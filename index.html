<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Strudel Mixer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        :root {
            color-scheme: light dark;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            background: #f0f2f5;
            color: #1c1c1c;
            padding: 1rem;
        }

        @media (prefers-color-scheme: dark) {
            body {
                background: #0f1115;
                color: #e6e9ef;
            }
        }

        header {
            padding: 1rem;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 1rem;
        }

        @media (prefers-color-scheme: dark) {
            header {
                background: rgba(24, 26, 32, 0.85);
            }
        }

        .header-main {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 2rem;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            letter-spacing: -0.02em;
        }

        .header-controls {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: flex-start;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            min-width: 0; /* allow children to shrink in tight containers */
        }

        /* Ensure the label and slider are consistently laid out:
           - label keeps a predictable width so long labels don't push the slider
           - slider uses flex so all sliders visually match regardless of surrounding text */
        .control-group > .control-label {
            flex: 0 0 110px; /* fixed label column width (adjustable) */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .control-group > .control-slider {
            flex: 1 1 200px; /* slider will take remaining space but stay consistent */
            width: auto; /* allow flexbox to control width */
            min-width: 120px;
            max-width: 420px;
        }

        .control-label {
            font-size: 0.85rem;
            opacity: 0.7;
            font-weight: 500;
        }

        .control-input {
            padding: 0.4rem 0.6rem;
            font-size: 0.9rem;
            border-radius: 6px;
            border: 2px solid rgba(0, 0, 0, 0.2);
            background: rgba(255, 255, 255, 0.7);
            color: inherit;
            font-weight: 500;
            width: 70px;
            text-align: center;
        }

        @media (prefers-color-scheme: dark) {
            .control-input {
                background: rgba(255, 255, 255, 0.1);
                border-color: rgba(255, 255, 255, 0.2);
            }
        }

        .control-input:focus {
            outline: 2px solid currentColor;
            outline-offset: 1px;
        }

        .control-slider {
            width: 120px;
            height: 6px;
            border-radius: 3px;
            background: rgba(0, 0, 0, 0.2);
            outline: none;
            appearance: none;
            -webkit-appearance: none;
        }

        @media (prefers-color-scheme: dark) {
            .control-slider {
                background: rgba(255, 255, 255, 0.2);
            }
        }

        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: currentColor;
            cursor: pointer;
            transition: transform 150ms ease;
        }

        .control-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .control-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: currentColor;
            cursor: pointer;
            border: none;
            transition: transform 150ms ease;
        }

        .control-slider::-moz-range-thumb:hover {
            transform: scale(1.2);
        }

        /* Loading screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 500ms ease, visibility 500ms ease;
        }

        @media (prefers-color-scheme: dark) {
            .loading-screen {
                background: #0f1115;
            }
        }

        .loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .loading-content {
            text-align: center;
            color: #1c1c1c;
        }

        @media (prefers-color-scheme: dark) {
            .loading-content {
                color: #e6e9ef;
            }
        }

        .loading-title {
            font-size: 3rem;
            font-weight: 700;
            margin: 0 0 1rem 0;
            letter-spacing: -0.02em;
        }

        .loading-subtitle {
            font-size: 1.2rem;
            opacity: 0.7;
            margin: 0 0 3rem 0;
            font-weight: 400;
        }

        .loading-dice {
            font-size: 5rem;
            margin: 0 auto 2rem;
            user-select: none;
            font-weight: 300;
        }

        .loading-progress {
            font-size: 0.9rem;
            opacity: 0.8;
            font-weight: 500;
            min-height: 1.5rem;
        }

        @keyframes rollDice {
            0% {
                transform: rotate(0deg) scale(1);
            }

            10% {
                transform: rotate(90deg) scale(1.05);
            }

            20% {
                transform: rotate(180deg) scale(1);
            }

            30% {
                transform: rotate(270deg) scale(1.05);
            }

            40% {
                transform: rotate(360deg) scale(1);
            }

            50% {
                transform: rotate(405deg) scale(1.02);
            }

            55% {
                transform: rotate(420deg) scale(1);
            }

            60% {
                transform: rotate(360deg) scale(1);
            }

            100% {
                transform: rotate(360deg) scale(1);
            }
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.05);
                opacity: 0.9;
            }
        }

        .header-main {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 2rem;
        }

        .add-slot-container {
            /* Keep add buttons on a single horizontal row. If there are more buttons
               than fit the viewport, allow horizontal scrolling instead of wrapping. */
            display: flex;
            gap: 0.75rem;
            padding: 0.5rem 0.75rem;
            border-radius: 8px;
            align-items: center;
            flex-wrap: nowrap; /* never wrap to next line */
            overflow-x: auto; /* allow scrolling when content is wider than container */
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
        }



        .add-slot-btn {
            aspect-ratio: 1;
            /* use a responsive width but allow it to shrink so many buttons fit on one line */
            width: clamp(56px, 7.5vw, 100px);
            flex: 0 0 auto; /* don't grow, but don't force a specific basis beyond width */
            padding: 0.4rem;
            font-size: 0.85rem;
            border: 2px solid var(--category-color);
            border-radius: 12px;
            cursor: pointer;
            transition: all 200ms ease;
            background: var(--category-color);
            color: inherit;
            font-weight: 600;
            opacity: 0.8;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            text-align: center;
            min-width: 48px;
        }

        .add-slot-btn-emoji {
            font-size: 2rem;
            line-height: 1;
            font-weight: 300;
        }

        .add-slot-btn-label {
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: capitalize;
        }

        .add-slot-btn:hover {
            opacity: 1;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .slot-type-picker {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            animation: slideIn 200ms ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .slot-type-option {
            padding: 0.5rem 1rem;
            border: 2px solid var(--category-color);
            background: var(--category-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 200ms ease;
            font-size: 0.9rem;
            font-weight: 500;
            opacity: 0.7;
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .slot-type-option:hover {
            opacity: 1;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .prompt-input {
            padding: 0.5rem 1rem;
            font-size: 0.95rem;
            border-radius: 8px;
            border: 2px solid currentColor;
            background: rgba(255, 255, 255, 0.5);
            color: inherit;
            font-weight: 500;
            min-width: 300px;
            flex: 1;
        }

        @media (prefers-color-scheme: dark) {
            .prompt-input {
                background: rgba(255, 255, 255, 0.1);
            }
        }

        .prompt-input::placeholder {
            opacity: 0.5;
        }

        .slot-prompt {
            flex: 1;
            padding: 0.4rem 0.6rem;
            font-size: 0.75rem;
            border-radius: 6px;
            border: 1px solid rgba(0, 0, 0, 0.2);
            background: rgba(255, 255, 255, 0.7);
            color: inherit;
            font-weight: 400;
            min-width: 0;
        }

        @media (prefers-color-scheme: dark) {
            .slot-prompt {
                background: rgba(255, 255, 255, 0.05);
                border-color: rgba(255, 255, 255, 0.2);
            }
        }

        .slot-prompt::placeholder {
            opacity: 0.5;
        }

        .slot-prompt:focus {
            outline: 2px solid currentColor;
            outline-offset: 1px;
        }

        .slot-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            flex-wrap: wrap;
        }

        .status {
            font-size: 0.85rem;
            opacity: 0.7;
        }

        .slots-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(450px, 1fr));
            gap: 0.5rem;
            flex: 1;
        }

        .slot {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            transition: all 300ms ease;
            border-left: 4px solid var(--slot-color);
            position: relative;
            animation: slotAppear 300ms ease-out;
        }

        @keyframes slotAppear {
            from {
                opacity: 0;
                transform: translateX(-20px) scale(0.95);
            }

            to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }
        }

        @keyframes slotDisappear {
            to {
                opacity: 0;
                transform: translateX(20px) scale(0.95);
            }
        }

        .slot.removing {
            animation: slotDisappear 300ms ease-out forwards;
        }

        @media (prefers-color-scheme: dark) {
            .slot {
                background: rgba(24, 26, 32, 0.85);
            }
        }

        /* When a slot is muted we want the slot content to appear dimmed/greyed,
       but keep the unmute button fully visible and clickable. Avoid using
       `opacity` on the parent because that also fades children. Instead
       render a semi-opaque overlay and dim specific content. */
        .slot.is-muted {
            transform: scale(0.98);
            /* create stacking context for overlay and controls */
            position: relative;
        }

        /* soft overlay that greys/dims the slot content but sits under header controls */
        .slot.is-muted::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 12px;
            pointer-events: none;
            z-index: 1;
            /* under controls which will be z-index:2+ */
            /* Use the slot color as the base for the overlay (rgb provided by JS).
         Fallback to white for light mode if the RGB variable isn't present. */
            background: rgba(var(--slot-color-rgb, 255, 255, 255), 0.18);
            mix-blend-mode: luminosity;
            transition: background 200ms ease, opacity 200ms ease;
        }

        /* dim code and decorative emoji more aggressively */
        .slot.is-muted .slot-code,
        .slot.is-muted .slot-code-emoji,
        .slot.is-muted .slot-prompt {
            opacity: 0.35;
        }

        /* ensure interactive controls remain clearly visible above the overlay */
        .slot .slot-mute-btn,
        .slot .slot-delete-btn,
        .slot .slot-dice,
        .slot .slot-spice,
        .slot .slot-rewind {
            position: relative;
            z-index: 3;
        }

        @media (prefers-color-scheme: dark) {

            /* use a darker overlay in dark mode so the dimming feels natural */
            .slot.is-muted::after {
                /* For dark mode, use a stronger tint from the slot color, falling back
           to a near-black if the variable isn't present. This avoids pure black
           while still providing sufficient dimming. */
                background: rgba(var(--slot-color-rgb, 10, 12, 16), 0.30);
                mix-blend-mode: normal;
            }
        }

        .slot-header {
            display: flex;
            flex-direction: column; /* two rows: top row (drag/mute/lifecycle), bottom row (controls) */
            justify-content: flex-start;
            align-items: stretch;
            margin-bottom: 0.75rem;
            gap: 0.5rem;
        }

        /* Make the top row items align horizontally */
        .slot-header > div:first-child {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 0.5rem;
        }

        .slot-mute-btn {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: 2px solid var(--slot-color);
            background: var(--slot-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 200ms ease;
            opacity: 0.9;
            flex-shrink: 0;
        }

        .slot-mute-btn:hover {
            opacity: 1;
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        /* When the slot is muted the button will usually toggle to an "unmute"
       state; keep it fully visible and obvious so the user can unmute quickly. */
        .slot-mute-btn.is-muted {
            opacity: 1;
            background: var(--slot-color);
            color: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: scale(1.05);
            border-color: rgba(0, 0, 0, 0.12);
        }

        .slot-delete-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid rgba(255, 80, 80, 0.8);
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 200ms ease;
            opacity: 0.4;
            color: rgba(255, 80, 80, 0.9);
        }

        .slot-delete-btn:hover {
            opacity: 1;
            transform: scale(1.1) rotate(90deg);
            background: rgba(255, 80, 80, 0.2);
        }

        .slot-color-indicator {
            display: none;
        }

        .slot-reload {
            display: none;
        }

        .slot-dice,
        .slot-spice,
        .slot-rewind {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            border: 2px solid currentColor;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            line-height: 1;
            transition: transform 200ms ease, background 200ms ease;
            opacity: 0.7;
            flex-shrink: 0;
            padding: 0;
        }

        .slot-dice:hover,
        .slot-spice:hover,
        .slot-rewind:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.05);
            transform: scale(1.15);
        }

        @media (prefers-color-scheme: dark) {

            .slot-dice:hover,
            .slot-spice:hover {
                background: rgba(255, 255, 255, 0.1);
            }
        }

        .slot-dice:active,
        .slot-spice:active,
        .slot-rewind:active {
            transform: scale(0.95) rotate(360deg);
        }

        .slot-dice:disabled,
        .slot-spice:disabled,
        .slot-rewind:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .slot-dice.rolling,
        .slot-spice.spicing,
        .slot-rewind.rewinding {
            opacity: 1 !important;
            pointer-events: none;
            font-size: 1.5rem;
            line-height: 1;
            animation: diceSpinCycle 0.4s ease-in-out infinite;
        }

        .slot-spice {
            border-color: currentColor;
        }

        @media (prefers-color-scheme: dark) {
            .slot-spice {
                border-color: currentColor;
            }
        }

        @keyframes diceSpinCycle {
            0% {
                transform: scale(1) rotate(0deg);
            }

            50% {
                transform: scale(1.2) rotate(180deg);
            }

            100% {
                transform: scale(1) rotate(360deg);
            }
        }

        @keyframes rewindPulse {
            0% { transform: scale(1) rotate(0deg); opacity: 1; }
            40% { transform: scale(1.18) rotate(-120deg); opacity: 1; }
            80% { transform: scale(0.98) rotate(-300deg); opacity: 0.95; }
            100% { transform: scale(1) rotate(-360deg); opacity: 1; }
        }

        .slot-rewind.rewinding {
            animation: rewindPulse 420ms cubic-bezier(.2,.9,.3,1) both;
        }

        .slot-code-wrapper {
            flex: 1;
            position: relative;
            display: flex;
        }

        .slot-code-emoji {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12rem;
            opacity: 0.12;
            pointer-events: none;
            z-index: 0;
            user-select: none;
            font-weight: 300;
        }

        .slot-code {
            flex: 1;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.8rem;
            line-height: 1.5;
            padding: 0.75rem;
            border: 1px solid rgba(0, 0, 0, 0.15);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.03);
            color: inherit;
            resize: vertical;
            min-height: 80px;
            position: relative;
            z-index: 1;
        }

        @media (prefers-color-scheme: dark) {
            .slot-code {
                background: rgba(0, 0, 0, 0.3);
                border-color: rgba(255, 255, 255, 0.15);
            }

            .slot-code-emoji {
                opacity: 0.1;
            }
        }

        .slot-code:focus {
            outline: 2px solid currentColor;
            outline-offset: 2px;
        }

        .slot-code::placeholder {
            opacity: 0.4;
            font-style: italic;
        }

        .slot.is-empty .slot-code {
            opacity: 0.5;
        }

        @keyframes flashBorder {

            0%,
            100% {
                border-color: rgba(0, 0, 0, 0.15);
                box-shadow: 0 0 0 0 currentColor;
            }

            50% {
                border-color: currentColor;
                box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.3);
            }
        }

        @media (prefers-color-scheme: dark) {
            @keyframes flashBorder {

                0%,
                100% {
                    border-color: rgba(255, 255, 255, 0.15);
                    box-shadow: 0 0 0 0 currentColor;
                }

                50% {
                    border-color: currentColor;
                    box-shadow: 0 0 0 3px rgba(100, 200, 255, 0.3);
                }
            }
        }

        .slot-code.flash {
            animation: flashBorder 400ms ease-out;
        }

        @media (min-width: 1200px) {
            /* Removed grid layout - using flexbox column instead */
        }

        @media (min-width: 768px) and (max-width: 1199px) {
            /* Removed grid layout - using flexbox column instead */
        }

        /* Drag handle styling */
        .slot-drag-handle {
            cursor: grab;
            padding: 0.25rem;
            opacity: 0.4;
            transition: opacity 200ms ease;
            font-size: 1.2rem;
            user-select: none;
        }

        /* Lifetime badge shown on a slot to indicate remaining bars */
        .slot-lifetime-badge {
            font-size: 0.75rem;
            padding: 0.18rem 0.45rem;
            border-radius: 6px;
            background: rgba(255,255,255,0.12);
            color: inherit;
            border: 1px solid rgba(0,0,0,0.06);
            margin-left: 0.25rem;
            min-width: 42px;
            text-align: center;
            font-weight: 600;
        }
    .slot-lifetime-badge { display: flex; align-items: center; gap: 0.35rem; cursor: default; flex: 1 1 auto; min-width: 0; }
    .slot-lifetime-badge.paused { opacity: 0.85; background: rgba(0,0,0,0.06); }
    .slot-lifetime-text { display: inline-block; min-width: 36px; text-align: center; transition: transform 160ms ease; }
    .slot-lifetime-progress { flex: 1 1 auto; width: auto; height: 6px; background: rgba(0,0,0,0.06); border-radius: 3px; overflow: hidden; }
    /* Use the slot color (rgb) for the progress bar so it matches the card highlight */
    .slot-lifetime-progress-bar { height:100%; width:100%; background: rgba(var(--slot-color-rgb, 0,0,0), 0.18); transform-origin: left center; transition: width 200ms linear; }
        .slot-lifetime-pin { background: transparent; border: none; cursor: pointer; padding: 0; font-size: 0.95rem; opacity: 0.85; }
        .slot-lifetime-badge.pinned { background: rgba(255,255,255,0.06); box-shadow: inset 0 0 0 1px rgba(0,0,0,0.04); }

        .slot-drag-handle:hover {
            opacity: 0.8;
        }

        .slot-drag-handle:active {
            cursor: grabbing;
        }

        .slot.dragging {
            opacity: 0.5;
            transform: scale(1.05);
        }

        .slot.drag-over {
            border-top: 3px solid var(--slot-color);
        }
    </style>
</head>

<body>
    <div class="loading-screen" id="loading-screen">
        <div class="loading-content">
            <div class="loading-title">Strudel Mixer</div>
            <div class="loading-subtitle">Preparing your musical playground...</div>
            <div class="loading-dice" id="loading-dice">⚀</div>
            <div class="loading-progress" id="loading-progress">Initializing...</div>
        </div>
    </div>

    <header>
        <div class="header-main">
            <div class="add-slot-container" id="add-slot-container">
                <!-- Layer type buttons will be generated by JavaScript -->
            </div>
            <div class="header-controls">
                <div class="control-group">
                    <label class="control-label" for="master-volume">Volume:</label>
                    <input type="range" id="master-volume" class="control-slider" min="0" max="1" step="0.01"
                        value="0.7">
                </div>
                <div class="control-group">
                    <label class="control-label" for="master-reverb">Reverb:</label>
                    <input type="range" id="master-reverb" class="control-slider" min="0" max="1" step="0.05" value="0">
                </div>
                <div class="control-group">
                    <label class="control-label" for="creativity">Creativity:</label>
                    <input type="range" id="creativity" class="control-slider" min="0" max="1" step="0.01" value="0.2">
                </div>
                <div style="display:flex;align-items:center;gap:0.6rem;">
                    <button id="auto-mode-btn" style="padding:0.36rem 0.9rem;font-weight:600;border-radius:8px;border:2px solid #2A9D8F;background:#2A9D8F;color:#fff;cursor:pointer;transition:background 0.2s;">Self-driving: Off</button>
                    <div id="status" class="status">Preparing Strudel…</div>
                </div>
            </div>
        </div>
    </header>

    <div class="slots-grid" id="slots-grid">
        <!-- Slots will be generated dynamically by JavaScript -->
    </div>

    <script type="module" src="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2"></script>
    <script src="https://unpkg.com/@strudel/web@1.0.3"></script>
    <script type="module">
        // Import Transformers.js
        import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2';

        // Disable local model loading
        env.allowLocalModels = false;

        (async () => {
            // --- SMARTER AUTO PRODUCER (self-driving) ---
            let autoMode = false;
            const autoBtn = document.getElementById('auto-mode-btn');
            // Disable Auto until initialization completes to avoid startup races
            try { if (autoBtn) autoBtn.disabled = true; } catch (e) {}
            function setAutoBtnState(on) {
                if (!autoBtn) return;
                autoBtn.textContent = on ? 'Self-driving: On' : 'Self-driving: Off';
                autoBtn.style.background = on ? '#2A9D8F' : '#888';
                autoBtn.style.borderColor = on ? '#2A9D8F' : '#888';
            }

            // Enhanced auto state with anchor motif and smarter timing
            let autoState = {
                phase: 'intro',
                barCount: 0,
                anchor: null, // { category: 'chords', desc: 'C G Am F' }
            };

            // More careful phase timings (bars). These are approximate and used for musical shape.
            const phasePlan = {
                intro:    { targetLayers: ['chords','texture'], desired: 2, addProb: 0.8, spiceProb: 0.08 },
                build:    { targetLayers: ['kick','snare','hihat','bass','chords','arp','texture'], desired: 5, addProb: 0.9, spiceProb: 0.14 },
                drop:     { targetLayers: ['kick','snare','hihat','bass','chords','arp','perc','melody','texture'], desired: 8, addProb: 0.9, spiceProb: 0.22 },
                breakdown:{ targetLayers: ['chords','texture','arp','melody'], desired: 3, addProb: 0.6, spiceProb: 0.12 },
                outro:    { targetLayers: ['chords','texture'], desired: 2, addProb: 0.6, spiceProb: 0.06 },
            };

            function pickPhase(barCount) {
                if (barCount < 8) return 'intro';
                if (barCount < 24) return 'build';
                if (barCount < 56) return 'drop';
                if (barCount < 72) return 'breakdown';
                if (barCount < 96) return 'drop';
                return 'outro';
            }

            // High-level style profiles to make Auto behave more like techno / house / ambient producers.
            // Tweak these to change overall Auto personality.
            // Note: while Auto (self-driving) is ON it will cycle through these styles automatically.
            let autoStyle = 'techno'; // current style (will be cycled when self-driving)
            const styles = ['techno','house','ambient'];
            let styleIndex = styles.indexOf(autoStyle) >= 0 ? styles.indexOf(autoStyle) : 0;
            const STYLE_CYCLE_BARS = 24; // how many auto 'bars' before changing style
            
            const styleProfiles = {
                techno: {
                    // core order: ensure rhythm foundation is created before melodic layers
                    ensureOrder: ['kick','bass','hihat','snare','arp','chords','texture'],
                    // reduce spicing on core rhythmic layers; prefer spicing textures and arp
                    spiceExclusion: ['kick','bass','hihat','snare'],
                    spiceMultiplier: 0.9,
                    // protect these from deletion/muting
                    protected: ['kick','bass'],
                    // prefer more rhythmic density
                    densityMultiplier: 1.1
                },
                house: {
                    ensureOrder: ['kick','hihat','bass','snare','chords','arp','texture'],
                    spiceExclusion: ['kick','bass'],
                    spiceMultiplier: 1.0,
                    protected: ['kick','bass'],
                    densityMultiplier: 1.0
                },
                ambient: {
                    ensureOrder: ['chords','texture','arp','melody','perc'],
                    spiceExclusion: ['kick','snare','hihat','bass'],
                    spiceMultiplier: 1.3,
                    protected: ['chords','texture'],
                    densityMultiplier: 0.7
                }
            };

            // Choose a category to add that complements existing layers
            function chooseCategoryForAdd(phase) {
                const plan = phasePlan[phase] || phasePlan.build;
                const present = slots.map(s => s.category);
                const profile = styleProfiles[autoStyle] || {};

                // Prefer missing layers from style-specific ensureOrder first
                if (profile.ensureOrder) {
                    const missingOrdered = profile.ensureOrder.filter(l => plan.targetLayers.includes(l) && !present.includes(l));
                    if (missingOrdered.length) return missingOrdered[0];
                }

                // Prefer missing important layers from phase plan
                const missing = plan.targetLayers.filter(l => !present.includes(l));
                if (missing.length) return missing[Math.floor(Math.random()*missing.length)];

                // Otherwise pick weighted by desirability with slight style density bias
                const weighted = plan.targetLayers.slice();
                const densityBias = profile.densityMultiplier || 1.0;
                // Duplicate desirable categories to increase probability in selection
                const pool = [];
                for (const t of weighted) {
                    const weight = Math.floor(1 + (Math.random() * densityBias * 2));
                    for (let i=0;i<weight;i++) pool.push(t);
                }
                return pool[Math.floor(Math.random()*pool.length)];
            }

            // Select a pattern that complements an anchor (if available) using precomputed embeddings.
            const selectComplementaryPattern = async (category, anchorDesc) => {
                try {
                    // If we have embeddings and extractor, pick semantically similar patterns to anchor
                    if (patternEmbeddingsCache && anchorDesc && extractor) {
                        // Compute embedding for anchor text (normalize for consistency)
                        const normalizedAnchor = normalizeText(anchorDesc);
                        const emb = await extractor(normalizedAnchor, { pooling: 'mean', normalize: true });
                        const anchorVec = Array.from(emb.data);
                        // Filter patterns of requested category
                        const candidates = patternEmbeddingsCache.filter(p => p.category === category);
                        if (candidates.length === 0) return null;
                        // Score by cosine similarity
                        candidates.forEach(c => { c.sim = cosineSimilarity(anchorVec, c.embedding); });
                        candidates.sort((a,b) => b.sim - a.sim);
                        // pick one of top 4 with slight randomness
                        const top = candidates.slice(0, Math.min(4, candidates.length));
                        return top[Math.floor(Math.random()*top.length)].code;
                    }
                    // Fallback: random from library
                    const lib = patternLibrary[category] || Object.values(patternLibrary).flat().filter(p=>p.category===category);
                    if (!lib || lib.length === 0) {
                        const all = Object.values(patternLibrary).flat();
                        return all[Math.floor(Math.random()*all.length)].code;
                    }
                    return lib[Math.floor(Math.random()*lib.length)].code;
                } catch (e) {
                    console.warn('selectComplementaryPattern failed:', e);
                    const lib = patternLibrary[category] || Object.values(patternLibrary).flat();
                    return lib[Math.floor(Math.random()*lib.length)].code;
                }
            };

            // Determine bars to schedule for a newly added layer based on phase
            // Determine bars to schedule for a newly added layer based on phase and category
            // TTS/vocal elements are short flourishes (accents) — keep them brief so they
            // describe recent events instead of acting as long-lived anchors.
            const barsForPhase = (phase, category = null) => {
                let base;
                switch (phase) {
                    case 'intro': base = 8; break;
                    case 'build': base = 12; break;
                    case 'drop': base = 16; break;
                    case 'breakdown': base = 8; break;
                    case 'outro': base = 6; break;
                    default: base = 8; break;
                }

                // If this is a vocal/tts element, keep it short — 1..3 bars depending on phase
                if (category === 'tts') {
                    if (phase === 'drop' || phase === 'build') return 3; // slightly longer accent
                    if (phase === 'intro' || phase === 'breakdown') return 2;
                    return 1; // outro or default: very short
                }

                return base;
            };

            // Create a new slot and immediately populate it with a chosen pattern (no UI dice click)
            // NOTE: when Auto is running, enforce at-most-one active TTS slot by reusing an existing
            // TTS slot instead of creating a new one. This prevents multiple concurrent TTS slots.
            const createAndPopulateSlot = async (category, promptHint = '', phase = 'build', isAuto = false) => {
                // If auto created and requesting a TTS slot, try to reuse an existing live TTS slot
                // instead of creating a new one.
                try {
                    if (isAuto && category === 'tts' && Array.isArray(slots)) {
                        // Prefer the currently active TTS slot if present
                        let existing = null;
                        try { if (typeof activeTtsSlotId !== 'undefined' && activeTtsSlotId) existing = slots.find(s => s && s.id === activeTtsSlotId); } catch (e) { existing = null; }
                        // Fallback: find any live TTS slot in the DOM
                        if (!existing) existing = slots.find(s => s && s.category === 'tts' && s.element && s.element.parentNode);
                        if (existing) {
                            // Ensure existing slot is a suitable candidate for reuse.
                            try {
                                // A: skip pinned slots - do not reuse pinned TTS slots for Auto flourishes
                                if (existing.pinned) existing = null;

                                // B: avoid reusing a slot that's about to expire. If the remaining lifetime
                                // is less than half of the requested TTS lifetime for this phase, treat as near-expiry.
                                if (existing && existing.lifetimeExpiresAt) {
                                    try {
                                        const remainingMs = existing.lifetimeExpiresAt - Date.now();
                                        const barsNeeded = Math.max(1, barsForPhase(phase, 'tts') || 2);
                                        const barMs = (typeof getBarMs === 'function') ? getBarMs() : 2000;
                                        const thresholdMs = barsNeeded * barMs * 0.5; // reuse only if more than half remains
                                        if (remainingMs < thresholdMs) {
                                            existing = null;
                                        }
                                    } catch (e) { /* ignore timing issues and fall back to creating a new slot */ }
                                }
                            } catch (e) { /* ignore and proceed to create a new slot */ }

                            // Update prompt/sample if a hint is provided
                            if (promptHint) {
                                try { if (existing.promptInput) existing.promptInput.value = promptHint; } catch (e) {}
                                try { if (existing.textarea) existing.textarea.dataset.ttsText = promptHint; } catch (e) {}
                                // If no sample exists, generate one async (don't block reuse)
                                if (!existing.currentTtsSampleName) {
                                    (async () => {
                                        try {
                                            const sampleName = await generateTTSSample(promptHint);
                                            existing.currentTtsSampleName = sampleName;
                                            try { if (existing.textarea) existing.textarea.dataset.ttsSampleName = sampleName; } catch (e) {}
                                            // set a simple default code if missing
                                            try {
                                                if (!existing.code || !existing.code.trim()) {
                                                    existing.code = `s("${sampleName}:0").speed(1)`;
                                                    if (existing.textarea) existing.textarea.value = existing.code;
                                                }
                                            } catch (e) {}
                                        } catch (e) { /* ignore generation failures */ }
                                    })();
                                }
                            }
                            // Ensure this slot is marked active and other TTS slots muted
                            try { ensureOnlyOneVocalPlays(existing); } catch (e) {}
                            try { scheduleSlotLifetime(existing, barsForPhase(phase, 'tts')); } catch (e) {}
                            return existing;
                        }
                    }
                } catch (e) { console.warn('TTS reuse check failed:', e); }

                const slot = createSlot(category);
                slots.push(slot);
                slotsGrid.appendChild(slot.element);
                // choose a pattern: prefer to align with anchor if available
                const anchorDesc = autoState.anchor ? autoState.anchor.desc : (promptHint || 'groovy');

                // Try to use the existing dice-roll UI flow so history, animations and TTS registration are handled uniformly.
                const promptForRoll = promptHint || anchorDesc || (category + ' pattern');

                // If the slot exposes a prompt input, set it so the dice handler will use it
                try { if (slot.promptInput) slot.promptInput.value = promptForRoll; } catch (e) {}

                // Helper: wait for slot.code to be set by the dice handler
                const waitForSlotCode = async (s, timeoutMs = 3500) => {
                    const start = Date.now();
                    while (Date.now() - start < timeoutMs) {
                        if (s && s.code && s.code.trim()) return true;
                        await sleep(200);
                    }
                    return false;
                };

                let obtained = false;
                try {
                    if (slot.diceButton && !slot.diceButton.disabled) {
                        // Trigger the same UI dice behavior the user would use
                        try { slot.diceButton.click(); } catch (e) { console.warn('dice click failed:', e); }
                        // Wait briefly for the dice handler to populate the slot
                        obtained = await waitForSlotCode(slot, 4500);
                    }
                } catch (e) { /* ignore */ }

                // If dice flow failed (no code set), fallback to semantic selection/generation
                if (!obtained) {
                    // Special-case TTS: if we couldn't trigger the dice handler for a TTS slot,
                    // explicitly generate/register a TTS sample and assign TTS-style code so
                    // we don't accidentally populate the TTS slot with unrelated instrument
                    // patterns (which was causing TTS slots to contain non-tts code).
                    if (category === 'tts') {
                        try {
                            const ttsPrompt = promptForRoll || (autoState && autoState.anchor && autoState.anchor.desc) || 'Hello';
                            // generate/register the concrete sampleName for this prompt
                            const sampleName = await generateTTSSample(ttsPrompt);

                            // small set of TTS variations (keep in sync with dice handler)
                            const ttsVariations = [
                                `s("${sampleName}:0").speed(1)`,
                                `s("${sampleName}:0").speed(0.9).room(0.5)`,
                                `s("${sampleName}:0").speed(1.1).delay(0.25)`,
                                `s("${sampleName}:0").chop(4).speed(0.95)`,
                                `s("${sampleName}:0").chop(8).room(0.3)`,
                                `s("${sampleName}:0").n("0 ~ 0 ~").speed(1)`
                            ];

                            let ttsCode = ttsVariations[Math.floor(Math.random() * ttsVariations.length)];
                            ttsCode = maybeApplyNaturalSkipToCode(ttsCode);

                            slot.code = ttsCode;
                            try {
                                slot.textarea.value = ttsCode;
                                slot.textarea.dataset.ttsText = ttsPrompt;
                                slot.textarea.dataset.ttsSampleName = sampleName;
                                if (slot.promptInput) slot.promptInput.value = ttsPrompt;
                                slot.currentTtsSampleName = sampleName;
                            } catch (e) { /* ignore UI sync errors */ }

                            slot._lastCommittedCode = slot.code;
                            obtained = true;
                            // Debug: log auto-created TTS assignment so we can trace races
                            try {
                                if (isAuto && category === 'tts') {
                                    console.log('[DEBUG][AUTO][TTS] created tts slot', { prompt: ttsPrompt, sampleName, code: slot.code });
                                }
                            } catch (e) {}
                        } catch (e) {
                            console.warn('Auto fallback TTS generation failed:', e);
                            // fall through to generic path below as a last resort
                        }
                    }

                    if (!obtained) {
                        let code = null;
                        try {
                            if (extractor && patternEmbeddingsCache) {
                                const comp = await selectComplementaryPattern(category, anchorDesc);
                                if (comp) code = comp;
                            }
                        } catch (e) { /* ignore */ }

                        if (!code) {
                            try {
                                const res = await generatePatternFromPrompt(promptForRoll, category);
                                code = res.code;
                                // If this was a chords or melody creation, set anchor
                                if (category === 'chords' || category === 'melody') {
                                    autoState.anchor = { category, desc: res.description || promptForRoll };
                                }
                            } catch (e) {
                                const pool = patternLibrary[category] || Object.values(patternLibrary).flat();
                                code = pool[Math.floor(Math.random()*pool.length)].code;
                            }
                        }

                        // apply small natural variation
                        code = maybeApplyNaturalSkipToCode(code);
                        slot.code = code;
                        try { slot.textarea.value = code; } catch (e) {}
                        slot._lastCommittedCode = slot.code;
                        // Debug: if a TTS slot ends up with non-tts code, log details (helps catch race conditions)
                        try {
                            if (category === 'tts' && isAuto) {
                                const looksLikeTTS = typeof slot.code === 'string' && /s\(".*:0"\)/.test(slot.code);
                                if (!looksLikeTTS) {
                                    console.warn('[DEBUG][AUTO][TTS] tts slot filled with non-tts code', { code: slot.code, promptForRoll, phase, stack: (new Error()).stack.split('\n').slice(0,5) });
                                }
                            }
                        } catch (e) {}
                        obtained = true;
                    }
                }

                // schedule lifetime aligned with phase. Auto-created TTS flourishes should be
                // very short (max 2 bars). UI flows (dice handler) explicitly schedule 8 bars
                // so they remain unchanged.
                try {
                    let lifeBars = barsForPhase(phase, category);
                    if (category === 'tts' && isAuto) {
                        lifeBars = Math.min(2, lifeBars);
                    }
                    scheduleSlotLifetime(slot, lifeBars);
                } catch (e) {}

                // ensure playback
                if (!slot.isMuted) {
                    try { ensureOnlyOneVocalPlays(slot); } catch (e) {}
                    refreshPlayback();
                }

                // record most-recent prompt for Auto to use for TTS
                try {
                    let candidate = null;
                    if (slot.promptInput && typeof slot.promptInput.value === 'string' && slot.promptInput.value.trim()) candidate = slot.promptInput.value.trim();
                    else if (slot.textarea && slot.textarea.dataset && typeof slot.textarea.dataset.ttsText === 'string' && slot.textarea.dataset.ttsText.trim()) candidate = slot.textarea.dataset.ttsText.trim();
                    else if (slot._lastCommittedCode && typeof slot._lastCommittedCode === 'string') candidate = slot._lastCommittedCode.substring(0, 160);
                    if (candidate) lastAddedSlotPrompt = candidate;
                } catch (e) { /* ignore safely */ }

                return slot;
            };

            async function autoStepSmart() {
                autoState.barCount += 1;
                const phase = pickPhase(autoState.barCount);

                // While self-driving, cycle the global auto style every STYLE_CYCLE_BARS
                try {
                    if (autoMode && STYLE_CYCLE_BARS > 0 && (autoState.barCount % STYLE_CYCLE_BARS) === 0) {
                        styleIndex = (styleIndex + 1) % styles.length;
                        autoStyle = styles[styleIndex];
                        console.log('Self-driving switched style ->', autoStyle);
                        // brief visual cue on the button
                        if (autoBtn) {
                            autoBtn.style.boxShadow = '0 0 0 6px rgba(42,157,143,0.08)';
                            setTimeout(() => { try { if (autoBtn) autoBtn.style.boxShadow = ''; } catch (e) {} }, 600);
                        }
                        // update status line briefly if present
                        const st = document.getElementById && document.getElementById('status');
                        if (st) {
                            const activeCount = slots.filter(s => s.code && !s.isMuted).length;
                            st.textContent = `${slots.length} layers (${activeCount} active) — ${autoStyle}`;
                        }
                    }
                } catch (e) {
                    console.warn('Style cycling error:', e);
                }
                // Occasionally update anchor by picking a chord/melody to drive the track
                if (!autoState.anchor || Math.random() < 0.12) {
                    // find an existing chord or melody slot to use as anchor
                    const anchorSlot = slots.find(s => (s.category === 'chords' || s.category === 'melody') && s.code);
                    if (anchorSlot) {
                        // derive description from stored prompt or sample
                        const desc = anchorSlot.promptInput && anchorSlot.promptInput.value ? anchorSlot.promptInput.value : (anchorSlot._lastCommittedCode || 'harmonic bed');
                        autoState.anchor = { category: anchorSlot.category, desc };
                    }
                }

                // Add new layers if track needs density — with style-aware core-order enforcement
                const plan = phasePlan[phase];
                const profile = styleProfiles[autoStyle] || {};

                // Try to gradually ensure core order (create foundational layers first) — gentle probability so it doesn't flood
                        if (profile.ensureOrder && Math.random() < 0.7) {
                    for (const want of profile.ensureOrder) {
                        const present = slots.find(s => s.category === want);
                        if (!present && slots.length < Math.max(2, plan.desired) && Math.random() < 0.9) {
                            await createAndPopulateSlot(want, null, phase, true);
                            // Optionally add a short TTS flourish describing what was just added
                            try {
                                const prompt = lastAddedSlotPrompt || (autoState && autoState.anchor && autoState.anchor.desc) || `${want}`;
                                // small chance to create a TTS flourish immediately after creating a core layer
                                if (prompt && Math.random() < 0.35) {
                                    // create but don't await — keep Auto responsive
                                    createAndPopulateSlot('tts', `${prompt}`, phase, true)
                                        .then(s => { try { ensureOnlyOneVocalPlays(s); scheduleSlotLifetime(s, barsForPhase(phase, 'tts')); } catch(e){} })
                                        .catch(e => console.warn('Auto tts flourish failed:', e));
                                }
                            } catch (e) {}
                            await sleep(180 + Math.random()*240);
                            break; // create one core at a time to feel human
                        }
                    }
                }

                // Standard density-driven adds (style density affects prob indirectly via chooseCategoryForAdd)
                if (slots.length < plan.desired && Math.random() < plan.addProb * (profile.densityMultiplier || 1)) {
                    const cat = chooseCategoryForAdd(phase);
                    await createAndPopulateSlot(cat, null, phase, true);
                    // After adding a regular layer, sometimes add a short vocal flourish describing it
                    try {
                        const prompt = lastAddedSlotPrompt || (autoState && autoState.anchor && autoState.anchor.desc) || null;
                        if (prompt && Math.random() < 0.24) {
                            const phrase = `${prompt}`;
                            createAndPopulateSlot('tts', phrase, phase, true)
                                .then(s => { try { ensureOnlyOneVocalPlays(s); scheduleSlotLifetime(s, barsForPhase(phase, 'tts')); } catch(e){} })
                                .catch(e => console.warn('Auto tts flourish failed:', e));
                        }
                    } catch (e) {}
                    await sleep(200 + Math.random()*300);
                }

                // Fill empty slots quickly
                for (const slot of slots) {
                        if (!slot.code && !slot.isMuted) {
                        // try to populate existing empty slot using its dice button (preferred)
                        try {
                            const prompt = autoState.anchor ? autoState.anchor.desc : null;
                            if (slot.promptInput && typeof slot.promptInput.value === 'string') {
                                try { slot.promptInput.value = prompt || slot.promptInput.placeholder || (slot.category + ' pattern'); } catch (e) {}
                            }
                            if (slot.diceButton && !slot.diceButton.disabled) {
                                    try { slot.diceButton.click(); await sleep(500); } catch (e) { /* ignore */ }
                                    // small wait to let dice handler populate
                                    await sleep(400 + Math.random()*300);
                                    if (!slot.code) {
                                        // as a fallback, call createAndPopulateSlot to create a new filled slot
                                        await createAndPopulateSlot(slot.category, prompt, phase, true);
                                        // create a short vocal flourish occasionally
                                        try {
                                            const p = lastAddedSlotPrompt || prompt || (autoState && autoState.anchor && autoState.anchor.desc) || slot.category;
                                            if (p && Math.random() < 0.22) {
                                                createAndPopulateSlot('tts', `${p}`, phase, true)
                                                    .then(s => { try { ensureOnlyOneVocalPlays(s); scheduleSlotLifetime(s, barsForPhase(phase, 'tts')); } catch(e){} })
                                                    .catch(e => console.warn('Auto tts flourish failed:', e));
                                            }
                                        } catch (e) {}
                                    }
                            } else {
                                // no dice available on this slot; create a fresh populated slot instead
                                await createAndPopulateSlot(slot.category, prompt, phase, true);
                                try { autoMaybeGenerateTTSFromMostRecent(lastAddedSlotPrompt).catch(e=>console.warn('Auto TTS error:', e)); } catch (e) {}
                            }
                        } catch (e) {}
                    }
                }

                // Evolve existing layers according to phase spice probability
                {
                    const profile = styleProfiles[autoStyle] || {};
                    const effectiveSpiceProb = (plan.spiceProb || 0.08) * (profile.spiceMultiplier || 1);
                    if (Math.random() < effectiveSpiceProb) {
                        // Prefer non-core and non-protected categories for spicing
                        const spiceCandidates = slots.filter(s => s.code && !s.isMuted && s.spiceButton && !s.spiceButton.disabled && (!profile.spiceExclusion || !profile.spiceExclusion.includes(s.category)));
                        const fallbackCandidates = slots.filter(s => s.code && !s.isMuted && s.spiceButton && !s.spiceButton.disabled);
                        const targetPool = spiceCandidates.length ? spiceCandidates : fallbackCandidates;
                        if (targetPool.length > 0) {
                            const s = targetPool[Math.floor(Math.random()*targetPool.length)];
                            s.spiceButton.click();
                            await sleep(120 + Math.random()*160);
                        }
                    }
                }

                // Subtle arrangement moves: mute/unmute or delete less relevant layers over time
                {
                    const profile = styleProfiles[autoStyle] || {};
                    // Prefer muting non-protected, non-core layers
                    if (Math.random() < 0.07 && slots.length > 3) {
                        const muteCandidates = slots.filter(s => !s.isMuted && (!profile.protected || !profile.protected.includes(s.category)) && ['perc','hihat','texture','arp'].includes(s.category));
                        if (muteCandidates.length > 0) {
                            const s = muteCandidates[Math.floor(Math.random()*muteCandidates.length)];
                            s.muteButton.click();
                            await sleep(90);
                        }
                    }

                    // Unmute a core layer for energy (but avoid unmuting if it's protected and intentionally muted)
                    if (Math.random() < 0.06 && slots.length > 2) {
                        const unmuteCandidates = slots.filter(s => s.isMuted && ['kick','snare','bass','chords','melody'].includes(s.category));
                        if (unmuteCandidates.length > 0) {
                            const s = unmuteCandidates[Math.floor(Math.random()*unmuteCandidates.length)];
                            // Avoid unmuting a protected anchor if it's intentionally off
                            const anchorCat = autoState && autoState.anchor && autoState.anchor.category;
                            if (!anchorCat || s.category !== anchorCat) {
                                s.muteButton.click();
                                await sleep(90);
                            }
                        }
                    }
                }

                // Periodically shape the mix — IMPORTANT: do NOT modify the global master volume or reverb here.
                // Instead, nudge per-slot levels (if present) and gently adjust creativity to influence generation.
                if (Math.random() < 0.06) {
                    try {
                        // Map phase -> target energy (0..1)
                        const phaseEnergyMap = { intro: 0.5, build: 0.72, drop: 0.98, breakdown: 0.38, outro: 0.28 };
                        const phaseEnergy = phaseEnergyMap[phase] || 0.6;
                        // Combine with creativity to get a local 'energy' value
                        const energy = Math.min(1, Math.max(0, phaseEnergy * (0.5 + 0.5 * creativity)));

                        // Try to nudge a few core slot levels (if slot DOM exposes a volume control).
                        // This is intentionally non-destructive and will silently skip if no control exists.
                        const coreCats = ['kick','snare','bass','chords','melody'];
                        const coreSlots = slots.filter(s => coreCats.includes(s.category) && !s.isMuted);

                        for (const s of coreSlots) {
                            try {
                                // Prefer an explicit slider element inside the slot DOM (class 'slot-volume')
                                const volEl = s.element && s.element.querySelector && s.element.querySelector('.slot-volume');
                                if (volEl && typeof volEl.value !== 'undefined') {
                                    const cur = parseFloat(volEl.value) || 0.7;
                                    // Small nudge toward the 'energy' target
                                    const target = Math.min(1, Math.max(0, cur * (0.7 + energy * 0.5)));
                                    volEl.value = target.toFixed(2);
                                    // If slot provides a handler for volume changes, call it (safe no-op if absent)
                                    if (typeof s.onVolumeChange === 'function') s.onVolumeChange(target);
                                }
                            } catch (e) {
                                // ignore any per-slot volume errors — we won't touch globals
                            }
                        }

                        // Slightly nudge creativity to vary behavior over time (small change only)
                        const newCreat = Math.min(0.99, Math.max(0, creativity + (Math.random() - 0.5) * 0.08));
                        creativitySlider.value = newCreat.toFixed(2);
                        creativity = parseFloat(creativitySlider.value);

                        // Apply changes to playback (refresh only; do not alter global masterVolume/masterReverb)
                        refreshPlayback();
                    } catch (e) {
                        console.warn('Auto mix shaping skipped due to error:', e);
                    }
                }

                // In outro, wind down more aggressively — but protect the anchor layer from being deleted
                if (phase === 'outro' && slots.length > 0 && Math.random() < 0.35) {
                    const d = pickLayerToDelete(phase);
                    if (d) {
                        const anchorCat = autoState && autoState.anchor && autoState.anchor.category;
                        // Protect anchor and vocal (tts) layers from aggressive deletion.
                        // Allow deleting tts only if there are many layers and with lower probability.
                        const isVocal = d.category === 'tts';
                        if (anchorCat && d.category === anchorCat) {
                            // do not delete the anchor
                        } else if (isVocal) {
                            // only delete vocal layers rarely
                            if (slots.length > 4 && Math.random() < 0.12) {
                                d.deleteButton.click();
                                await sleep(80);
                            }
                        } else {
                            d.deleteButton.click();
                            await sleep(80);
                        }
                    }
                }

                // If we're in an outro and the track seems to be ending, continue into a new "song":
                // rotate style, reset auto state and seed a foundational layer so Self-driving never fully stops.
                if (phase === 'outro') {
                    try {
                        // Conservative end-of-song heuristics: long play (>STYLE_CYCLE_BARS*4) or very few layers left
                        const longPlay = autoState.barCount >= (STYLE_CYCLE_BARS * 4);
                        const fewLayers = slots.length <= 1;

                        if (longPlay || fewLayers) {
                            // advance style
                            styleIndex = (styleIndex + 1) % styles.length;
                            autoStyle = styles[styleIndex];
                            console.log('Self-driving continuing into new style ->', autoStyle);

                            // reset state for a fresh section
                            autoState.barCount = 0;
                            autoState.phase = 'intro';
                            autoState.anchor = null;

                            // Brief visual/status feedback
                            if (autoBtn) {
                                autoBtn.style.transform = 'scale(1.04)';
                                setTimeout(() => { try { if (autoBtn) autoBtn.style.transform = ''; } catch (e) {} }, 280);
                            }
                            if (statusEl) {
                                const activeCount = slots.filter(s => s.code && !s.isMuted).length;
                                statusEl.textContent = `${slots.length} layers (${activeCount} active) — ${autoStyle}`;
                            }

                            // Seed one foundational layer for the new style (first ensureOrder) if missing
                            const profile = styleProfiles[autoStyle] || {};
                            if (profile.ensureOrder && profile.ensureOrder.length > 0) {
                                const primary = profile.ensureOrder[0];
                                const present = slots.find(s => s.category === primary);
                                if (!present) {
                                    await createAndPopulateSlot(primary, null, 'intro', true);
                                    await sleep(220 + Math.random() * 180);
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('Failed to continue self-driving after outro:', e);
                    }
                }
            }

            let autoLoopRunning = false;
            async function autoLoopSmart() {
                if (autoLoopRunning) return;
                autoLoopRunning = true;
                try {
                    // If there's no anchor, try to pick an existing chord/melody slot as anchor
                    if (!autoState.anchor) {
                        const anchorSlot = slots.find(s => (s.category === 'chords' || s.category === 'melody') && s.code);
                        if (anchorSlot) {
                            const desc = anchorSlot.promptInput && anchorSlot.promptInput.value ? anchorSlot.promptInput.value : (anchorSlot._lastCommittedCode || 'harmonic bed');
                            autoState.anchor = { category: anchorSlot.category, desc };
                        }
                    }

                    // Ensure phase aligns to barCount
                    autoState.phase = pickPhase(autoState.barCount || 0);

                    while (autoMode) {
                        await autoStepSmart();
                        await sleep(1400 + Math.random()*700);
                    }
                } finally {
                    autoLoopRunning = false;
                }
            }

            if (autoBtn) {
                autoBtn.addEventListener('click', () => {
                    autoMode = !autoMode;
                    setAutoBtnState(autoMode);

                    if (autoMode) {
                        // Pick a random style when Self-driving is turned on
                        try {
                            styleIndex = Math.floor(Math.random() * styles.length);
                            autoStyle = styles[styleIndex];
                            console.log('Self-driving ENABLED, selected style ->', autoStyle);
                            if (statusEl) {
                                const activeCount = slots.filter(s => s.code && !s.isMuted).length;
                                statusEl.textContent = `${slots.length} layers (${activeCount} active) — ${autoStyle}`;
                            }
                        } catch (e) { console.warn('Could not pick random style:', e); }

                        // Start the loop if not already running. Defensive: if initialization
                        // hasn't finished (createSlot / slots not ready) autoLoopSmart may
                        // throw a ReferenceError; catch and retry until initialization settles.
                        if (!autoLoopRunning) {
                            (function tryStartAuto(attempts = 0) {
                                (async () => {
                                    try {
                                        if (!autoLoopRunning) await autoLoopSmart();
                                    } catch (err) {
                                        // If a ReferenceError occurred because code isn't initialized,
                                        // retry shortly (but avoid infinite loops).
                                        if (err && err.name === 'ReferenceError' && attempts < 30) {
                                            console.warn('Auto start deferred until initialization:', err.message);
                                            setTimeout(() => tryStartAuto(attempts + 1), 200);
                                        } else {
                                            console.error('Auto start failed:', err);
                                        }
                                    }
                                })();
                            })();
                        }
                    }
                });
                setAutoBtnState(false);
            }
            const statusEl = document.getElementById('status');
            const slotsGrid = document.getElementById('slots-grid');
            const addSlotContainer = document.getElementById('add-slot-container');
            const masterVolumeSlider = document.getElementById('master-volume');
            const masterReverbSlider = document.getElementById('master-reverb');
            const creativitySlider = document.getElementById('creativity');
            const loadingScreen = document.getElementById('loading-screen');
            const loadingProgress = document.getElementById('loading-progress');
            const loadingDice = document.getElementById('loading-dice');
            const slots = []; // Will hold slot data dynamically
            // Track most-recently added slot prompt (used by Auto for TTS inputs)
            let lastAddedSlotPrompt = null;
            let slotIdCounter = 0; // Unique ID for each slot
            let masterVolume = 0.7;
            let masterReverb = 0;
            let creativity = 0.7; // 0 = deterministic, 1 = most creative/random

            // Dice animation for loading screen
            const diceFaces = ['⚀', '⚁', '⚂', '⚃', '⚄', '⚅'];
            let diceIndex = 0;
            let diceInterval = null;

            const startDiceAnimation = () => {
                if (diceInterval) return;
                diceInterval = setInterval(() => {
                    diceIndex = (diceIndex + 1) % diceFaces.length;
                    if (loadingDice) {
                        loadingDice.textContent = diceFaces[diceIndex];
                    }
                }, 200);
            };

            // Add occasional natural rhythmic "skips" to a pattern code so TTS isn't too repetitive
            const maybeApplyNaturalSkipToCode = (code) => {
                try {
                    // Probability to inject skips is influenced by creativity (more creative => more skips)
                    const baseProbability = 0.6;
                    const prob = Math.min(0.95, baseProbability + (creativity * 0.3));
                    if (Math.random() > prob) return code; // no change

                    // Find an existing .n("pattern") call and probabilistically insert rests (~) into the pattern
                    const nRegex = /\.n\(\s*([`'"])([^"`']+)\1\s*\)/;
                    const nMatch = nRegex.exec(code);
                    if (nMatch) {
                        const patternStr = nMatch[2];
                        const tokens = patternStr.split(/\s+/).filter(t => t.length > 0);
                        const skipChance = 0.35 + (creativity * 0.35); // higher creativity -> more skips
                        const newTokens = tokens.map(tok => {
                            // Leave obvious special tokens alone
                            if (tok.includes('~') || tok.includes('(') || tok.includes(')') || tok.includes('<') || tok.includes('>') || tok.includes('[') || tok.includes(']')) return tok;
                            // If token looks like a numeric note or a simple named sample/pitch token, maybe replace with a rest
                            if (/^[0-9a-zA-Z_]+$/.test(tok) && Math.random() < skipChance) return '~';
                            return tok;
                        });

                        const newPattern = newTokens.join(' ');
                        code = code.replace(nRegex, `.n("${newPattern}")`);
                    }

                    // Also check for `.struct("pattern")` and modify 'x' hits into rests probabilistically
                    const structRegex = /\.struct\(\s*([`'"])([^"`']+)\1\s*\)/;
                    const structMatch = structRegex.exec(code);
                    if (structMatch) {
                        const patternStr = structMatch[2];
                        const tokens = patternStr.split(/\s+/).filter(t => t.length > 0);
                        const skipChance = 0.25 + (creativity * 0.45);
                        const newTokens = tokens.map(tok => {
                            // Only consider plain 'x' tokens as hits to replace
                            if (tok === 'x' && Math.random() < skipChance) return '~';
                            return tok;
                        });
                        const newPattern = newTokens.join(' ');
                        return code.replace(structRegex, `.struct("${newPattern}")`);
                    }

                    // If there's no .n() in the code, append a simple pattern that incorporates rests
                    const candidatePatterns = ['.n("0 ~ 0 ~")', '.n("0 ~ ~ 0")', '.n("0 ~ ~ ~")', '.n("0 !4")', '.n("0 !8")'];
                    const chosen = candidatePatterns[Math.floor(Math.random() * candidatePatterns.length)];
                    return code + chosen;
                } catch (e) {
                    console.warn('Could not apply skip to pattern code:', e);
                    return code;
                }
            };

            const stopDiceAnimation = () => {
                if (diceInterval) {
                    clearInterval(diceInterval);
                    diceInterval = null;
                }
            };

            startDiceAnimation();

            // Function to animate dice rolling on a button - cycles through faces while busy
            const animateDiceRoll = (button, callback, animationType = 'rolling') => {
                const diceFaces = ['⚀', '⚁', '⚂', '⚃', '⚄', '⚅'];
                const spiceFaces = ['✦', '✧', '⚛', '※', '⁂', '❋'];

                const faces = animationType === 'spicing' ? spiceFaces : diceFaces;
                let faceIndex = 0;

                button.disabled = true;
                button.classList.add(animationType);

                // Cycle through faces in order, repeating continuously
                const rollInterval = setInterval(() => {
                    button.innerHTML = faces[faceIndex];
                    faceIndex = (faceIndex + 1) % faces.length; // Loop back to start
                }, 400); // Match the animation duration

                // Execute callback and stop animation when done
                if (callback) {
                    callback().finally(() => {
                        clearInterval(rollInterval);
                        // Pick a final random face to land on
                        const finalFace = faces[Math.floor(Math.random() * faces.length)];
                        button.innerHTML = finalFace;
                        button.classList.remove(animationType);
                        button.disabled = false;
                    });
                }
            };

            // Loading progress messages
            const updateLoadingProgress = (message) => {
                loadingProgress.textContent = message;
            };

            // Load the semantic similarity model (using efficient smaller model for fast loading)
            updateLoadingProgress('Loading model...');
            statusEl.textContent = 'Loading model...';
            let extractor = null;
            let patternEmbeddingsCache = null; // Cache for pre-computed pattern embeddings

            try {
                // Using all-MiniLM-L6-v2: efficient model (22M params) for fast loading and good semantic understanding
                // Much smaller than all-mpnet-base-v2 (420M) while maintaining strong performance
                extractor = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
                console.log('AI model loaded successfully');
                updateLoadingProgress('AI model ready ✓');
            } catch (e) {
                console.error('Failed to load AI model:', e);
                updateLoadingProgress('AI model failed (continuing without AI features)');
            }

            // TTS Web Worker - using module worker to avoid blocking the main thread
            let ttsWorker = null;
            let ttsWorkerReady = false;
            const ttsWorkerPromises = new Map();
            let ttsRequestId = 0;

            const initTTSWorker = async () => {
                if (ttsWorker) return ttsWorker;

                // Create a module worker that can use ES imports
                const workerCode = `
          import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2';
          
          // Disable local model loading
          env.allowLocalModels = false;
          
          let model = null;
          
          self.onmessage = async function(e) {
            const { id, type, text } = e.data;
            
            try {
              if (type === 'init') {
                console.log('[Worker] Loading TTS model...');
                model = await pipeline('text-to-speech', 'Xenova/speecht5_tts', { quantized: false });
                console.log('[Worker] TTS model loaded!');
                self.postMessage({ id, type: 'ready' });
              } else if (type === 'generate') {
                if (!model) {
                  throw new Error('Model not initialized');
                }
                
                console.log('[Worker] Generating speech for:', text);
                const result = await model(text, {
                  speaker_embeddings: 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/speaker_embeddings.bin'
                });
                
                console.log('[Worker] Speech generated!');
                self.postMessage({
                  id,
                  type: 'result',
                  audio: Array.from(result.audio),
                  sampling_rate: result.sampling_rate
                });
              }
            } catch (error) {
              console.error('[Worker] Error:', error);
              self.postMessage({
                id,
                type: 'error',
                message: error.message
              });
            }
          };
        `;

                // Create a blob URL with module type
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const workerUrl = URL.createObjectURL(blob);

                try {
                    // Create module worker
                    ttsWorker = new Worker(workerUrl, { type: 'module' });

                    ttsWorker.onmessage = (e) => {
                        const { id, type } = e.data;

                        if (type === 'ready') {
                            ttsWorkerReady = true;
                            console.log('TTS Worker ready!');
                            if (ttsWorkerPromises.has(id)) {
                                ttsWorkerPromises.get(id).resolve();
                                ttsWorkerPromises.delete(id);
                            }
                        } else if (type === 'result') {
                            if (ttsWorkerPromises.has(id)) {
                                ttsWorkerPromises.get(id).resolve(e.data);
                                ttsWorkerPromises.delete(id);
                            }
                        } else if (type === 'error') {
                            if (ttsWorkerPromises.has(id)) {
                                ttsWorkerPromises.get(id).reject(new Error(e.data.message));
                                ttsWorkerPromises.delete(id);
                            }
                        }
                    };

                    ttsWorker.onerror = (error) => {
                        console.error('TTS Worker error:', error);
                    };

                    // Initialize the worker (load model)
                    console.log('Initializing TTS worker...');
                    const initId = ttsRequestId++;
                    await new Promise((resolve, reject) => {
                        ttsWorkerPromises.set(initId, { resolve, reject });
                        ttsWorker.postMessage({ id: initId, type: 'init' });
                    });

                    return ttsWorker;
                } catch (e) {
                    console.error('Failed to create TTS worker:', e);
                    throw e;
                }
            };

            // Generate TTS using the worker
            const generateTTSAudio = async (text) => {
                if (!ttsWorker) {
                    await initTTSWorker();
                }

                const id = ttsRequestId++;
                const result = await new Promise((resolve, reject) => {
                    ttsWorkerPromises.set(id, { resolve, reject });
                    ttsWorker.postMessage({ id, type: 'generate', text });
                });

                return {
                    audio: result.audio,
                    sampling_rate: result.sampling_rate
                };
            };

            // Pre-generate some common TTS samples to avoid blocking during playback
            // This happens in the background after page load
            const preWarmTTS = async () => {
                try {
                    await new Promise(resolve => setTimeout(resolve, 3000)); // Wait 3s after load
                    console.log('Pre-generating TTS samples...');
                    const commonPhrases = [];
                    for (const phrase of commonPhrases) {
                        // Generate a prompt-specific sample name for each phrase to avoid clobbering
                        await generateTTSSample(phrase);
                        await new Promise(resolve => setTimeout(resolve, 500)); // Small delay between
                    }
                    console.log('TTS samples pre-generated and ready!');
                } catch (e) {
                    console.log('TTS pre-warming skipped:', e.message);
                }
            };

            // Define slot categories for complementary layering
            const slotCategories = [
                { name: 'chords', icon: '♬', desc: 'Chords & Harmony', color: '#F4A261' },
                { name: 'texture', icon: '○', desc: 'Texture & FX', color: '#2A9D8F' },
                { name: 'bass', icon: '▬', desc: 'Bass & Low End', color: '#457B9D' },
                { name: 'kick', icon: '■', desc: 'Kick & Bass Drum', color: '#E63946' },
                { name: 'hihat', icon: '≡', desc: 'Hi-hats & Cymbals', color: '#F77F00' },
                { name: 'snare', icon: '●', desc: 'Snare & Clap', color: '#EF476F' },
                { name: 'perc', icon: '◐', desc: 'Percussion & Accents', color: '#F4A261' },
                { name: 'arp', icon: '✦', desc: 'Arpeggiator', color: '#FF69B4' },
                { name: 'melody', icon: '◇', desc: 'Melodic Elements', color: '#A8DADC' },
                { name: 'tts', icon: '◼', desc: 'Speech', color: '#E9C46A' }
            ];

            // Pattern library with natural language descriptions focused on feelings, moods, and vibes
            // Normalized `desc` values use a consistent lowercase pattern: "<short phrase> for <purpose/character>"
            const patternLibrary = {
                // Separated drum component categories for modern electronic music
                kick: [
                    { desc: "four on the floor kick for dancefloor", code: 's("bd*4").gain(0.95).lpf(600).room(0.05)', literal: "four-on-the-floor", tempo: "fast", density: "steady", energy: "high", mood: "dance" },
                    { desc: "808 sub kick with spaced hits for club", code: 's("808bd").n("0 ~ 0 ~").lpf(250).gain(0.95)', literal: "808 sub kick", tempo: "medium", density: "medium", energy: "high", mood: "club" },
                    { desc: "punchy techno house kick with grit for driving energy", code: 's("bd").n("0 !4").gain(0.98).distort(0.06).lpf(500)', literal: "punchy techno kick", tempo: "fast", density: "steady", energy: "driving", mood: "intense" },
                    { desc: "minimal pulsing kick for hypnotic grooves", code: 's("bd").n("0!4").lpf(350).gain(0.85)', literal: "minimal pulse kick", tempo: "medium", density: "steady", energy: "medium", mood: "hypnotic" },
                    { desc: "two-step garage kick for a heart beat", code: 's("bd").struct("x ~ x ~").early("<0 0.06>*4").gain(0.9).lpf(400)', literal: "syncopated 2-step kick", tempo: "medium", density: "medium", energy: "medium", mood: "skippy" }
                ],
                snare: [
                    { desc: "classic backbeat snare for dancefloor", code: 's("sd").struct("~ x ~ x").gain(0.95).room(0.12)', literal: "backbeat snare/clap", tempo: "fast", density: "steady", energy: "high", mood: "dance" },
                    { desc: "tight snare with short decay for punch", code: 's("sd").gain(0.96).lpf(2400)', literal: "tight punch snare", tempo: "medium", density: "medium", energy: "high", mood: "punchy" },
                    { desc: "half-time trap snare with long tail for moody vibe", code: 's("sd").slow(2).struct("~ x ~ x").gain(0.9).room(0.25)', literal: "half-time trap snare", tempo: "slow", density: "sparse", energy: "medium", mood: "moody" },
                    { desc: "snare roll fill in eighths for excited energy", code: 's("sd!8").sometimes(x=>x.fast(2)).gain(0.9).room(0.2)', literal: "snare roll/fill", tempo: "fast", density: "high", energy: "high", mood: "excited" },
                    { desc: "stacked clap for epic drops and builds", code: 's("realclaps").n("0").gain(0.95).room(0.6).lpf(3000)', literal: "stacked clap for impact", tempo: "fast", density: "low", energy: "very high", mood: "epic" }
                ],
                hihat: [
                    { desc: "steady 16th closed hats for driving grooves", code: 's("hh*16").gain(0.85).hcutoff(10000)', literal: "steady 16th closed hats", tempo: "fast", density: "high", energy: "driving", mood: "club" },
                    { desc: "triplet hat rolls for punchy trap patterns", code: 's("hh!16").struct("x(3,8)").gain(0.9).hcutoff(11000)', literal: "triplet hat rolls", tempo: "medium", density: "very high", energy: "punchy", mood: "intense" },
                    { desc: "shuffled swung hats for garage pocket", code: 's("hh").struct("x(3,8)").early("<0 0.06>").gain(0.75)', literal: "shuffled swung hats", tempo: "medium", density: "medium", energy: "bouncy", mood: "swing" },
                    { desc: "sparse high-end hats for minimal chill grooves", code: 's("hh").struct("x ~ ~ x").gain(0.5).hpf(300)', literal: "sparse hats", tempo: "slow", density: "low", energy: "subtle", mood: "chill" }
                ],
                perc: [
                    { desc: "16th shaker pulse for groove", code: 's("perc").struct("x(11,16)").gain(0.35).hpf(4500).room(0.08)', literal: "shaker pulse", tempo: "fast", density: "high", energy: "medium", mood: "groovy" },
                    { desc: "syncopated rim and conga accents for pocket", code: 's("tabla").struct("~ x ~ ~").early("<0 0.04>").gain(0.46)', literal: "rim/conga accents", tempo: "medium", density: "medium", energy: "medium", mood: "skippy" },
                    { desc: "metallic ping hits for contrast and edge", code: 's("metal").struct("x(5,16)").gain(0.5).distort(0.08).hpf(800)', literal: "metallic percussive hits", tempo: "variable", density: "low", energy: "high", mood: "edgy" },
                    { desc: "top end clicks and sparkles for accents", code: 's("oc").gain(0.2).hpf(5000).sometimes(x=>x.fast(2))', literal: "top-end clicks", tempo: "fast", density: "low", energy: "low", mood: "sparkly" },
                    { desc: "textural crackle bed for warmth", code: 's("pebbles").gain(0.18).degradeBy(0.15).room(0.18)', literal: "lo‑fi percussive texture", tempo: "variable", density: "low", energy: "low", mood: "warm" }
                ],
                bass: [
                    { desc: "four on the floor sub pulse for house", code: 's("subroc3d").n("0!4").lpf(300).gain(0.9)', literal: "four-on-the-floor sub pulse", genre: "house", register: "sub", movement: "pulsing", timbre: "deep", rhythm: "steady" },
                    { desc: "pitched 808 sub pattern for trap", code: 's("808bd").n("0 ~ [0 1] ~").lpf(200).gain(0.95)', literal: "pitched 808 sub", genre: "trap", register: "sub", movement: "thumping", timbre: "clean", rhythm: "syncopated" },
                    { desc: "rolling saw bass for trance and progressive", code: 's("jungbass").n("<0 7 9>").fast(2).lpf(900).gain(0.8)', literal: "rolling saw bass", genre: "trance", register: "mid-bass", movement: "rolling", timbre: "sweeping", rhythm: "flowing" },
                    { desc: "reese detuned layered bass for weight and drive", code: 's("bass").n("0 0 5 0").lpq(4).distort(0.16).gain(0.9)', literal: "reese-style layered bass", genre: "drum & bass", register: "mid-bass", movement: "pulsing", timbre: "thick", rhythm: "driving" },
                    { desc: "perlin wobble sub for growly dubstep bass", code: 's("jungbass").n("0").lpf(perlin.range(80,400)).gain(0.88).distort(0.06)', literal: "perlin-wobble sub", genre: "dubstep", register: "sub", movement: "wobbling", timbre: "growly", rhythm: "sparse" },
                    { desc: "acid resonant bass stab for squelchy character", code: 's("jvbass").n("<0 3 5>").lpq(10).distort(0.12).gain(0.8)', literal: "acid resonant bass", genre: "acid", register: "mid-bass", movement: "squelchy", timbre: "resonant", rhythm: "steady" }
                ],
                melody: [
                    { desc: "plucked arpeggio for rhythmic hooks", code: 's("pluck").n("<0 4 7>").clip(2).gain(0.6)', literal: "plucked arpeggio", genre: "house", range: "mid" },
                    { desc: "wide saw lead for drops and mains", code: 's("juno").n("<0 5 9>").lpf(2000).gain(0.7).delay(0.12)', literal: "wide saw lead", genre: "edm", range: "high" },
                    { desc: "bell-like motif for top-end sparkle", code: 's("newnotes").n("<0 7 1 2 4 >").delay(0.8).gain(0.65).room(0.6)', literal: "bell-like motif", genre: "ambient", range: "high" },
                    { desc: "vocal chop motif for texture and hooks", code: 's("mouth").chop(8).n("<0 4 7>").gain(0.45).delay(0.08)', literal: "vocal chop", genre: "pop/edm", range: "mid" },
                    { desc: "minimal piano motif for emotional anchors", code: 's("notes").n("<0 3 7>").lpf(1200).gain(0.5)', literal: "minimal piano motif", genre: "minimal", range: "mid" }
                ],
                chords: [
                    { desc: "chord progression for anthemic dance music", code: 'note("<[c3,e3,g3] [g2,b2,d3] [a2,c3,e3] [f2,a2,c3]>").slow(2).lpf(1200).gain(0.85).room(0.6)', literal: "C G Am F", genre: "edm" },
                    { desc: "chord progression for emotive dance music", code: 'note("<[a2,c3,e3] [f2,a2,c3] [c3,e3,g3] [g2,b2,d3]>").slow(2).lpf(1000).gain(0.8).room(0.55)', literal: "Am F C G", genre: "pop/edm" },
                    { desc: "minor drop loop for driving hook", code: 'note("<[a2,c3,e3] [e2,g2,b2] [f2,a2,c3] [g2,b2,d3]>").slow(1).lpf(1500).gain(0.9).delay(0.08)', literal: "Am Em F G", genre: "dance" },
                    { desc: "chord progression for lush ambient uplift", code: 'note("<[c3,d3,g3] [f3,g3,c4]>").slow(2).lpf(1000).gain(0.5).room(0.7)', literal: "Cadd9 Fadd9", genre: "ambient" },
                    { desc: "two chord vamp for tension and release", code: 'note("<[d2,f2,a2] [a2,c3,e3]>").slow(2).lpf(1400).gain(0.65).room(0.4)', literal: "Dm Am", genre: "edm" }
                ],
                texture: [
                    { desc: "subtle shaker and vinyl crackle for warmth", code: 's("perc").struct("x(11,16)").gain(0.18).hpf(4500).room(0.15)', literal: "subtle shaker pulse and vinyl crackle", genre: "house", frequency: "mid", density: "medium", character: "groovy", placement: "background" },
                    { desc: "dark atmos and vocal grains for depth", code: 's("noise2").n("0").slow(8).gain(0.12).lpf(1200).room(0.35).sometimes(x=>s("mouth").chop(16).gain(0.08))', literal: "dark atmos and vocal grains", genre: "trap/ambient", frequency: "low-mid", density: "sparse", character: "atmospheric", placement: "background" },
                    { desc: "top end sparkle and percussive flourishes for accents", code: 's("feelfx").sometimes(x=>x.fast(2)).gain(0.25).hcutoff(10000).pan(perlin.range(0,1))', literal: "sparkle FX and flourishes", genre: "electronic", frequency: "high", density: "low", character: "sparkly", placement: "accent" },
                    { desc: "field recordings and outdoor ambience for realism", code: 's("outdoor").gain(0.28).lpf(2500).room(0.4)', literal: "outdoor ambient field layer", genre: "organic", frequency: "variable", density: "sustained", character: "recorded", placement: "background" },
                    { desc: "soft mechanical clicks and micro impulses for rhythm glue", code: 's("oc").gain(0.18).hpf(5000).sometimes(x=>x.chop(8))', literal: "mechanical clicks for glue", genre: "minimal", frequency: "very high", density: "low", character: "clicky", placement: "top" },
                    { desc: "percussive metallic gated textures for edgy foreground", code: 's("glitch").struct("x(5,16)").gain(0.4).distort(0.15).delay(0.06)', literal: "percussive metallic gated textures", genre: "glitch", frequency: "mid-high", density: "medium", character: "metallic", placement: "foreground" }
                ],
                arp: [
                    { desc: "simple plucked chord arpeggio for clarity", code: 'n("c eb g c4").clip(2).s("pluck")', literal: "simple chord arpeggio", tempo: "medium", density: "medium", energy: "low", mood: "melodic" },
                    { desc: "scale-based arpeggio with rhythmic variation for bounce", code: 'n("0 2 4 7").scale("C:minor").clip(2).s("pluck")', literal: "scale-based arpeggio", tempo: "medium", density: "medium", energy: "medium", mood: "uplifting" },
                    { desc: "chord-symbol arpeggio with voiced voicings for harmonic richness", code: 'n("0 1 2 3").chord("Cm").mode("above:c3").voicing().clip(2).s("pluck")', literal: "chord symbol arpeggio", tempo: "medium", density: "medium", energy: "medium", mood: "harmonic" },
                    { desc: "off beat arpeggio with polyrhythmic displacements for groove", code: 'n("0").off(1/3, add(2)).off(1/2, add(4)).scale("C:minor").s("pluck")', literal: "off-beat arpeggio", tempo: "medium", density: "medium", energy: "medium", mood: "groovy" },
                    { desc: "fast glittering arpeggio for buildups and tension", code: 'n("0 2 4 7").fast(2).clip(1).s("pluck")', literal: "fast glitter arpeggio", tempo: "fast", density: "high", energy: "high", mood: "tense" },
                    { desc: "sparse ambient arpeggio with slow envelopes for ethereal pads", code: 'n("0").slow(4).s("pad").gain(0.28).room(0.6)', literal: "ambient slow arpeggio", tempo: "slow", density: "low", energy: "low", mood: "ethereal" },
                    { desc: "motoric repeating arpeggio for trance and techno drive", code: 'n("0!8").fast(1.5).s("pluck").lpf(1200)', literal: "motoric repeating arpeggio", tempo: "fast", density: "high", energy: "high", mood: "driving" },
                    { desc: "granular chopped arpeggio for experimental textures", code: 'n("0 2 4").chop(16).sometimes(x=>x.rev()).s("pluck").gain(0.35)', literal: "granular chopped arpeggio", tempo: "variable", density: "high", energy: "medium", mood: "experimental" },
                    { desc: "basic triad up-down arpeggio for melodic clarity", code: 'n("0 2 4 2").chord("C").clip(2).s("pluck")', literal: "basic triad up-down", tempo: "medium", density: "medium", energy: "low", mood: "melodic" },
                    { desc: "scale run arpeggio with smooth contour for flowing melody", code: 'n("0 1 2 3 4 3 2 1").scale("C:major").clip(2).s("pluck")', literal: "scale run up and down", tempo: "medium", density: "medium", energy: "medium", mood: "flowing" },
                    { desc: "rhythmic triad arpeggio with off beats for groove", code: 'n("0 2 4").struct("x ~ x").chord("C").clip(2).s("pluck")', literal: "rhythmic triad pattern", tempo: "medium", density: "medium", energy: "medium", mood: "groovy" },
                    { desc: "inverted arpeggio starting from the top for descending motion", code: 'n("4 2 0").chord("C").clip(2).s("pluck")', literal: "inverted triad descent", tempo: "medium", density: "medium", energy: "low", mood: "descending" },
                    { desc: "seventh chord arpeggio for richer harmony", code: 'n("0 2 4 6").chord("Cm7").clip(2).s("pluck")', literal: "seventh chord arpeggio", tempo: "medium", density: "medium", energy: "medium", mood: "rich" },
                    { desc: "fast octave bounce for energetic movement", code: 'n("<0 4>").chord("C").fast(2).clip(2).s("pluck")', literal: "fast octave bounce", tempo: "fast", density: "high", energy: "high", mood: "bouncy" },
                    { desc: "sparse arpeggio with wide intervals for spacious textures", code: 'n("0 4").chord("C").slow(2).clip(2).s("pluck")', literal: "sparse wide arpeggio", tempo: "slow", density: "low", energy: "low", mood: "sparse" },
                ],
                // tts legacy patterns intentionally omitted; TTS is handled by dedicated slot type
            };

            let hasDirtSamples = false;
            let sampleStatusSuffix = '';
            let ttsAudioBuffers = {};  // Store generated TTS audio buffers by text
            const getSchedulerApi = () => window.strudel ?? null;
            let schedulerApi = null;

            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
            const getNow = () => (typeof performance !== 'undefined' && typeof performance.now === 'function'
                ? performance.now()
                : Date.now());

            // Helper function to compute cosine similarity between two embeddings
            const cosineSimilarity = (a, b) => {
                let dotProduct = 0;
                let normA = 0;
                let normB = 0;
                for (let i = 0; i < a.length; i++) {
                    dotProduct += a[i] * b[i];
                    normA += a[i] * a[i];
                    normB += b[i] * b[i];
                }
                return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
            };

            // Normalize text before embedding to reduce sensitivity to small wording differences
            const normalizeText = (text) => {
                if (!text || typeof text !== 'string') return '';
                try {
                    // Unicode normalize and lower-case
                    let s = text.normalize('NFC');
                    s = s.toLowerCase();

                    // Common token mappings (expand or canonicalize frequent phrases)
                    s = s.replace(/4-on-the-floor|4 on the floor|four-on-the-floor/gi, 'four on the floor');
                    s = s.replace(/hi-?hat/gi, 'hi hat');

                    // Remove punctuation (keep alphanumerics and spaces)
                    s = s.replace(/[\u2012\u2013\u2014\u2015]/g, ' '); // various dashes
                    s = s.replace(/[^\p{L}\p{N} ]+/gu, ' ');

                    // Collapse whitespace
                    s = s.replace(/\s+/g, ' ').trim();

                    // Optional lightweight synonym mapping
                    s = s.replace(/\bbd\b/g, 'kick');
                    s = s.replace(/\bsd\b/g, 'snare');
                    s = s.replace(/\bhh\b/g, 'hihat');

                    return s;
                } catch (e) {
                    return text.toLowerCase();
                }
            };

            // Pre-compute embeddings for all patterns (one-time operation)
            // Each comma-separated element in pattern.desc gets its own embedding
            const precomputePatternEmbeddings = async () => {
                if (!extractor) return null;

                // Generate a cache key based on the pattern library structure (bump when normalization/grouping changes)
                const cacheKey = 'strudel_pattern_embeddings_v2';
                const libraryHashKey = 'strudel_pattern_library_hash_v2';

                // Create a hash of the pattern library to detect changes (use full JSON to be safe)
                const libraryHash = JSON.stringify(patternLibrary);

                try {
                    // Check if we have cached embeddings
                    const cachedEmbeddings = localStorage.getItem(cacheKey);
                    const cachedHash = localStorage.getItem(libraryHashKey);

                    if (cachedEmbeddings && cachedHash === libraryHash) {
                        console.log('✅ Loading cached pattern embeddings from browser storage');
                        updateLoadingProgress('Loading cached embeddings...');
                        const cache = JSON.parse(cachedEmbeddings);
                        console.log(`Loaded ${cache.length} cached pattern embeddings`);
                        return cache;
                    }
                } catch (e) {
                    console.warn('Could not load cached embeddings:', e);
                }

                updateLoadingProgress('Analyzing pattern library...');
                statusEl.textContent = 'Pre-computing pattern embeddings...';
                const cache = [];

                let processedCount = 0;
                let totalDescriptions = 0;

                // Count total descriptions (each comma-separated element)
                for (const patterns of Object.values(patternLibrary)) {
                    for (const pattern of patterns) {
                        const descriptions = pattern.desc.split(',').map(d => d.trim()).filter(d => d.length > 0);
                        totalDescriptions += descriptions.length;
                    }
                }

                for (const [category, patterns] of Object.entries(patternLibrary)) {
                    for (const pattern of patterns) {
                        // Split description by commas - each becomes a separate embedding
                        const descriptions = pattern.desc.split(',').map(d => d.trim()).filter(d => d.length > 0);

                        // Build literal metadata text based on category
                        let literalText = pattern.literal || '';

                        // Add category-specific metadata to embedding text
                        if ((category === 'kick' || category === 'snare' || category === 'hihat' || category === 'perc') && pattern.tempo && pattern.density && pattern.energy && pattern.mood) {
                            literalText += ` tempo: ${pattern.tempo}, density: ${pattern.density}, energy: ${pattern.energy}, mood: ${pattern.mood}`;
                        } else if (category === 'bass' && pattern.register && pattern.movement && pattern.timbre && pattern.rhythm) {
                            literalText += ` register: ${pattern.register}, movement: ${pattern.movement}, timbre: ${pattern.timbre}, rhythm: ${pattern.rhythm}`;
                        } else if (category === 'melody' && pattern.range && pattern.contour && pattern.texture && pattern.articulation) {
                            literalText += ` range: ${pattern.range}, contour: ${pattern.contour}, texture: ${pattern.texture}, articulation: ${pattern.articulation}`;
                        } else if (category === 'chords' && pattern.voicing && pattern.quality && pattern.density && pattern.rhythm) {
                            literalText += ` voicing: ${pattern.voicing}, quality: ${pattern.quality}, density: ${pattern.density}, rhythm: ${pattern.rhythm}`;
                        } else if (category === 'texture' && pattern.frequency && pattern.density && pattern.character && pattern.placement) {
                            literalText += ` frequency: ${pattern.frequency}, density: ${pattern.density}, character: ${pattern.character}, placement: ${pattern.placement}`;
                        }

                        for (const desc of descriptions) {
                            // Combine description with literal metadata for embedding
                            const embeddingText = literalText ? `${desc}, ${literalText}` : desc;
                            // Normalize embedding text to match prompt normalization
                            const normalizedEmbeddingText = normalizeText(embeddingText);
                            const embedding = await extractor(normalizedEmbeddingText, { pooling: 'mean', normalize: true });
                            cache.push({
                                code: pattern.code,
                                desc: desc, // Individual description phrase
                                fullDesc: pattern.desc, // Keep full description for reference
                                literal: pattern.literal || '', // Include literal description
                                category,
                                embedding: Array.from(embedding.data)
                            });
                            processedCount++;

                            // Update progress and yield to event loop every 5 embeddings
                            if (processedCount % 5 === 0 || processedCount === totalDescriptions) {
                                updateLoadingProgress(`Analyzing patterns... ${processedCount}/${totalDescriptions}`);
                                await new Promise(resolve => setTimeout(resolve, 0)); // Yield to event loop
                            }
                        }
                    }
                }

                // Cache the embeddings in localStorage
                try {
                    localStorage.setItem(cacheKey, JSON.stringify(cache));
                    localStorage.setItem(libraryHashKey, libraryHash);
                    console.log(`✅ Cached ${cache.length} pattern embeddings to browser storage`);
                } catch (e) {
                    console.warn('Could not cache embeddings to localStorage:', e);
                }

                console.log(`Pre-computed ${cache.length} pattern embeddings from ${totalDescriptions} descriptions`);
                return cache;
            };

            // IndexedDB helper for TTS caching
            const openTTSCache = () => {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('StrudelTTSCache', 1);

                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('tts')) {
                            db.createObjectStore('tts', { keyPath: 'text' });
                        }
                    };
                });
            };

            const getCachedTTS = async (text) => {
                try {
                    const db = await openTTSCache();
                    return new Promise((resolve, reject) => {
                        const transaction = db.transaction(['tts'], 'readonly');
                        const store = transaction.objectStore('tts');
                        const request = store.get(text);

                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                } catch (e) {
                    console.warn('Could not access TTS cache:', e);
                    return null;
                }
            };

            const saveTTSToCache = async (text, audioData, samplingRate) => {
                try {
                    const db = await openTTSCache();
                    return new Promise((resolve, reject) => {
                        const transaction = db.transaction(['tts'], 'readwrite');
                        const store = transaction.objectStore('tts');
                        const request = store.put({
                            text: text,
                            audio: Array.from(audioData), // Convert Float32Array to regular array for storage
                            sampling_rate: samplingRate,
                            timestamp: Date.now()
                        });

                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                } catch (e) {
                    console.warn('Could not save TTS to cache:', e);
                }
            };

            // Generate TTS audio and register it as a Strudel sample
            // Deterministic, URL-safe sample name derived from the TTS prompt
            const sampleNameForPrompt = (prompt) => {
                if (!prompt) return `tts_${Date.now()}`;
                try {
                    // Encode Unicode safely, base64 it, make it URL-safe and truncate
                    const b64 = btoa(unescape(encodeURIComponent(prompt)));
                    const urlSafe = b64.replace(/=+$/, '').replace(/\+/g, '-').replace(/\//g, '_');
                    return `tts_${urlSafe.slice(0, 20)}`;
                } catch (e) {
                    // Fallback deterministic-ish hash
                    const hash = Math.abs(Array.from(prompt).reduce((h, c) => ((h << 5) - h) + c.charCodeAt(0), 0));
                    return `tts_${hash.toString(36)}`;
                }
            };

            // Map prompt -> registered sample name for quick reuse
            const ttsSampleNameByPrompt = {};

            // Generate TTS audio and register it as a Strudel sample (returns sampleName)
            const generateTTSSample = async (text, providedSampleName = null) => {
                if (!text || !text.trim()) throw new Error('Empty TTS text');

                const sampleName = providedSampleName || sampleNameForPrompt(text);

                // If we've previously registered this prompt under a name, reuse it
                if (ttsSampleNameByPrompt[text]) {
                    // If the mapped name differs from sampleName, prefer mapped name (reused)
                    if (ttsSampleNameByPrompt[text] !== sampleName) {
                        console.log('Reusing existing sample name for prompt:', ttsSampleNameByPrompt[text]);
                        return ttsSampleNameByPrompt[text];
                    }
                    // otherwise fall through and return sampleName after confirming registration
                }

                // In-memory cache check
                if (ttsAudioBuffers[text]) {
                    console.log('✅ Using in-memory cached TTS audio for:', text);
                    ttsSampleNameByPrompt[text] = sampleName;
                    return sampleName;
                }

                const getMostRecentSlotPrompt = () => {
                    try {
                        // Prefer any explicit most-recent prompt captured by createAndPopulateSlot
                        try {
                            if (typeof lastAddedSlotPrompt === 'string' && lastAddedSlotPrompt.trim()) return lastAddedSlotPrompt.trim();
                        } catch (e) {}

                        if (!Array.isArray(slots) || slots.length === 0) return null;
                        // Prefer the newest slot in the array (assumed to be the most-recently added)
                        const s = slots[slots.length - 1];
                        if (!s) return null;

                        // Try common locations for a prompt text in a defensive order
                        try {
                            if (s.promptInput && typeof s.promptInput.value === 'string' && s.promptInput.value.trim()) return s.promptInput.value.trim();
                        } catch (e) {}
                        try {
                            if (s.textarea && s.textarea.dataset && typeof s.textarea.dataset.ttsText === 'string' && s.textarea.dataset.ttsText.trim()) return s.textarea.dataset.ttsText.trim();
                        } catch (e) {}
                        try {
                            if (s._lastCommittedCode && typeof s._lastCommittedCode === 'string' && s._lastCommittedCode.trim()) return s._lastCommittedCode.trim();
                        } catch (e) {}

                        // Fallback: search backwards through slots to find any prompt-like content
                        for (let i = slots.length - 1; i >= 0; i--) {
                            const t = slots[i];
                            try { if (t.promptInput && typeof t.promptInput.value === 'string' && t.promptInput.value.trim()) return t.promptInput.value.trim(); } catch (e) {}
                            try { if (t.textarea && t.textarea.dataset && typeof t.textarea.dataset.ttsText === 'string' && t.textarea.dataset.ttsText.trim()) return t.textarea.dataset.ttsText.trim(); } catch (e) {}
                        }
                        return null;
                    } catch (e) {
                        return null;
                    }
                };

                // Attempt to generate/register a TTS sample from the most-recent slot prompt.
                // This is intentionally non-blocking for Auto: it returns a Promise but callers
                // should not need to await it; errors are caught and logged.
                // Attempt to generate/register a TTS sample from the most-recent prompt.
                // For Auto we avoid scanning the shared `slots` array to prevent races.
                // Small debounce/locking for auto TTS generation to avoid rapidly
                // generating duplicate samples for the same prompt.
                const AUTO_TTS_DEBOUNCE_MS = 3000; // 3 seconds
                const autoTtsLocks = new Map(); // prompt -> { promise, ts }

                const autoMaybeGenerateTTSFromMostRecent = async (promptOverride = null) => {
                    try {
                        const prompt = promptOverride || (typeof lastAddedSlotPrompt === 'string' && lastAddedSlotPrompt.trim() ? lastAddedSlotPrompt.trim() : null);
                        if (!prompt) return null;

                        // If we already have a registered sample for this prompt, return it.
                        if (ttsSampleNameByPrompt && ttsSampleNameByPrompt[prompt]) {
                            return ttsSampleNameByPrompt[prompt];
                        }

                        // If a generation for this prompt is already in-flight, reuse its promise.
                        const existing = autoTtsLocks.get(prompt);
                        if (existing && existing.promise) {
                            // If the lock is recent, return the in-flight promise to avoid duplicate work.
                            if (Date.now() - existing.ts < AUTO_TTS_DEBOUNCE_MS) {
                                // console.debug('Auto TTS: reusing in-flight generation for prompt:', prompt);
                                return existing.promise;
                            }
                        }

                        // Start a new generation and record the promise in the lock map.
                        const p = (async () => {
                            try {
                                const name = await generateTTSSample(prompt);
                                try { if (name && ttsSampleNameByPrompt) ttsSampleNameByPrompt[prompt] = name; } catch (e) {}
                                console.log('Auto: generated TTS for prompt:', prompt, '->', name);
                                return name;
                            } catch (e) {
                                console.warn('Auto TTS generation failed:', e);
                                return null;
                            } finally {
                                // release lock after a short delay to allow callers to reuse
                                try { setTimeout(() => { try { autoTtsLocks.delete(prompt); } catch (e) {} }, AUTO_TTS_DEBOUNCE_MS); } catch (e) {}
                            }
                        })();

                        autoTtsLocks.set(prompt, { promise: p, ts: Date.now() });
                        return p;
                    } catch (e) {
                        console.warn('Auto TTS generation failed (outer):', e);
                        return null;
                    }
                };

                // Track a single active TTS slot by id and mute any other TTS slots.
                // This centralizes vocal logic and reduces races caused by scanning
                // and mutating the shared `slots` array from multiple async flows.
                let activeTtsSlotId = null;

                const setActiveTtsSlot = (slot) => {
                    try {
                        if (!slot || slot.category !== 'tts') return;
                        // record the active TTS slot id (atomic-ish)
                        activeTtsSlotId = slot.id;

                        if (!Array.isArray(slots)) return;
                        for (const s of slots) {
                            if (!s) continue;
                            // keep the active slot unmuted; mute other TTS slots
                            if (s.category === 'tts' && s.id !== activeTtsSlotId && !s.isMuted) {
                                s.isMuted = true;
                                try { if (s.muteButton) { s.muteButton.classList.add('is-muted'); s.muteButton.innerHTML = '🔇'; } } catch (e) {}
                                try { if (s.element) s.element.classList.add('is-muted'); } catch (e) {}
                                // clear lifetime countdown when muted
                                try { if (s.lifetimeTimer) { clearTimeout(s.lifetimeTimer); s.lifetimeTimer = null; } } catch (e) {}
                                try { if (s.lifetimeInterval) { clearInterval(s.lifetimeInterval); s.lifetimeInterval = null; } } catch (e) {}
                                try { if (s.lifetimeText) s.lifetimeText.textContent = '⏸'; } catch (e) {}
                                try { if (s.lifetimeBadge) s.lifetimeBadge.classList.add('paused'); } catch (e) {}
                            }
                        }
                        try { refreshPlayback(); } catch (e) {}
                    } catch (e) {
                        console.warn('setActiveTtsSlot error:', e);
                    }
                };

                // Backwards-compatible alias used throughout the codebase
                const ensureOnlyOneVocalPlays = (slot) => setActiveTtsSlot(slot);
                // Check IndexedDB cache
                const cached = await getCachedTTS(text);
                if (cached) {
                    console.log('✅ Using cached TTS audio from storage for:', text);
                    try {
                        // Restore to memory cache
                        ttsAudioBuffers[text] = {
                            audio: new Float32Array(cached.audio),
                            sampling_rate: cached.sampling_rate
                        };

                        // Build AudioBuffer and register under sampleName
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const audioBuffer = audioContext.createBuffer(
                            1,
                            cached.audio.length,
                            cached.sampling_rate
                        );
                        audioBuffer.getChannelData(0).set(new Float32Array(cached.audio));

                        const wavData = audioBufferToWav(audioBuffer);
                        const base64 = btoa(String.fromCharCode.apply(null, new Uint8Array(wavData)));
                        const dataUrl = `data:audio/wav;base64,${base64}`;

                        const sampleLoader = typeof window.samples === 'function'
                            ? window.samples
                            : (typeof samples === 'function' ? samples : null);

                        if (sampleLoader) {
                            await sampleLoader({ [sampleName]: [dataUrl] });
                            ttsSampleNameByPrompt[text] = sampleName;
                            console.log('Registered cached TTS sample:', sampleName);
                        }
                        return sampleName;
                    } catch (e) {
                        console.warn('Failed to register cached TTS sample, will regenerate:', e);
                        // fall through to regenerate
                    }
                }

                // Generate fresh audio via worker
                try {
                    console.log('🎙️ Generating speech for prompt...');
                    const result = await generateTTSAudio(text);

                    // store in memory and persistent cache
                    ttsAudioBuffers[text] = { audio: result.audio, sampling_rate: result.sampling_rate };
                    await saveTTSToCache(text, result.audio, result.sampling_rate);

                    // Register as a Strudel sample under the deterministic name
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const audioBuffer = audioContext.createBuffer(1, result.audio.length, result.sampling_rate);
                    audioBuffer.getChannelData(0).set(result.audio);

                    const wavData = audioBufferToWav(audioBuffer);
                    const base64 = btoa(String.fromCharCode.apply(null, new Uint8Array(wavData)));
                    const dataUrl = `data:audio/wav;base64,${base64}`;

                    const sampleLoader = typeof window.samples === 'function'
                        ? window.samples
                        : (typeof samples === 'function' ? samples : null);

                    if (sampleLoader) {
                        await sampleLoader({ [sampleName]: [dataUrl] });
                        ttsSampleNameByPrompt[text] = sampleName;
                        console.log('Registered TTS sample via data URL:', sampleName);
                    } else {
                        console.error('Samples loader not available');
                    }

                    return sampleName;
                } catch (e) {
                    console.error('Error generating TTS sample:', e);
                    throw e;
                }
            };

            // Helper function to convert AudioBuffer to WAV format
            const audioBufferToWav = (buffer) => {
                const length = buffer.length * buffer.numberOfChannels * 2;
                const arrayBuffer = new ArrayBuffer(44 + length);
                const view = new DataView(arrayBuffer);
                const channels = [];
                let offset = 0;
                let pos = 0;

                // Write WAV header
                const setUint16 = (data) => {
                    view.setUint16(pos, data, true);
                    pos += 2;
                };
                const setUint32 = (data) => {
                    view.setUint32(pos, data, true);
                    pos += 4;
                };

                // "RIFF" chunk descriptor
                setUint32(0x46464952); // "RIFF"
                setUint32(36 + length); // file length - 8
                setUint32(0x45564157); // "WAVE"

                // "fmt " sub-chunk
                setUint32(0x20746d66); // "fmt "
                setUint32(16); // subchunk1size
                setUint16(1); // audio format (1 = PCM)
                setUint16(buffer.numberOfChannels);
                setUint32(buffer.sampleRate);
                setUint32(buffer.sampleRate * buffer.numberOfChannels * 2); // byte rate
                setUint16(buffer.numberOfChannels * 2); // block align
                setUint16(16); // bits per sample

                // "data" sub-chunk
                setUint32(0x61746164); // "data"
                setUint32(length);

                // Write interleaved audio data
                for (let i = 0; i < buffer.numberOfChannels; i++) {
                    channels.push(buffer.getChannelData(i));
                }

                while (pos < arrayBuffer.byteLength) {
                    for (let i = 0; i < buffer.numberOfChannels; i++) {
                        let sample = channels[i][offset];
                        sample = Math.max(-1, Math.min(1, sample));
                        view.setInt16(pos, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                        pos += 2;
                    }
                    offset++;
                }

                return arrayBuffer;
            };

            // Generate pattern based on prompt using semantic similarity with STRICT category filtering
            const generatePatternFromPrompt = async (prompt, categoryBias = null) => {
                if (!extractor || !patternEmbeddingsCache || !prompt.trim()) {
                    // Fallback: pick random pattern from the STRICT category only
                    const patterns = categoryBias && patternLibrary[categoryBias]
                        ? patternLibrary[categoryBias]
                        : Object.values(patternLibrary).flat();
                    const selected = patterns[Math.floor(Math.random() * patterns.length)];
                    return { code: selected.code, description: selected.desc };
                }

                try {
                        // Normalize prompt text before embedding to match precomputed entries
                        const normalizedPrompt = normalizeText(prompt);
                        // Get embedding for the prompt (only one embedding needed now!)
                        const promptEmbedding = await extractor(normalizedPrompt, { pooling: 'mean', normalize: true });
                    const promptVector = Array.from(promptEmbedding.data);

                    // STRICT filtering: only consider patterns from the slot's category
                    const categoryPatterns = categoryBias
                        ? patternEmbeddingsCache.filter(p => p.category === categoryBias)
                        : patternEmbeddingsCache;

                    // Compute similarities using pre-cached embeddings (only for matching category)
                    const perEntryScores = categoryPatterns.map(pattern => {
                        const similarity = cosineSimilarity(promptVector, pattern.embedding);
                        return { ...pattern, similarity };
                    });

                    // Group by pattern code (aggregate per pattern)
                    const patternMap = new Map();
                    for (const entry of perEntryScores) {
                        const key = entry.code || `${entry.category}:${entry.literal || entry.fullDesc || entry.desc}`;
                        const existing = patternMap.get(key) || { code: entry.code, category: entry.category, literal: entry.literal, entries: [] };
                        existing.entries.push(entry);
                        patternMap.set(key, existing);
                    }

                    // Aggregate scores per pattern (use max similarity and also record best phrase)
                    const aggregated = [];
                    for (const [key, val] of patternMap.entries()) {
                        let best = null;
                        for (const e of val.entries) {
                            if (!best || e.similarity > best.similarity) best = e;
                        }
                        aggregated.push({
                            code: val.code,
                            category: val.category,
                            literal: val.literal,
                            score: best.similarity,
                            bestPhrase: best.desc,
                            entries: val.entries
                        });
                    }

                    // Sort aggregated patterns by score
                    aggregated.sort((a, b) => b.score - a.score);

                    // Use weighted random selection from top pattern matches (add some randomness)
                    const topN = Math.min(5, aggregated.length);
                    const topPatterns = aggregated.slice(0, topN);

                    // Map the UI creativity (0..1) to a temperature value. Lower creativity -> more deterministic.
                    // creativity 0  => temperature ~0.1 (almost deterministic)
                    // creativity 1  => temperature ~1.5 (more exploratory)
                    const temperature = Math.max(0.01, 0.1 + (creativity * 1.4));

                    // If creativity is very low, pick the top match deterministically
                    if (typeof creativity === 'number' && creativity < 0.12) {
                        console.log('Deterministic mode: picking top match');
                        return { code: topPatterns[0].code, description: topPatterns[0].bestPhrase };
                    }

                    // Otherwise use a softmax weighted by similarity and temperature
                    const weights = topPatterns.map(p => Math.exp(p.score / temperature));
                    const totalWeight = weights.reduce((a, b) => a + b, 0);

                    let random = Math.random() * totalWeight;
                    for (let i = 0; i < topPatterns.length; i++) {
                        random -= weights[i];
                        if (random <= 0) {
                            console.log(`Selected ${topPatterns[i].category}: "${topPatterns[i].bestPhrase.substring(0, 40)}..."`);
                            return { code: topPatterns[i].code, description: topPatterns[i].bestPhrase };
                        }
                    }

                    // Fallback to top match
                    console.log(`Selected ${topPatterns[0].category}: "${topPatterns[0].bestPhrase.substring(0, 40)}..."`);
                    return { code: topPatterns[0].code, description: topPatterns[0].bestPhrase };
                } catch (e) {
                    console.error('Error generating pattern:', e);
                    // Fallback to random from the STRICT category
                    const patterns = categoryBias && patternLibrary[categoryBias]
                        ? patternLibrary[categoryBias]
                        : Object.values(patternLibrary).flat();
                    const selected = patterns[Math.floor(Math.random() * patterns.length)];
                    return { code: selected.code, description: selected.desc };
                }
            };

            // Mutate/spice up an existing pattern with richer, multi-step mutations
            const spiceUpPattern = (currentCode, categoryName) => {
                if (!currentCode || !currentCode.trim()) return currentCode;

                const randChoice = (arr) => arr[Math.floor(Math.random() * arr.length)];
                const rand = (min, max) => (Math.random() * (max - min) + min);

                const hasEffect = (code, effectName) => new RegExp(`\\.${effectName}\\(`).test(code);

                // Safely replace a single effect's params (handles nested parens)
                const replaceEffect = (code, effectName, newValue) => {
                    const regex = new RegExp(`\\.${effectName}\\(`);
                    const match = regex.exec(code);
                    if (!match) return code;
                    let start = match.index;
                    let i = start + match[0].length;
                    let depth = 0;
                    for (; i < code.length; i++) {
                        if (code[i] === '(') depth++;
                        else if (code[i] === ')') {
                            if (depth === 0) { i++; break; }
                            depth--;
                        }
                    }
                    return code.substring(0, start) + `.${effectName}(${newValue})` + code.substring(i);
                };

                // Remove first occurrence of an effect
                const removeEffect = (code, effectName) => {
                    const regex = new RegExp(`\\.${effectName}\\(`);
                    const match = regex.exec(code);
                    if (!match) return code;
                    let start = match.index;
                    let i = start + match[0].length;
                    let depth = 0;
                    for (; i < code.length; i++) {
                        if (code[i] === '(') depth++;
                        else if (code[i] === ')') {
                            if (depth === 0) { i++; break; }
                            depth--;
                        }
                    }
                    return code.substring(0, start) + code.substring(i);
                };

                let code = currentCode;

                // A set of focused mutation strategies with category-specific weights
                const mutations = [];

                // Define category preferences (higher weight = more likely)
                const getCategoryWeights = (category) => {
                    const isDrum = ['kick', 'snare', 'hihat', 'perc'].includes(category);
                    const isBass = category === 'bass';
                    const isMelody = category === 'melody';
                    const isChords = category === 'chords';
                    const isTexture = category === 'texture';
                    const isArp = category === 'arp';
                    const isTTS = category === 'tts';

                    return {
                        structural: isDrum ? 3 : isArp ? 2 : 1,        // Drums and arps love rhythm changes
                        addModulation: isTexture ? 2 : 1,               // Textures love modulations
                        modifyModulation: isTexture ? 3 : 1,            // Textures love modulation changes
                        addGranular: isMelody || isArp ? 2 : 0.5,       // Melodies and arps like chopping
                        modifyGranular: isMelody || isArp ? 3 : 0.5,    // Melodies and arps like granular changes
                        addFilter: isBass || isDrum ? 2 : 1,             // Bass and drums love filters
                        modifyFilter: isBass || isDrum ? 3 : 1,         // Bass and drums love filter changes
                        addTemporal: isArp ? 2 : 1,                      // Arps like temporal changes
                        modifyTemporal: isArp ? 3 : 1,                   // Arps like temporal modifications
                        removeEffect: 1,                                 // All categories can benefit from removal
                        swapEffect: isBass || isMelody ? 2 : 1          // Bass and melody benefit from effect swaps
                    };
                };

                const categoryWeights = getCategoryWeights(categoryName);

                // 1) Structural / rhythmic mutations: edit .struct("...") or .n("...") or n("...")
                mutations.push({
                    weight: categoryWeights.structural,
                    func: () => {
                        // mutate .struct("...")
                        const structMatch = code.match(/\\.struct\\(("|')([^"']+)("|')\\)/);
                        if (structMatch) {
                            let struct = structMatch[2];
                            // add or swap an accent or ghost-note and sometimes insert a roll
                            if (Math.random() < 0.5) {
                                // insert a micro-roll or ghost note
                                struct = struct.replace(/~|x/g, (m) => (Math.random() < 0.18 ? `x(3,8)` : m));
                            } else {
                                // flip some ~ to x or vice-versa
                                struct = struct.split(' ').map(tok => {
                                    if (Math.random() < 0.15) return tok === '~' ? 'x' : '~';
                                    if (tok.match(/x\(\d+,\d+\)/) && Math.random() < 0.25) {
                                        const v = [3,4,5,6,8,16][Math.floor(Math.random()*6)];
                                        return 'x(' + v + ')';
                                    }
                                    return tok;
                                }).join(' ');
                            }
                            code = code.replace(structMatch[0], '.struct("' + struct + '")');
                            return true;
                        }

                        // mutate n("...") sequences (notes) by transposing or turning some notes into ranges
                        const nMatch = code.match(/(\b|\.)n\\(("|')([^"']+)("|')\\)/);
                        if (nMatch) {
                            let notes = nMatch[3];
                            // transpose numeric tokens
                            notes = notes.replace(/(-?\d+)/g, (m) => {
                                if (Math.random() < 0.35) return String(parseInt(m) + (Math.random() < 0.5 ? -1 : 1));
                                if (Math.random() < 0.08) {
                                    return '<' + Math.max(0, parseInt(m)-2) + ' ' + (parseInt(m)+2) + '>';
                                }
                                return m;
                            });
                            code = code.replace(nMatch[0], `n("${notes}")`);
                            return true;
                        }

                        return false;
                    }
                });

                // 2) Add small modulations: pan, gain, perlin and small envelopes
                mutations.push({
                    weight: categoryWeights.addModulation,
                    func: () => {
                        const additions = [
                            '.pan(sine.slow(4))',
                            '.pan(perlin.slow(6))',
                            '.gain(' + (rand(0.6, 1)).toFixed(2) + ')',
                            '.gain(perlin.range(0.6,1))',
                            '.lpq(4)', '.clip(2)', '.early("<0 0.02>")'
                        ];
                        const pick = randChoice(additions);
                        if (!hasEffect(code, pick.match(/\.(\w+)\(/)[1])) {
                            code = code + pick;
                            return true;
                        }
                        return false;
                    }
                });

                // 2b) Modify existing modulation effects
                mutations.push({
                    weight: categoryWeights.modifyModulation,
                    func: () => {
                        const modifiableEffects = ['gain', 'pan', 'lpq', 'clip'];
                        const existing = modifiableEffects.filter(e => hasEffect(code, e));
                        if (existing.length > 0) {
                            const effect = randChoice(existing);
                            if (effect === 'gain') {
                                code = replaceEffect(code, 'gain', (rand(0.5, 1.2)).toFixed(2));
                            } else if (effect === 'pan') {
                                code = replaceEffect(code, 'pan', randChoice(['sine.slow(2)', 'sine.slow(8)', 'perlin.slow(4)', 'perlin.slow(12)', '0.3', '-0.3']));
                            } else if (effect === 'lpq') {
                                code = replaceEffect(code, 'lpq', randChoice(['2', '4', '6', '8', '12']));
                            } else if (effect === 'clip') {
                                code = replaceEffect(code, 'clip', randChoice(['0.5', '1', '2', '4']));
                            }
                            return true;
                        }
                        return false;
                    }
                });

                // 3) Granular / chopping changes
                mutations.push({
                    weight: categoryWeights.addGranular,
                    func: () => {
                        const choices = ['.chop(4)', '.chop(8)', '.chop(16)', '.striate(4)', '.striate(8)'];
                        const pick = randChoice(choices);
                        if (!hasEffect(code, pick.match(/\.(\w+)\(/)[1]) || Math.random() < 0.4) {
                            code = code + pick;
                            return true;
                        }
                        return false;
                    }
                });

                // 3b) Modify existing granular effects
                mutations.push({
                    weight: categoryWeights.modifyGranular,
                    func: () => {
                        const granularEffects = ['chop', 'striate'];
                        const existing = granularEffects.filter(e => hasEffect(code, e));
                        if (existing.length > 0) {
                            const effect = randChoice(existing);
                            if (effect === 'chop') {
                                code = replaceEffect(code, 'chop', randChoice(['2', '4', '8', '16', '32']));
                            } else if (effect === 'striate') {
                                code = replaceEffect(code, 'striate', randChoice(['2', '4', '8', '16']));
                            }
                            return true;
                        }
                        return false;
                    }
                });

                // 4) Filter / warmth changes
                mutations.push({
                    weight: categoryWeights.addFilter,
                    func: () => {
                        const choices = ['.hpf(300)', '.hpf(800)', '.lpf(2000)', '.lpf(1200)', '.degradeBy(0.08)', '.distort(0.08)'];
                        code = code + randChoice(choices);
                        return true;
                    }
                });

                // 4b) Modify existing filter effects
                mutations.push({
                    weight: categoryWeights.modifyFilter,
                    func: () => {
                        const filterEffects = ['hpf', 'lpf', 'degradeBy', 'distort'];
                        const existing = filterEffects.filter(e => hasEffect(code, e));
                        if (existing.length > 0) {
                            const effect = randChoice(existing);
                            if (effect === 'hpf') {
                                code = replaceEffect(code, 'hpf', Math.floor(rand(100, 1000)));
                            } else if (effect === 'lpf') {
                                code = replaceEffect(code, 'lpf', Math.floor(rand(800, 4000)));
                            } else if (effect === 'degradeBy') {
                                code = replaceEffect(code, 'degradeBy', (rand(0.05, 0.2)).toFixed(2));
                            } else if (effect === 'distort') {
                                code = replaceEffect(code, 'distort', (rand(0.05, 0.15)).toFixed(2));
                            }
                            return true;
                        }
                        return false;
                    }
                });

                // 5) Temporal shuffles like fast/slow/sometimes/every
                mutations.push({
                    weight: categoryWeights.addTemporal,
                    func: () => {
                        const choices = ['.fast(2)', '.slow(2)', '.sometimes(x=>x.fast(2))', '.every(2,x=>x.fast(1.5))'];
                        code = code + randChoice(choices);
                        return true;
                    }
                });

                // 5b) Modify existing temporal effects
                mutations.push({
                    weight: categoryWeights.modifyTemporal,
                    func: () => {
                        const temporalEffects = ['fast', 'slow'];
                        const existing = temporalEffects.filter(e => hasEffect(code, e));
                        if (existing.length > 0) {
                            const effect = randChoice(existing);
                            if (effect === 'fast') {
                                code = replaceEffect(code, 'fast', (rand(1.5, 4)).toFixed(1));
                            } else if (effect === 'slow') {
                                code = replaceEffect(code, 'slow', (rand(1.5, 4)).toFixed(1));
                            }
                            return true;
                        }
                        return false;
                    }
                });

                // 6) Remove a random effect (for variety and mutation)
                mutations.push({
                    weight: categoryWeights.removeEffect,
                    func: () => {
                        // Find all effects in the code
                        const effectMatches = code.match(/\.(\w+)\(/g);
                        if (effectMatches && effectMatches.length > 1) { // Keep at least one effect
                            const effects = effectMatches.map(m => m.slice(1, -1)); // Remove . and (
                            const effectToRemove = randChoice(effects);
                            code = removeEffect(code, effectToRemove);
                            return true;
                        }
                        return false;
                    }
                });

                // 7) Swap effects (replace one effect with another similar one)
                mutations.push({
                    weight: categoryWeights.swapEffect,
                    func: () => {
                        const swaps = [
                            ['gain', 'gain', (rand(0.7, 1.1)).toFixed(2)], // gain to different gain
                            ['lpf', 'hpf', Math.floor(rand(200, 800))], // lpf to hpf
                            ['hpf', 'lpf', Math.floor(rand(1000, 3000))], // hpf to lpf
                            ['chop', 'striate', randChoice(['2', '4', '8'])], // chop to striate
                            ['striate', 'chop', randChoice(['4', '8', '16'])], // striate to chop
                            ['fast', 'slow', (rand(1.5, 3)).toFixed(1)], // fast to slow
                            ['slow', 'fast', (rand(1.5, 3)).toFixed(1)], // slow to fast
                        ];
                        const existingEffects = code.match(/\.(\w+)\(/g)?.map(m => m.slice(1, -1)) || [];
                        const possibleSwaps = swaps.filter(([from]) => existingEffects.includes(from));
                        if (possibleSwaps.length > 0) {
                            const [from, to, newValue] = randChoice(possibleSwaps);
                            code = replaceEffect(code, from, newValue);
                            // Now replace the effect name
                            code = code.replace(new RegExp(`\\.${from}\\(`), `.${to}(`);
                            return true;
                        }
                        return false;
                    }
                });

                // 6) TTS-specific tasteful tweaks
                if (categoryName === 'tts') {
                    // Prefer small, speech-focused variations
                    const ttsChoices = [
                        x => replaceEffect(x, 'speed', String((rand(0.85, 1.15)).toFixed(2))),
                        x => x + '.chop(4)',
                        x => x + '.chop(8)',
                        x => x + '.striate(4)',
                        x => x + '.room(0.4)',
                        x => x + '.hpf(' + Math.floor(rand(100,400)) + ')',
                        x => x + '.lpf(' + Math.floor(rand(2500,6000)) + ')',
                        x => x + '.delay(0.25)'
                    ];
                    // apply 1-2 tts-specific mutations
                    const count = 1 + Math.floor(Math.random() * 2);
                    for (let i = 0; i < count; i++) {
                        code = randChoice(ttsChoices)(code);
                    }
                    return code;
                }

                // Decide how many focused mutations to attempt (2..4)
                const attempts = 2 + Math.floor(Math.random() * 3);
                const picked = [];
                for (let i = 0; i < attempts; i++) {
                    // pick a mutation using weighted random selection
                    const available = mutations.filter((m, idx) => !picked.includes(idx));
                    if (available.length === 0) break;

                    const totalWeight = available.reduce((sum, m) => sum + m.weight, 0);
                    let random = Math.random() * totalWeight;
                    let selectedIdx = 0;
                    for (let j = 0; j < available.length; j++) {
                        random -= available[j].weight;
                        if (random <= 0) {
                            selectedIdx = j;
                            break;
                        }
                    }
                    const idxGlobal = mutations.indexOf(available[selectedIdx]);
                    picked.push(idxGlobal);
                    try {
                        const applied = available[selectedIdx].func();
                        // if mutation didn't apply, try another in the same pass
                        if (!applied && Math.random() < 0.4) {
                            // sometimes remove an effect, sometimes add a small random addition
                            if (Math.random() < 0.3) {
                                // Try to remove a random effect
                                const effectMatches = code.match(/\.(\w+)\(/g);
                                if (effectMatches && effectMatches.length > 1) {
                                    const effects = effectMatches.map(m => m.slice(1, -1));
                                    const effectToRemove = randChoice(effects);
                                    code = removeEffect(code, effectToRemove);
                                } else {
                                    // fallback to addition
                                    code = code + randChoice(['.gain(0.9)', '.room(0.25)', '.delay(0.125)']);
                                }
                            } else {
                                // append a small random addition
                                code = code + randChoice(['.gain(0.9)', '.room(0.25)', '.delay(0.125)']);
                            }
                        }
                    } catch (e) {
                        console.warn('Spice mutation failed:', e);
                    }
                }

                // small chance to perform a dramatic morph: swap in a short pattern from the library
                if (Math.random() < 0.06) {
                    const samplePatterns = Object.values(patternLibrary).flat();
                    const sample = randChoice(samplePatterns);
                    if (sample && sample.code) code = sample.code + '.gain(0.95)';
                }

                // Trim redundant whitespace and return
                return code.replace(/\s+/g, ' ').trim();
            };

            const waitForScheduler = async (timeoutMs = 5000) => {
                const start = getNow();
                let api = getSchedulerApi();
                let attempts = 0;

                while (getNow() - start < timeoutMs) {
                    if (api && typeof api.setPattern === 'function' && typeof api.setCps === 'function') {
                        return api;
                    }

                    await sleep(50);
                    api = getSchedulerApi();
                    attempts++;

                    // Update progress every few attempts to show activity
                    if (attempts % 5 === 0) {
                        updateLoadingProgress(`Waiting for audio engine...`);
                    }
                }

                return api;
            };

            updateLoadingProgress('Loading Strudel and samples...');
            statusEl.textContent = 'Loading Strudel and samples…';

            await initStrudel({
                // Load the classic Dirt sample pack so bd/sn/hh/etc. are available.
                prebake: async () => {
                    updateLoadingProgress('Loading sample library...');
                    const sampleLoader = typeof window.samples === 'function'
                        ? window.samples
                        : (typeof samples === 'function' ? samples : null);
                    if (!sampleLoader) {
                        console.warn('Strudel samples loader unavailable. Using synth fallback for drums and percussion.');
                        updateLoadingProgress('Using synth fallback...', false);
                        return;
                    }

                    // Load ALL the sample packs - comprehensive loading
                    const allSamplePacks = [
                        { url: 'github:tidalcycles/Dirt-Samples', name: 'Dirt-Samples (main)' },
                        { url: 'github:yaxu/clean-breaks', name: 'breaks' },
                    ];

                    let loadedCount = 0;
                    for (let i = 0; i < allSamplePacks.length; i++) {
                        const pack = allSamplePacks[i];
                        try {
                            updateLoadingProgress(`Loading ${pack.name}... (${i + 1}/${allSamplePacks.length})`);
                            await sampleLoader(pack.url);
                            console.log(`✓ Loaded: ${pack.url}`);
                            loadedCount++;
                            if (i === 0) hasDirtSamples = true; // First pack is main Dirt samples
                        } catch (e) {
                            console.warn(`✗ Failed to load ${pack.url}:`, e.message || e);
                            // Continue trying other packs even if one fails
                        }
                    }

                    console.log(`Successfully loaded ${loadedCount}/${allSamplePacks.length} sample packs`);
                    updateLoadingProgress(`Loaded ${loadedCount} sample packs ✓`);

                    updateLoadingProgress('Sample libraries loaded ✓');
                }
            });

            // initStrudel has completed, now start the audio engine
            updateLoadingProgress('Starting audio system...');

            schedulerApi = await waitForScheduler();

            if (!schedulerApi) {
                console.warn('Strudel scheduler did not become ready in time.');
            }

            updateLoadingProgress('Configuring audio settings...');

            if (!hasDirtSamples) {
                sampleStatusSuffix = ' (samples not loaded)';
            }

            updateLoadingProgress('Audio engine ready ✓');

            // Pre-compute pattern embeddings if AI model is available
            if (extractor) {
                patternEmbeddingsCache = await precomputePatternEmbeddings();
                updateLoadingProgress('Pattern library ready ✓');
            }

            // Initialize TTS worker during the loading screen so the model download
            // happens up-front instead of on the first generation call.
            try {
                updateLoadingProgress('Loading TTS model...');
                // Ensure the worker is created and the model is loaded
                await initTTSWorker();
                updateLoadingProgress('TTS model ready ✓');

                // Pre-warm a couple of common phrases so the first playback feels snappy.
                // This is awaited so the loading screen only hides after pre-warm completes
                // (with a timeout to avoid blocking indefinitely on flaky networks).
                if (typeof preWarmTTS === 'function') {
                    const PREWARM_TIMEOUT_MS = 15000; // 15s timeout for pre-warm
                    updateLoadingProgress('Warming TTS samples...');
                    try {
                        await Promise.race([
                            preWarmTTS(),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('TTS pre-warm timeout')), PREWARM_TIMEOUT_MS))
                        ]);
                        updateLoadingProgress('TTS samples ready ✓');
                    } catch (e) {
                        console.warn('TTS pre-warm failed or timed out:', e);
                        updateLoadingProgress('TTS pre-warm skipped');
                    }
                }
            } catch (e) {
                console.warn('TTS model failed to load during startup:', e);
                updateLoadingProgress('TTS model failed (TTS disabled)');
            }

            updateLoadingProgress('Setting up interface...');

            // small helper: convert hex color (#rrggbb or #rgb) to "r,g,b" string
            const hexToRgbString = (hex) => {
                if (!hex) return '0,0,0';
                // remove # if present
                let h = hex.replace('#', '');
                if (h.length === 3) {
                    h = h.split('').map(c => c + c).join('');
                }
                const intVal = parseInt(h, 16);
                const r = (intVal >> 16) & 255;
                const g = (intVal >> 8) & 255;
                const b = intVal & 255;
                return `${r}, ${g}, ${b}`;
            };

            // -------- Lifetime helpers (deterministic 8-bar default, clickable +1) --------
            const getBarMs = () => {
                // Try to read BPM from scheduler if available, otherwise default to 120
                let bpm = 120;
                try {
                    if (schedulerApi && typeof schedulerApi.getBpm === 'function') {
                        bpm = schedulerApi.getBpm();
                    } else if (schedulerApi && typeof schedulerApi.bpm === 'number') {
                        bpm = schedulerApi.bpm;
                    } else if (typeof window.bpm === 'number') {
                        bpm = window.bpm;
                    }
                } catch (e) {
                    // fallback to default
                }
                // assuming 4/4 bars
                return (60 / Math.max(1, bpm)) * 1000 * 4;
            };

            // Try to read transport time (in seconds) from the Strudel scheduler if available.
            // We attempt several common API names; fall back to wall-clock seconds.
            const getTransportSeconds = () => {
                try {
                    if (schedulerApi) {
                        // common patterns
                        if (typeof schedulerApi.getPosition === 'function') {
                            // assume seconds
                            return schedulerApi.getPosition();
                        }
                        if (typeof schedulerApi.getNow === 'function') {
                            const v = schedulerApi.getNow();
                            // if large, assume milliseconds
                            if (v > 1e6) return v / 1000;
                            return v;
                        }
                        if (schedulerApi.transport && typeof schedulerApi.transport.position === 'number') {
                            return schedulerApi.transport.position;
                        }
                        if (typeof schedulerApi.position === 'number') {
                            return schedulerApi.position;
                        }
                        if (typeof schedulerApi.getBeat === 'function') {
                            // convert beats to seconds when BPM known
                            const beats = schedulerApi.getBeat();
                            const bpm = (typeof schedulerApi.getBpm === 'function') ? schedulerApi.getBpm() : (schedulerApi.bpm || 120);
                            return (beats * 60) / bpm;
                        }
                    }
                } catch (e) {
                    console.warn('Transport time read failed:', e);
                }
                return Date.now() / 1000;
            };

            // Detect whether the scheduler/transport is currently playing.
            // We try a few common property/method names and fall back to checking
            // whether any slot has code and is unmuted (best-effort).
            const isTransportPlaying = () => {
                try {
                    if (schedulerApi) {
                        if (typeof schedulerApi.isPlaying === 'boolean') return schedulerApi.isPlaying;
                        if (typeof schedulerApi.isPlaying === 'function') return !!schedulerApi.isPlaying();
                        if (schedulerApi.transport) {
                            if (typeof schedulerApi.transport.isPlaying === 'boolean') return schedulerApi.transport.isPlaying;
                            if (typeof schedulerApi.transport.playing === 'boolean') return schedulerApi.transport.playing;
                        }
                        if (typeof schedulerApi.playing === 'boolean') return schedulerApi.playing;
                    }
                } catch (e) {
                    // ignore and fall through to fallback
                }
                try {
                    // fallback: if any slot has code and isn't muted, assume playback is active
                    return slots && Array.isArray(slots) && slots.some(s => s.code && !s.isMuted);
                } catch (e) {
                    return false;
                }
            };

            const destroySlot = (slotObj, reason) => {
                if (!slotObj || !slotObj.element) return;
                // clear any timers
                if (slotObj.lifetimeTimer) { clearTimeout(slotObj.lifetimeTimer); slotObj.lifetimeTimer = null; }
                if (slotObj.lifetimeInterval) { clearInterval(slotObj.lifetimeInterval); slotObj.lifetimeInterval = null; }

                // If already removed from DOM, do nothing
                if (!slotObj.element.parentNode) return;

                slotObj.element.classList.add('removing');
                setTimeout(() => {
                    const index = slots.findIndex(s => s.id === slotObj.id);
                    // If the removed slot was the active TTS slot, clear the active id
                    try { if (typeof activeTtsSlotId !== 'undefined' && slotObj && slotObj.id === activeTtsSlotId) activeTtsSlotId = null; } catch (e) {}
                    if (index !== -1) slots.splice(index, 1);
                    try { slotObj.element.remove(); } catch(e) {}
                    refreshPlayback();
                    updateStatus();
                    console.log(`Slot ${slotObj.id} removed (${reason || 'expired/deleted'})`);
                }, 300);
            };

            const scheduleSlotLifetime = (slotObj, barsParam) => {
                if (!slotObj) return;

                // If pinned, do not schedule lifetime — show infinity and locked icon
                if (slotObj.pinned) {
                    if (slotObj.lifetimeBadge) slotObj.lifetimeBadge.classList.add('pinned');
                    if (slotObj.lifetimeText) slotObj.lifetimeText.textContent = '∞';
                    if (slotObj.lifetimePinBtn) slotObj.lifetimePinBtn.innerHTML = '🔒';
                    // when pinned, show full progress bar so it's visually persistent
                    if (slotObj.lifetimeProgressBar) slotObj.lifetimeProgressBar.style.width = '100%';
                    if (slotObj.lifetimeTimer) { clearTimeout(slotObj.lifetimeTimer); slotObj.lifetimeTimer = null; }
                    if (slotObj.lifetimeInterval) { clearInterval(slotObj.lifetimeInterval); slotObj.lifetimeInterval = null; }
                    return;
                }

                // Clear existing lifetime timers
                if (slotObj.lifetimeTimer) { clearTimeout(slotObj.lifetimeTimer); slotObj.lifetimeTimer = null; }
                if (slotObj.lifetimeInterval) { clearInterval(slotObj.lifetimeInterval); slotObj.lifetimeInterval = null; }

                const barMs = getBarMs();

                // Decide bars to schedule:
                // - If barsParam provided, use it
                // - Else if a lifetimeBars value exists (pending or set), use that
                // - Else if an expiry is already set in the future, use remaining bars
                // - Otherwise default to 8 bars
                let bars;
                if (typeof barsParam === 'number' && barsParam > 0) {
                    bars = Math.max(1, Math.floor(barsParam));
                } else if (typeof slotObj.lifetimeBars === 'number' && slotObj.lifetimeBars > 0) {
                    // honor an existing stored bars count (created while idle)
                    bars = Math.max(1, Math.floor(slotObj.lifetimeBars));
                } else if (slotObj.lifetimeExpiresAt && slotObj.lifetimeExpiresAt > Date.now()) {
                    bars = Math.max(1, Math.ceil((slotObj.lifetimeExpiresAt - Date.now()) / barMs));
                } else {
                    bars = 8; // default deterministic lifetime
                }

                // Store the bars count (used for display while idle and when playback begins)
                slotObj.lifetimeBars = bars;

                // If transport/audio is not currently playing, do not start timers.
                // Instead, show the bars count and reset progress to 0 — the actual
                // countdown will start when `refreshPlayback` detects playback and
                // calls `scheduleSlotLifetime` again (which will create timers).
                if (!isTransportPlaying()) {
                    if (slotObj.lifetimeBadge) {
                        slotObj.lifetimeBadge.classList.remove('pinned');
                        slotObj.lifetimeBadge.classList.add('paused');
                    }
                    // show the bars count but replace it with a pause symbol to indicate paused state
                    if (slotObj.lifetimeText) slotObj.lifetimeText.textContent = `⏸`;
                    if (slotObj.lifetimeProgressBar) slotObj.lifetimeProgressBar.style.width = '0%';
                    // clear any timers just in case
                    if (slotObj.lifetimeTimer) { clearTimeout(slotObj.lifetimeTimer); slotObj.lifetimeTimer = null; }
                    if (slotObj.lifetimeInterval) { clearInterval(slotObj.lifetimeInterval); slotObj.lifetimeInterval = null; }
                    console.log(`Deferred scheduling slot ${slotObj.id} (${bars} bar(s)) until playback starts`);
                    return;
                }

                // Transport is playing — compute an expiry aligned to the transport's bar boundary
                try {
                    const bpm = 240000 / barMs; // derive bpm from barMs
                    const transportSec = getTransportSeconds();
                    const beatsElapsed = transportSec * (bpm / 60);
                    const barsElapsed = beatsElapsed / 4;
                    const nextBar = Math.ceil(barsElapsed); // next whole bar index
                    const nextBarBeat = nextBar * 4; // beat number at next bar
                    const beatsUntilNextBar = nextBarBeat - beatsElapsed;
                    const secsUntilNextBar = beatsUntilNextBar * (60 / bpm);

                    const totalMs = Math.round(secsUntilNextBar * 1000) + ((bars - 1) * barMs);
                    slotObj.lifetimeExpiresAt = Date.now() + totalMs;
                } catch (e) {
                    // fallback: simple wall-clock scheduling
                    slotObj.lifetimeExpiresAt = Date.now() + bars * barMs;
                }

                // Ensure the badge element exists and has text/progress elements
                    if (slotObj.lifetimeBadge) {
                        slotObj.lifetimeBadge.classList.remove('pinned');
                        slotObj.lifetimeBadge.classList.remove('paused');
                        if (slotObj.lifetimePinBtn && !slotObj.pinned) slotObj.lifetimePinBtn.innerHTML = '🔓';
                    const updateBadge = () => {
                        const msLeft = Math.max(0, slotObj.lifetimeExpiresAt - Date.now());
                        const barsLeft = Math.max(0, Math.ceil(msLeft / barMs));
                        if (slotObj.lifetimeText) slotObj.lifetimeText.textContent = `${barsLeft}`;
                        // progress within current bar
                        const withinBar = msLeft % barMs;
                        const pct = Math.max(0, Math.min(1, withinBar / barMs));
                        if (slotObj.lifetimeProgressBar) slotObj.lifetimeProgressBar.style.width = `${pct * 100}%`;
                    };
                    updateBadge();
                    slotObj.lifetimeInterval = setInterval(updateBadge, 200);
                }

                const totalMs = Math.max(0, slotObj.lifetimeExpiresAt - Date.now());

                slotObj.lifetimeTimer = setTimeout(() => {
                    if (slotObj.pinned) return;
                    destroySlot(slotObj, 'lifetime expired');
                }, totalMs);

                console.log(`Scheduled slot ${slotObj.id} to expire in ${bars} bar(s)`);
            };
            // ---------------------------------------------------------------

            // Function to create a new slot
            const createSlot = (categoryName) => {
                const slotId = slotIdCounter++;
                const category = slotCategories.find(c => c.name === categoryName) || slotCategories[0];

                const slotDiv = document.createElement('div');
                slotDiv.className = 'slot';
                slotDiv.style.setProperty('--slot-color', category.color);
                // also expose an rgb triplet for CSS use (e.g. overlay tint)
                slotDiv.style.setProperty('--slot-color-rgb', hexToRgbString(category.color));
                slotDiv.dataset.slotId = slotId;

                const header = document.createElement('div');
                header.className = 'slot-header';

                const leftGroup = document.createElement('div');
                leftGroup.style.display = 'flex';
                leftGroup.style.alignItems = 'center';
                leftGroup.style.gap = '0.5rem';

                // Drag handle
                const dragHandle = document.createElement('div');
                dragHandle.className = 'slot-drag-handle';
                dragHandle.innerHTML = '⋮⋮';
                dragHandle.title = 'Drag to reorder';
                dragHandle.draggable = true;

                const muteBtn = document.createElement('button');
                muteBtn.className = 'slot-mute-btn';
                muteBtn.innerHTML = '🔊';
                muteBtn.setAttribute('aria-label', 'Mute/unmute layer');
                muteBtn.title = 'Mute/unmute';

                // place mute button on the left, then drag handle, then expanding lifecycle badge
                leftGroup.appendChild(muteBtn);
                leftGroup.appendChild(dragHandle);

                // Lifetime badge (will show remaining bars once scheduled)
                const lifetimeBadge = document.createElement('div');
                lifetimeBadge.className = 'slot-lifetime-badge';

                const lifetimeText = document.createElement('span');
                lifetimeText.className = 'slot-lifetime-text';
                // show default 8 bars on creation (do not start countdown until playback)
                lifetimeText.textContent = '8';

                // Decrement button (-) to the left of the number
                const decBtn = document.createElement('button');
                decBtn.className = 'slot-lifetime-decrement';
                decBtn.title = 'Decrease lifetime by 1 bar';
                // use a minus sign (unicode) which looks nicer than a hyphen
                decBtn.innerHTML = '−';

                // Increment button (+) to the right of the number
                const incBtn = document.createElement('button');
                incBtn.className = 'slot-lifetime-increment';
                incBtn.title = 'Increase lifetime by 1 bar';
                incBtn.innerHTML = '+';

                const lifetimeProgress = document.createElement('div');
                lifetimeProgress.className = 'slot-lifetime-progress';
                const lifetimeProgressBar = document.createElement('div');
                lifetimeProgressBar.className = 'slot-lifetime-progress-bar';
                // default to empty progress until playback begins
                lifetimeProgressBar.style.width = '0%';
                lifetimeProgress.appendChild(lifetimeProgressBar);

                const pinBtn = document.createElement('button');
                pinBtn.className = 'slot-lifetime-pin';
                pinBtn.title = 'Pin/Unpin from auto-delete';
                // show unlocked icon by default (unpin = unlocked)
                pinBtn.innerHTML = '🔓';

                // Arrange: [ - ] [ number ] [ + ] [ progress ] [ pin ]
                lifetimeBadge.appendChild(decBtn);
                lifetimeBadge.appendChild(lifetimeText);
                lifetimeBadge.appendChild(incBtn);
                lifetimeBadge.appendChild(lifetimeProgress);
                lifetimeBadge.appendChild(pinBtn);

                leftGroup.appendChild(lifetimeBadge);

                // If transport is not playing at creation time, show paused UI
                try {
                    if (!isTransportPlaying()) {
                        lifetimeBadge.classList.add('paused');
                        // show pause in the lifetime text rather than replacing the pin
                        if (lifetimeText) lifetimeText.textContent = '⏸';
                        // keep pin button showing unlocked by default
                        if (pinBtn) pinBtn.innerHTML = '🔓';
                    }
                } catch (e) {
                    // ignore
                }

                const controlsGroup = document.createElement('div');
                controlsGroup.className = 'slot-controls';

                const slotPromptInput = document.createElement('input');
                slotPromptInput.type = 'text';
                slotPromptInput.className = 'slot-prompt';
                const slotPlaceholders = {
                    kick: 'Describe the kick (four-on-floor, 808, syncopated...)',
                    snare: 'Describe the snare/clap (backbeat, half-time, ghost notes...)',
                    hihat: 'Describe hi-hat pattern (steady 16ths, trap rolls, shuffle...)',
                    perc: 'Describe percussion (shaker, conga, rim, toms...)',
                    bass: 'Describe the bass (sub, wobble, pluck...)',
                    melody: 'Describe the melody (lead, arps, or motifs...)',
                    chords: 'Describe chord style (pad, stabs, piano...)',
                    texture: 'Describe texture/FX (sweeps, washes, grain...)',
                    arp: 'Describe arpeggios (fast, slow, rhythmic, dreamy...)',
                    tts: 'What would you like to say...'
                };
                slotPromptInput.placeholder = slotPlaceholders[category.name] || 'Describe the vibe...';
                slotPromptInput.disabled = !extractor;

                const dice = document.createElement('button');
                dice.className = 'slot-dice';
                dice.innerHTML = '⚅';
                dice.setAttribute('aria-label', `Generate ${category.desc} pattern`);
                dice.title = `Roll for ${category.desc}`;
                dice.disabled = !extractor;

                const spice = document.createElement('button');
                spice.className = 'slot-spice';
                spice.innerHTML = '✦';
                spice.setAttribute('aria-label', `Add spice to ${category.desc} pattern`);
                spice.title = `Add spice - mutate current pattern`;
                spice.disabled = !extractor;

                // Rewind button: step back to previous pattern after a roll or mutation
                const rewindBtn = document.createElement('button');
                rewindBtn.className = 'slot-rewind';
                // Use a plain Unicode rewind symbol (non-emoji)
                rewindBtn.innerHTML = '↺';
                rewindBtn.title = 'Rewind to previous pattern';
                rewindBtn.setAttribute('aria-label', `Rewind ${category.desc} to previous pattern`);
                rewindBtn.disabled = true;

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'slot-delete-btn';
                deleteBtn.innerHTML = '×';
                deleteBtn.setAttribute('aria-label', 'Delete layer');
                deleteBtn.title = 'Delete layer';

                const textarea = document.createElement('textarea');
                textarea.className = 'slot-code';
                textarea.placeholder = category.name === 'tts'
                    ? 'Roll the dice to generate speech, then edit and press Enter to apply...'
                    : 'Roll the dice to generate, or enter Strudel code and press Enter...';

                const codeWrapper = document.createElement('div');
                codeWrapper.className = 'slot-code-wrapper';

                const emojiBackground = document.createElement('div');
                emojiBackground.className = 'slot-code-emoji';
                emojiBackground.textContent = category.icon;

                codeWrapper.appendChild(emojiBackground);
                codeWrapper.appendChild(textarea);

                controlsGroup.appendChild(slotPromptInput);
                controlsGroup.appendChild(dice);
                controlsGroup.appendChild(spice);
                controlsGroup.appendChild(rewindBtn);
                controlsGroup.appendChild(deleteBtn);

                header.appendChild(leftGroup);
                header.appendChild(controlsGroup);
                slotDiv.appendChild(header);
                slotDiv.appendChild(codeWrapper);

                // Create slot object
                const slotObj = {
                    id: slotId,
                    code: '',
                    element: slotDiv,
                    diceButton: dice,
                    spiceButton: spice,
                    textarea: textarea,
                    promptInput: slotPromptInput,
                    muteButton: muteBtn,
                    deleteButton: deleteBtn,
                    isMuted: false,
                    category: category.name,
                    dragHandle: dragHandle
                    , lifetimeBadge: lifetimeBadge,
                    lifetimeText: lifetimeText,
                    lifetimeProgressBar: lifetimeProgressBar,
                    lifetimePinBtn: pinBtn,
                    lifetimeTimer: null,
                    lifetimeInterval: null,
                    lifetimeBars: 8, // default visible lifetime (but not ticking until playback)
                    lifetimeExpiresAt: null,
                    pinned: false
                    ,
                    // history / rewind support
                    history: [],
                    rewindButton: rewindBtn,
                    _lastCommittedCode: ''
                };

                // History helper: push the previous code state so rewind can restore it.
                const pushToHistory = (prevCode) => {
                    try {
                        // normalize prevCode to string
                        const codeStr = (typeof prevCode === 'string') ? prevCode : '';
                        // capture the current prompt text so we can restore it on rewind
                        // prefer the visible prompt input, but fall back to any dataset-stored tts text
                        let promptStr = '';
                        try {
                            if (slotPromptInput && typeof slotPromptInput.value === 'string' && slotPromptInput.value.trim()) {
                                promptStr = slotPromptInput.value.trim();
                            } else if (textarea && textarea.dataset && typeof textarea.dataset.ttsText === 'string' && textarea.dataset.ttsText.trim()) {
                                promptStr = textarea.dataset.ttsText.trim();
                            }
                        } catch (e) { promptStr = ''; }
                        // If we couldn't capture a prompt text but the code references a concrete
                        // TTS sample (e.g. s("tts_xxx:0")), attempt a reverse lookup into
                        // ttsSampleNameByPrompt so we can restore a visible prompt when rewinding.
                        if (!promptStr && codeStr) {
                            try {
                                const m = codeStr.match(/s\((['\"])([^'\"]+):\d+\1\)/);
                                if (m && m[2]) {
                                    const sampleName = m[2];
                                    for (const [p, n] of Object.entries(ttsSampleNameByPrompt)) {
                                        if (n === sampleName) { promptStr = p; break; }
                                    }
                                }
                            } catch (e) { /* ignore reverse lookup errors */ }
                        }
                        // detect if the code references a concrete registered sample name
                        let sampleNameStr = '';
                        try {
                            const sm = codeStr.match(/s\((['"])([^'\"]+):\d+\1\)/);
                            if (sm && sm[2]) sampleNameStr = sm[2];
                        } catch (e) { sampleNameStr = ''; }
                        // prefer any explicit current sampleName stored on the slot
                        try {
                            if (!sampleNameStr && slotObj && slotObj.currentTtsSampleName) sampleNameStr = slotObj.currentTtsSampleName;
                        } catch (e) {}

                        const entry = { code: codeStr, prompt: promptStr, sampleName: sampleNameStr };
                        // Avoid pushing duplicates in a row (compare by code)
                        const last = slotObj.history.length > 0 ? slotObj.history[slotObj.history.length - 1] : null;
                        if (!last || last.code !== entry.code) {
                            slotObj.history.push(entry);
                            try { console.log('[history] push:', { slotId: slotObj.id, entry }); } catch (e) {}
                        }
                        // enable rewind UI
                        if (slotObj.rewindButton) slotObj.rewindButton.disabled = slotObj.history.length === 0;
                    } catch (e) {
                        console.warn('Could not push to history:', e);
                    }
                };

                const updateRewindButton = () => {
                    if (slotObj.rewindButton) slotObj.rewindButton.disabled = slotObj.history.length === 0;
                };

                // Mute button handler
                muteBtn.addEventListener('click', () => {
                    slotObj.isMuted = !slotObj.isMuted;
                    muteBtn.classList.toggle('is-muted', slotObj.isMuted);
                    muteBtn.innerHTML = slotObj.isMuted ? '🔇' : '🔊';
                    slotDiv.classList.toggle('is-muted', slotObj.isMuted);

                    if (slotObj.isMuted) {
                        // stop any lifetime countdown when muted
                        if (slotObj.lifetimeTimer) { clearTimeout(slotObj.lifetimeTimer); slotObj.lifetimeTimer = null; }
                        if (slotObj.lifetimeInterval) { clearInterval(slotObj.lifetimeInterval); slotObj.lifetimeInterval = null; }
                        // show the stored bars (or default 8) and reset visual progress
                        if (slotObj.lifetimeText) slotObj.lifetimeText.textContent = '⏸';
                        if (slotObj.lifetimeProgressBar) slotObj.lifetimeProgressBar.style.width = '0%';
                        if (slotObj.lifetimeBadge) slotObj.lifetimeBadge.classList.add('paused');
                        // keep pin icon as unlocked unless pinned
                        if (slotObj.lifetimePinBtn && !slotObj.pinned) slotObj.lifetimePinBtn.innerHTML = '🔓';
                    } else {
                        // when unmuted, reset lifetime to 8 bars (unless pinned)
                        if (!slotObj.pinned) {
                            slotObj.lifetimeBadge && slotObj.lifetimeBadge.classList.remove('paused');
                            slotObj.lifetimeBars = 8;
                            try { scheduleSlotLifetime(slotObj, 8); } catch (err) { console.warn('Could not schedule after unmute:', err); }
                            // If this is a TTS slot, ensure other vocals are muted so only this one plays
                            try { if (slotObj.category === 'tts') ensureOnlyOneVocalPlays(slotObj); } catch (e) {}
                        } else {
                            // if pinned, ensure infinity UI
                            if (slotObj.lifetimeText) slotObj.lifetimeText.textContent = '∞';
                            if (slotObj.lifetimePinBtn) slotObj.lifetimePinBtn.innerHTML = '🔒';
                        }
                    }

                    refreshPlayback();
                });

                // Pin button handler (toggle auto-delete)
                pinBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    slotObj.pinned = !slotObj.pinned;
                    if (slotObj.pinned) {
                        // clear any timers and mark as pinned
                        if (slotObj.lifetimeTimer) { clearTimeout(slotObj.lifetimeTimer); slotObj.lifetimeTimer = null; }
                        if (slotObj.lifetimeInterval) { clearInterval(slotObj.lifetimeInterval); slotObj.lifetimeInterval = null; }
                        slotObj.lifetimeBadge.classList.remove('paused');
                        slotObj.lifetimeBadge.classList.add('pinned');
                        // show infinity sign when pinned
                        if (slotObj.lifetimeText) slotObj.lifetimeText.textContent = '∞';
                        if (slotObj.lifetimePinBtn) slotObj.lifetimePinBtn.innerHTML = '🔒';
                        if (slotObj.lifetimeProgressBar) slotObj.lifetimeProgressBar.style.width = '100%';
                    } else {
                        // unpinned: remove pinned UI, show unlocked icon and reset lifetime to exactly 8 bars
                        slotObj.lifetimeBadge.classList.remove('pinned');
                        slotObj.lifetimeBadge.classList.remove('paused');
                        if (slotObj.lifetimePinBtn) slotObj.lifetimePinBtn.innerHTML = '🔓';
                        try { scheduleSlotLifetime(slotObj, 8); } catch (err) { console.warn('Could not schedule after unpin:', err); }
                    }
                });

                    // Clicking the + / - buttons adjusts bars (left = -, right = +)
                    incBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        try {
                            const barMs = getBarMs();
                            const add = 1;
                            // If pinned, keep pinned but still extend an internal expiry value
                            if (!slotObj.lifetimeExpiresAt || slotObj.lifetimeExpiresAt < Date.now()) {
                                // If there's no expiry, create one equal to now + add
                                slotObj.lifetimeExpiresAt = Date.now() + add * barMs;
                            } else {
                                slotObj.lifetimeExpiresAt = slotObj.lifetimeExpiresAt + add * barMs;
                            }

                            // Update lifetimeBars approx
                            slotObj.lifetimeBars = Math.max(1, Math.ceil((slotObj.lifetimeExpiresAt - Date.now()) / barMs));

                            // If not pinned, (re)schedule timers to reflect increased lifetime
                            if (!slotObj.pinned) {
                                try { scheduleSlotLifetime(slotObj); } catch (err) { console.warn('Could not reschedule after add:', err); }
                            } else {
                                // keep showing infinity when pinned
                                if (slotObj.lifetimeText) slotObj.lifetimeText.textContent = '∞';
                            }

                            // tiny visual feedback
                            lifetimeText.style.transform = 'scale(1.15)';
                            setTimeout(() => lifetimeText.style.transform = '', 140);
                        } catch (e) {
                            console.warn('Could not add bars:', e);
                        }
                    });

                    decBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        try {
                            const barMs = getBarMs();

                            // If pinned, ignore decrement (showing infinity)
                            if (slotObj.pinned) {
                                // brief visual cue to show it's pinned
                                lifetimeText.style.transform = 'scale(0.95)';
                                setTimeout(() => lifetimeText.style.transform = '', 140);
                                return;
                            }

                            const sub = 1;
                            const now = Date.now();

                            // Determine current ms left; fall back to lifetimeBars if no expiry
                            let msLeft = 0;
                            if (slotObj.lifetimeExpiresAt && slotObj.lifetimeExpiresAt > now) {
                                msLeft = slotObj.lifetimeExpiresAt - now;
                            } else {
                                const baseBars = (typeof slotObj.lifetimeBars === 'number' && slotObj.lifetimeBars > 0) ? slotObj.lifetimeBars : 8;
                                msLeft = baseBars * barMs;
                            }

                            msLeft = Math.max(barMs, msLeft - sub * barMs); // never go below 1 bar
                            slotObj.lifetimeExpiresAt = now + msLeft;

                            slotObj.lifetimeBars = Math.max(1, Math.ceil((slotObj.lifetimeExpiresAt - now) / barMs));

                            // (re)schedule timers to reflect decreased lifetime
                            try { scheduleSlotLifetime(slotObj); } catch (err) { console.warn('Could not reschedule after subtract:', err); }

                            // tiny visual feedback
                            lifetimeText.style.transform = 'scale(0.95)';
                            setTimeout(() => lifetimeText.style.transform = '', 140);
                        } catch (e) {
                            console.warn('Could not remove bars:', e);
                        }
                    });

                // Delete button handler
                deleteBtn.addEventListener('click', () => {
                    // Clear any lifetime timers before removal
                    if (slotObj.lifetimeTimer) { clearTimeout(slotObj.lifetimeTimer); slotObj.lifetimeTimer = null; }
                    if (slotObj.lifetimeInterval) { clearInterval(slotObj.lifetimeInterval); slotObj.lifetimeInterval = null; }

                    slotDiv.classList.add('removing');
                    setTimeout(() => {
                        const index = slots.findIndex(s => s.id === slotId);
                        if (index !== -1) {
                            slots.splice(index, 1);
                        }
                        slotDiv.remove();
                        refreshPlayback();
                        updateStatus();
                    }, 300);
                });

                // Code change handler - apply on input
                textarea.addEventListener('input', () => {
                    slotObj.code = textarea.value.trim();
                });

                // Enter key handler - apply changes (Cmd/Ctrl+Enter for new line)
                textarea.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.metaKey) {
                        e.preventDefault();

                        // Add flash animation for visual feedback
                        textarea.classList.add('flash');
                        setTimeout(() => textarea.classList.remove('flash'), 400);

                        if (category.name === 'tts') {
                            // For TTS, regenerate with current text
                            const text = textarea.dataset.ttsText || slotPromptInput.value.trim() || 'Welcome';
                            const previousDiceIcon = dice.innerHTML;
                            dice.disabled = true;
                            dice.innerHTML = '⏳';

                            // helper: replace any generic tts token references in code with the concrete sampleName
                            const rewriteTtsReferences = (code, sampleName) => {
                                if (!code || !sampleName) return code;
                                try {
                                    return code.replace(/s\((['"])(.*?)\1\)/g, (m, q, inner) => {
                                        // if inner starts with 'tts' assume it's a generic/legacy tts token and rewrite
                                        if (inner && inner.startsWith('tts')) {
                                            return `s("${sampleName}:0")`;
                                        }
                                        return m;
                                    });
                                } catch (e) {
                                    return code;
                                }
                            };

                            generateTTSSample(text).then((sampleName) => {
                                // If this slot didn't already have a pattern, set a default TTS playback code
                                if (!slotObj.code || !slotObj.code.trim()) {
                                    let defaultTtsCode = `s("${sampleName}:0").n("0 ~ 0 ~")`;
                                    defaultTtsCode = maybeApplyNaturalSkipToCode(defaultTtsCode);
                                    slotObj.code = defaultTtsCode;
                                    textarea.value = defaultTtsCode;
                                    textarea.dataset.ttsText = text;
                                    textarea.dataset.ttsSampleName = sampleName;
                                    try { if (slotPromptInput) slotPromptInput.value = text; } catch (e) {}
                                    try { slotObj.currentTtsSampleName = sampleName; } catch (e) {}
                                } else {
                                    // If there was existing code that referenced a generic tts token, rewrite it to the concrete sampleName
                                    try {
                                        const rewritten = rewriteTtsReferences(slotObj.code, sampleName);
                                        if (rewritten !== slotObj.code) {
                                            slotObj.code = rewritten;
                                            textarea.value = rewritten;
                                        }
                                    } catch (e) { /* ignore */ }
                                }

                                refreshPlayback();
                                // Assign a randomized lifetime for this newly-generated pattern
                                try { scheduleSlotLifetime(slotObj); } catch (e) { console.warn('Could not schedule lifetime:', e); }
                            }).catch(e => {
                                console.error('Error generating TTS:', e);
                            }).finally(() => {
                                dice.disabled = false;
                                dice.innerHTML = previousDiceIcon;
                            });
                        } else {
                            // For regular code, commit the manual edit and enable rewind
                            try {
                                if (slotObj._lastCommittedCode !== slotObj.code) {
                                    // Push the current code before committing the new state so rewind restores correctly
                                    pushToHistory(slotObj.code || '');
                                    slotObj._lastCommittedCode = slotObj.code;
                                }
                            } catch (e) { /* ignore */ }

                            if (!slotObj.isMuted && slotObj.code) {
                                refreshPlayback();
                                try { scheduleSlotLifetime(slotObj); } catch (e) { console.warn('Could not schedule lifetime:', e); }
                            }
                        }
                    }
                });

                // Dice button handler
                dice.addEventListener('click', () => {
                    // Prevent multiple clicks while processing
                    if (dice.disabled) return;

                    if (category.name === 'tts') {
                        const text = slotPromptInput.value.trim() || 'Welcome to the Strudel Mixer';
                        slotPromptInput.value = text;

                        const originalStatus = statusEl.textContent;
                        statusEl.textContent = 'Generating speech...';

                        animateDiceRoll(dice, async () => {
                            try {
                                // Generate and register sample; generateTTSSample returns the concrete sampleName
                                const sampleName = await generateTTSSample(text);

                                // Generate TTS with random effects/variations using the concrete sampleName
                                const ttsVariations = [
                                    `s("${sampleName}:0").speed(1)`,
                                    `s("${sampleName}:0").speed(0.9).room(0.5)`,
                                    `s("${sampleName}:0").speed(1.1).delay(0.25)`,
                                    `s("${sampleName}:0").chop(4).speed(0.95)`,
                                    `s("${sampleName}:0").chop(8).room(0.3)`,
                                    `s("${sampleName}:0").speed("<1 0.9>").room(0.4)`,
                                    `s("${sampleName}:0").striate(4).speed(0.95)`,
                                    `s("${sampleName}:0").sometimes(x=>x.speed(0.8)).delay(0.3)`,
                                    `s("${sampleName}:0").chunk(4, x=>x.fast(rand.range(0.8,1.2)))`,
                                    `s("${sampleName}:0").speed(perlin.range(0.9,1.1)).room(0.5)`,
                                    `s("${sampleName}:0").chop(16).speed(1.05)`,
                                    `s("${sampleName}:0").fast(2).chop(2)`,
                                    `s("${sampleName}:0").slow(2).room(0.7)`,
                                    // TTS-specific rhythmic variations with rests to make speech patterns less repetitive
                                    `s("${sampleName}:0").n("0 ~ 0 ~").speed(1)`,
                                    `s("${sampleName}:0").n("0 ~ ~ 0").speed(0.95).room(0.25)`,
                                    `s("${sampleName}:0").n("0 ~ ~ ~").speed(0.95).room(0.3)`,
                                    `s("${sampleName}:0").speed(1).hpf(200).lpf(3000)`,
                                    `s("${sampleName}:0").speed(rand.range(0.85,1.15)).delay(0.4)`,
                                ];

                                // Avoid generating the same variation if there's already code
                                let ttsCode;
                                const currentCode = slotObj.code || '';

                                // push previous state so user can rewind
                                try { pushToHistory(currentCode); } catch (e) { /* ignore */ }

                                const availableVariations = ttsVariations.filter(v => v !== currentCode);

                                if (availableVariations.length > 0) {
                                    ttsCode = availableVariations[Math.floor(Math.random() * availableVariations.length)];
                                } else {
                                    ttsCode = ttsVariations[Math.floor(Math.random() * ttsVariations.length)];
                                }

                                // Apply a small chance to inject a natural-skip into the pattern code so TTS
                                // playback doesn't feel too repetitive. This is influenced by the "creativity" slider.
                                ttsCode = maybeApplyNaturalSkipToCode(ttsCode);

                                slotObj.code = ttsCode;
                                textarea.value = ttsCode;
                                textarea.dataset.ttsText = text;
                                textarea.dataset.ttsSampleName = sampleName;
                                try { if (slotPromptInput) slotPromptInput.value = text; } catch (e) {}
                                try { slotObj.currentTtsSampleName = sampleName; } catch (e) {}
                                slotObj._lastCommittedCode = slotObj.code;

                                statusEl.textContent = 'Speech generated!';
                                setTimeout(() => {
                                    statusEl.textContent = originalStatus;
                                }, 2000);

                                if (!slotObj.isMuted) {
                                    refreshPlayback();
                                }
                                // Schedule lifetime for this generated TTS pattern (reset to 8 bars)
                                try { scheduleSlotLifetime(slotObj, 8); } catch (e) { console.warn('Could not schedule lifetime:', e); }
                            } catch (e) {
                                console.error('Error generating TTS:', e);
                                statusEl.textContent = 'TTS generation failed';
                                setTimeout(() => {
                                    statusEl.textContent = originalStatus;
                                }, 3000);
                            }
                        });
                    } else {
                        // Category-specific default prompts for cohesive minimal techno
                        const defaultPrompts = {
                            kick: 'four on the floor house kick, 808 heavy sub, or syncopated techno kick',
                            snare: 'backbeat clap or snare with ghost notes and tight reverb',
                            hihat: 'steady 16th hats, triplets, or shuffled hats for groove',
                            perc: 'conga, shaker, rimshots, or polyrhythmic percussion',
                            bass: 'minimal techno pulse, hypnotic repetitive throb, sub bass',
                            melody: 'arpeggiated synth line or bright saw lead melody',
                            chords: 'warm chord stabs, sustained pad or punchy synth chords',
                            texture: 'spacey risers, filtered noise, subtle ambience and fx',
                            arp: 'fast rhythmic arpeggios, dreamy sequences, or evolving patterns'
                        };

                        const prompt = slotPromptInput.value.trim() || defaultPrompts[slotObj.category] || 'minimal techno';

                        animateDiceRoll(dice, async () => {
                            try {
                                let result = await generatePatternFromPrompt(prompt, slotObj.category);

                                // If we got the exact same code, try one more time
                                if (result.code === slotObj.code) {
                                    result = await generatePatternFromPrompt(prompt, slotObj.category);
                                }

                                // push previous state for rewind
                                try { pushToHistory(slotObj.code || ''); } catch (e) { /* ignore */ }

                                slotObj.code = result.code;
                                textarea.value = result.code;
                                slotObj._lastCommittedCode = slotObj.code;

                                // Update the prompt input with the pattern's description
                                slotPromptInput.value = result.description;

                                if (!slotObj.isMuted) {
                                    refreshPlayback();
                                }
                                // Rolling the dice resets lifetime to 8 bars (unless pinned)
                                try { scheduleSlotLifetime(slotObj, 8); } catch (e) { console.warn('Could not schedule lifetime:', e); }
                            } catch (e) {
                                console.error('Error generating pattern:', e);
                            }
                        });
                    }
                });

                // Spice button handler - mutate existing pattern
                spice.addEventListener('click', () => {
                    // Prevent multiple clicks while processing
                    if (spice.disabled) return;

                    // Need existing code to mutate
                    if (!slotObj.code || !slotObj.code.trim()) {
                        console.log('No pattern to spice up - roll the dice first!');
                        return;
                    }

                    if (category.name === 'tts') {
                        // For TTS, apply spice to the existing TTS code
                        animateDiceRoll(spice, async () => {
                            const currentCode = slotObj.code;
                            try { pushToHistory(currentCode); } catch (e) {}
                            const spicedCode = spiceUpPattern(currentCode, category.name);

                            if (spicedCode !== currentCode) {
                                slotObj.code = spicedCode;
                                textarea.value = spicedCode;
                                slotObj._lastCommittedCode = slotObj.code;

                                if (!slotObj.isMuted) {
                                    refreshPlayback();
                                }
                                try { scheduleSlotLifetime(slotObj); } catch (e) { console.warn('Could not schedule lifetime:', e); }
                            }
                        }, 'spicing');
                    } else {
                        // For regular patterns, apply mutations
                        animateDiceRoll(spice, async () => {
                            const currentCode = slotObj.code;
                            try { pushToHistory(currentCode); } catch (e) {}
                            const spicedCode = spiceUpPattern(currentCode, category.name);

                            if (spicedCode !== currentCode) {
                                slotObj.code = spicedCode;
                                textarea.value = spicedCode;
                                slotObj._lastCommittedCode = slotObj.code;

                                if (!slotObj.isMuted) {
                                    refreshPlayback();
                                }
                                try { scheduleSlotLifetime(slotObj); } catch (e) { console.warn('Could not schedule lifetime:', e); }
                            }
                        }, 'spicing');
                    }
                });

                // Rewind handler: pop last saved code state and restore it
                rewindBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!slotObj.history || slotObj.history.length === 0) return;
                    // animate the button briefly for feedback
                    try {
                        rewindBtn.classList.add('rewinding');
                        setTimeout(() => rewindBtn.classList.remove('rewinding'), 520);
                    } catch (err) {
                        /* ignore animation errors */
                    }
                    // Pop the last entry. If the entry has no code and no prompt,
                    // continue popping until we find a meaningful entry or history is empty.
                    let prev = slotObj.history.pop();
                    // skip empty tombstone entries (often from initial empty pushes)
                    while (prev && !prev.code && !prev.prompt && slotObj.history.length > 0) {
                        try { console.log('[history] skipping empty tombstone for slot', slotObj.id); } catch (e) {}
                        prev = slotObj.history.pop();
                    }
                    try { console.log('[history] pop:', { slotId: slotObj.id, prev, remaining: slotObj.history.length }); } catch (e) {}
                    try {
                        const prevCode = prev && typeof prev.code === 'string' ? prev.code : '';
                        const prevPrompt = prev && typeof prev.prompt === 'string' ? prev.prompt : '';

                        // If this is a TTS slot, ensure the sample is registered for the restored prompt
                        const rewriteTtsReferences = (code, sampleName) => {
                            if (!code || !sampleName) return code;
                            try {
                                return code.replace(/s\((['"])(.*?)\1\)/g, (m, q, inner) => {
                                    if (inner && inner.startsWith('tts')) {
                                        return `s("${sampleName}:0")`;
                                    }
                                    return m;
                                });
                            } catch (e) { return code; }
                        };

                        if (slotObj.category === 'tts') {
                            // Try to determine the prompt by reverse lookup from sample name in code
                            let promptToRestore = '';
                            let sampleNameFromCode = null;
                            // If history entry explicitly included a sampleName, prefer it
                            let historySampleName = prev && prev.sampleName ? prev.sampleName : '';
                            try {
                                const m = prevCode && prevCode.match(/s\((['"])([^'\"]+):\d+\1\)/);
                                if (m && m[2]) sampleNameFromCode = m[2];
                            } catch (e) { /* ignore */ }

                            // Use the sample name to reverse lookup the prompt
                            const sampleNameForLookup = historySampleName || sampleNameFromCode;
                            if (sampleNameForLookup) {
                                try {
                                    for (const [p, n] of Object.entries(ttsSampleNameByPrompt)) {
                                        if (n === sampleNameForLookup) { promptToRestore = p; break; }
                                    }
                                } catch (e) { /* ignore reverse lookup errors */ }
                            }
                            // Fallback to saved prompt if reverse lookup failed
                            if (!promptToRestore) {
                                promptToRestore = prevPrompt || '';
                            }

                            // helper to rewrite generic tts tokens to a concrete sample name
                            const rewriteTtsReferences = (code, sampleName) => {
                                if (!code || !sampleName) return code;
                                try {
                                    return code.replace(/s\((['"])(.*?)\1\)/g, (m, q, inner) => {
                                        if (inner && inner.startsWith('tts')) {
                                            return `s("${sampleName}:0")`;
                                        }
                                        return m;
                                    });
                                } catch (e) { return code; }
                            };

                            // If the history entry included an explicit sampleName, prefer restoring
                            // using that exact sample id (less brittle than regenerating by prompt).
                            if (historySampleName) {
                                try {
                                    const sampleName = historySampleName;
                                    // If prevCode already references this sampleName, keep it as-is.
                                    let restoredCode = prevCode;
                                    try {
                                        const contains = prevCode && prevCode.indexOf(sampleName) !== -1;
                                        if (!contains) {
                                            // rewrite only generic/legacy tts tokens to the concrete sampleName
                                            restoredCode = rewriteTtsReferences(prevCode, sampleName);
                                        }
                                    } catch (e) { /* ignore */ }

                                    slotObj.code = restoredCode;
                                    textarea.value = restoredCode;
                                    try { textarea.dataset.ttsSampleName = sampleName; } catch (e) {}
                                    try { slotObj.currentTtsSampleName = sampleName; } catch (e) {}
                                    // Always try reverse lookup for the correct prompt for this sample
                                    let promptToSet = '';
                                    try {
                                        for (const [p, n] of Object.entries(ttsSampleNameByPrompt)) {
                                            if (n === sampleName) { promptToSet = p; break; }
                                        }
                                    } catch (e) {}
                                    // Fallback to saved prompt if reverse lookup failed
                                    if (!promptToSet) {
                                        promptToSet = prevPrompt || '';
                                    }
                                    textarea.dataset.ttsText = promptToSet;
                                    try { if (slotPromptInput) slotPromptInput.value = promptToSet; } catch (e) {}

                                    if (typeof slotObj.id === 'number' && Array.isArray(slots)) {
                                        const idx = slots.findIndex(s => s.id === slotObj.id);
                                        if (idx !== -1) {
                                            slots[idx].code = restoredCode;
                                            console.log('[rewind] Updated slots[' + idx + '].code (by historySampleName):', slots[idx].code);
                                        }
                                    }

                                    slotObj._lastCommittedCode = slotObj.code;
                                    updateRewindButton();
                                    // ensure sample is registered if we have a prompt for it
                                    if (prevPrompt) {
                                        generateTTSSample(prevPrompt).then(() => {
                                            setTimeout(() => { if (!slotObj.isMuted) refreshPlayback(); }, 40);
                                        }).catch(() => { setTimeout(() => { if (!slotObj.isMuted) refreshPlayback(); }, 60); });
                                    } else {
                                        // no prompt available - play and hope the sample remains registered
                                        setTimeout(() => { if (!slotObj.isMuted) refreshPlayback(); }, 60);
                                    }
                                    try { scheduleSflotLifetime(slotObj); } catch (err) { console.warn('Could not schedule after rewind:', err); }
                                } catch (e) {
                                    console.warn('Rewind using history.sampleName failed:', e);
                                }
                            }
                            // If we have a prompt, (re)ensure the sample is registered and then restore.
                            else if (promptToRestore) {
                                try {
                                    generateTTSSample(promptToRestore).then((sampleName) => {
                                        try { console.log('[rewind] generateTTSSample returned sampleName:', sampleName); } catch (e) {}
                                        try {
                                            const rewritten = rewriteTtsReferences(prevCode, sampleName);
                                            slotObj.code = rewritten;
                                            try { console.log('[rewind] restored code for slot', slotObj.id, slotObj.code); } catch (e) {}
                                            textarea.value = rewritten;
                                            // record the restored sample name so UI and future history entries know
                                            try { textarea.dataset.ttsSampleName = sampleName; } catch (e) {}
                                            try { slotObj.currentTtsSampleName = sampleName; } catch (e) {}
                                            // Ensure global slots array is updated before playback
                                            if (typeof slotObj.id === 'number' && Array.isArray(slots)) {
                                                const idx = slots.findIndex(s => s.id === slotObj.id);
                                                if (idx !== -1) {
                                                    slots[idx].code = rewritten;
                                                    console.log('[rewind] Updated slots[' + idx + '].code:', slots[idx].code);
                                                }
                                            }
                                            // ensure dataset and visible prompt are synchronized
                                            textarea.dataset.ttsText = promptToRestore;
                                            try { if (slotPromptInput) slotPromptInput.value = promptToRestore; } catch (e) {}
                                            slotObj._lastCommittedCode = slotObj.code;
                                            updateRewindButton();
                                            // small delay to ensure sample registration is settled before playback
                                            setTimeout(() => { if (!slotObj.isMuted) refreshPlayback(); }, 60);
                                            try { scheduleSlotLifetime(slotObj); } catch (err) { console.warn('Could not schedule after rewind:', err); }
                                        } catch (e) {
                                            console.warn('Rewind TTS rewrite failed:', e);
                                        }
                                    }).catch(e => {
                                        console.warn('Failed to regenerate TTS during rewind:', e);
                                        // fallback to restoring raw code/prompt
                                        slotObj.code = prevCode;
                                        try { console.log('[rewind] restored code for slot', slotObj.id, slotObj.code); } catch (e) {}
                                        textarea.value = prevCode;
                                        if (typeof slotObj.id === 'number' && Array.isArray(slots)) {
                                            const idx = slots.findIndex(s => s.id === slotObj.id);
                                            if (idx !== -1) {
                                                slots[idx].code = prevCode;
                                                console.log('[rewind] Updated slots[' + idx + '].code:', slots[idx].code);
                                            }
                                        }
                                        // restore dataset & visible prompt
                                        try { textarea.dataset.ttsText = prevPrompt; } catch (e) {}
                                        try { if (slotPromptInput) slotPromptInput.value = prevPrompt; } catch (e) {}
                                        slotObj._lastCommittedCode = slotObj.code;
                                        updateRewindButton();
                                        setTimeout(() => { if (!slotObj.isMuted) refreshPlayback(); }, 60);
                                        try { scheduleSlotLifetime(slotObj); } catch (err) { console.warn('Could not schedule after rewind:', err); }
                                    });
                                } catch (e) {
                                    // if async regeneration fails, fall back to raw restore
                                    slotObj.code = prevCode;
                                    try { console.log('[rewind] restored code for slot', slotObj.id, slotObj.code); } catch (e) {}
                                    textarea.value = prevCode;
                                    if (typeof slotObj.id === 'number' && Array.isArray(slots)) {
                                        const idx = slots.findIndex(s => s.id === slotObj.id);
                                        if (idx !== -1) {
                                            slots[idx].code = prevCode;
                                            console.log('[rewind] Updated slots[' + idx + '].code:', slots[idx].code);
                                        }
                                    }
                                    try { if (slotPromptInput) slotPromptInput.value = prevPrompt; } catch (e) {}
                                    slotObj._lastCommittedCode = slotObj.code;
                                    updateRewindButton();
                                    if (!slotObj.isMuted) refreshPlayback();
                                    try { scheduleSlotLifetime(slotObj); } catch (err) { console.warn('Could not schedule after rewind:', err); }
                                }
                            } else if (sampleNameFromCode) {
                                // We don't have the original prompt text, but the code already references
                                // a concrete sample name. Restore using that sampleName and try to
                                // recover a visible prompt via reverse mapping if possible.
                                try {
                                    const rewritten = rewriteTtsReferences(prevCode, sampleNameFromCode);
                                    slotObj.code = rewritten;
                                    textarea.value = rewritten;
                                    try { textarea.dataset.ttsSampleName = sampleNameFromCode; } catch (e) {}
                                    try { slotObj.currentTtsSampleName = sampleNameFromCode; } catch (e) {}
                                    if (typeof slotObj.id === 'number' && Array.isArray(slots)) {
                                        const idx = slots.findIndex(s => s.id === slotObj.id);
                                        if (idx !== -1) {
                                            slots[idx].code = rewritten;
                                            console.log('[rewind] Updated slots[' + idx + '].code:', slots[idx].code);
                                        }
                                    }
                                    // attempt reverse lookup for a visible prompt
                                    let recoveredPrompt = '';
                                    try {
                                        for (const [p, n] of Object.entries(ttsSampleNameByPrompt)) {
                                            if (n === sampleNameFromCode) { recoveredPrompt = p; break; }
                                        }
                                    } catch (e) { /* ignore */ }
                                    textarea.dataset.ttsText = recoveredPrompt || '';
                                    try { if (slotPromptInput) slotPromptInput.value = recoveredPrompt || ''; } catch (e) {}
                                    slotObj._lastCommittedCode = slotObj.code;
                                    updateRewindButton();
                                    setTimeout(() => { if (!slotObj.isMuted) refreshPlayback(); }, 60);
                                    try { scheduleSlotLifetime(slotObj); } catch (err) { console.warn('Could not schedule after rewind:', err); }
                                } catch (e) {
                                    console.warn('Rewind restore with concrete sampleName failed:', e);
                                    // fallback to raw restore
                                    slotObj.code = prevCode;
                                    textarea.value = prevCode;
                                    try { if (slotPromptInput) slotPromptInput.value = prevPrompt; } catch (e) {}
                                    slotObj._lastCommittedCode = slotObj.code;
                                    updateRewindButton();
                                    if (!slotObj.isMuted) refreshPlayback();
                                    try { scheduleSlotLifetime(slotObj); } catch (err) { console.warn('Could not schedule after rewind:', err); }
                                }
                            } else {
                                // No prompt and no concrete sample name available; simple restore
                                slotObj.code = prevCode;
                                try { console.log('[rewind] restored code for slot', slotObj.id, slotObj.code); } catch (e) {}
                                textarea.value = prevCode;
                                if (typeof slotObj.id === 'number' && Array.isArray(slots)) {
                                    const idx = slots.findIndex(s => s.id === slotObj.id);
                                    if (idx !== -1) {
                                        slots[idx].code = prevCode;
                                        console.log('[rewind] Updated slots[' + idx + '].code:', slots[idx].code);
                                    }
                                }
                                try { if (slotPromptInput) slotPromptInput.value = prevPrompt; } catch (e) {}
                                slotObj._lastCommittedCode = slotObj.code;
                                updateRewindButton();
                                if (!slotObj.isMuted) refreshPlayback();
                                try { scheduleSlotLifetime(slotObj); } catch (err) { console.warn('Could not schedule after rewind:', err); }
                            }
                        } else {
                            // Non-TTS slot: simple restore
                            slotObj.code = prevCode;
                            try { console.log('[rewind] restored code for slot', slotObj.id, slotObj.code); } catch (e) {}
                            textarea.value = prevCode;
                            if (typeof slotObj.id === 'number' && Array.isArray(slots)) {
                                const idx = slots.findIndex(s => s.id === slotObj.id);
                                if (idx !== -1) {
                                    slots[idx].code = prevCode;
                                    console.log('[rewind] Updated slots[' + idx + '].code:', slots[idx].code);
                                }
                            }
                            try { if (slotPromptInput) slotPromptInput.value = prevPrompt; } catch (e) {}
                            slotObj._lastCommittedCode = slotObj.code;
                            updateRewindButton();
                            if (!slotObj.isMuted) refreshPlayback();
                            try { scheduleSlotLifetime(slotObj); } catch (err) { console.warn('Could not schedule after rewind:', err); }
                        }
                    } catch (e) {
                        console.warn('Rewind failed:', e);
                    }
                });

                // Prompt input Enter key handler - trigger dice roll
                slotPromptInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !dice.disabled) {
                        e.preventDefault();
                        dice.click();
                    }
                });

                // Drag and drop handlers
                dragHandle.addEventListener('dragstart', (e) => {
                    slotDiv.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', slotId);
                });

                dragHandle.addEventListener('dragend', () => {
                    slotDiv.classList.remove('dragging');
                    document.querySelectorAll('.slot').forEach(el => el.classList.remove('drag-over'));
                });

                slotDiv.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    const dragging = document.querySelector('.dragging');
                    if (dragging && dragging !== slotDiv) {
                        slotDiv.classList.add('drag-over');
                    }
                });

                slotDiv.addEventListener('dragleave', () => {
                    slotDiv.classList.remove('drag-over');
                });

                slotDiv.addEventListener('drop', (e) => {
                    e.preventDefault();
                    slotDiv.classList.remove('drag-over');

                    const draggedId = parseInt(e.dataTransfer.getData('text/plain'));
                    const draggedSlot = slots.find(s => s.id === draggedId);
                    const targetSlot = slots.find(s => s.id === slotId);

                    if (draggedSlot && targetSlot && draggedSlot !== targetSlot) {
                        // Reorder in array
                        const draggedIndex = slots.indexOf(draggedSlot);
                        const targetIndex = slots.indexOf(targetSlot);

                        slots.splice(draggedIndex, 1);
                        slots.splice(targetIndex, 0, draggedSlot);

                        // Reorder in DOM
                        slotsGrid.innerHTML = '';
                        slots.forEach(slot => slotsGrid.appendChild(slot.element));

                        refreshPlayback();
                    }
                });

                return slotObj;
            };

            // Create add layer buttons for each category
            slotCategories.forEach(category => {
                const addBtn = document.createElement('button');
                addBtn.className = 'add-slot-btn';
                addBtn.style.setProperty('--category-color', category.color);

                const emoji = document.createElement('div');
                emoji.className = 'add-slot-btn-emoji';
                emoji.textContent = category.icon;

                const label = document.createElement('div');
                label.className = 'add-slot-btn-label';
                label.textContent = category.desc;

                addBtn.appendChild(emoji);
                addBtn.appendChild(label);
                addBtn.title = `Add ${category.desc} layer`;

                addBtn.addEventListener('click', () => {
                    const slot = createSlot(category.name);
                    slots.push(slot);
                    slotsGrid.appendChild(slot.element);
                    updateStatus();
                });

                addSlotContainer.appendChild(addBtn);
            });

            // Update status message
            const updateStatus = () => {
                const activeCount = slots.filter(s => !s.isMuted && s.code).length;
                statusEl.textContent = `${slots.length} layers (${activeCount} active)${sampleStatusSuffix}`;
            };

            masterVolumeSlider.addEventListener('input', () => {
                masterVolume = parseFloat(masterVolumeSlider.value);
                refreshPlayback();
            });

            masterReverbSlider.addEventListener('input', () => {
                masterReverb = parseFloat(masterReverbSlider.value);
                refreshPlayback();
            });

            if (creativitySlider) {
                creativitySlider.addEventListener('input', () => {
                    creativity = parseFloat(creativitySlider.value);
                    // Update status briefly to reflect change
                    statusEl.textContent = `Creativity: ${Math.round(creativity * 100)}%`;
                    setTimeout(() => updateStatus(), 900);
                });
            }

            const refreshPlayback = () => {
                if (!schedulerApi) {
                    console.warn('Scheduler is not ready yet.');
                    return;
                }

                // Collect all unmuted slots with code
                const activePatterns = [];
                slots.forEach((slot, index) => {
                    if (!slot.isMuted && slot.code) {
                        try {
                            console.log(`Evaluating slot ${slot.id} (${slot.category}):`, slot.code);
                            const pattern = eval(slot.code);
                            console.log(`Slot ${slot.id} pattern:`, pattern);
                            activePatterns.push(pattern);
                        } catch (e) {
                            console.error(`Error evaluating slot ${slot.id}:`, e);
                            console.error('Code was:', slot.code);
                        }
                    }
                });

                if (activePatterns.length === 0) {
                    // Try to pause the transport instead of stopping completely
                    if (schedulerApi?.pause) {
                        schedulerApi.pause();
                    } else if (typeof window.pause === 'function') {
                        window.pause();
                    } else if (schedulerApi?.hush) {
                        schedulerApi.hush();
                    } else if (typeof window.hush === 'function') {
                        window.hush();
                    }
                    updateStatus();
                    return;
                }

                // Stack all active patterns together
                let mixedPattern = stack(...activePatterns);

                // Apply master controls
                if (masterVolume !== 1) {
                    mixedPattern = mixedPattern.gain(masterVolume);
                }

                if (masterReverb > 0) {
                    mixedPattern = mixedPattern.room(masterReverb);
                }

                try {
                    if (schedulerApi?.setPattern) {
                        schedulerApi.setPattern(mixedPattern, false);
                    } else {
                        mixedPattern.play();
                    }
                } catch (e) {
                    console.error('Error setting pattern:', e);
                }

                updateStatus();

                // If audio is playing (or we've just engaged playback), ensure any
                // slots with pending lifetimeBars start their countdowns. We only
                // start timers when the transport appears to be playing so that
                // lifetimes don't tick down while the system is idle.
                const playing = isTransportPlaying();
                if (playing) {
                    slots.forEach(s => {
                        try {
                            if (!s) return;
                            if (s.pinned) return;
                            // If a slot has lifetimeBars set but no active timer, schedule it
                            if ((typeof s.lifetimeBars === 'number') && !s.lifetimeTimer) {
                                // schedule with remaining bars if expiresAt present
                                try { scheduleSlotLifetime(s); } catch (err) { /* ignore */ }
                            }
                        } catch (e) {}
                    });
                }
            };

            // Enable prompt inputs when AI model is ready
            if (extractor) {
                // AI is ready, users can add slots
            }

            stopDiceAnimation();
            updateLoadingProgress('All systems ready!');
            statusEl.textContent = `Ready! ${sampleStatusSuffix}`;

            // Hide loading screen with a slight delay and enable Auto button once init is complete
            setTimeout(() => {
                loadingScreen.classList.add('hidden');
                try { if (autoBtn) { autoBtn.disabled = false; setAutoBtnState(false); } } catch (e) {}
            }, 500);

            // Pre-warm TTS samples in the background (optional)
            // This helps avoid audio freezing during playback
            // Uncomment the next line to enable:
            // preWarmTTS();

        })().catch((error) => {
            console.error('Strudel init failed', error);
            const statusEl = document.getElementById('status');
            const loadingProgress = document.getElementById('loading-progress');
            const loadingScreen = document.getElementById('loading-screen');

            loadingProgress.textContent = '❌ Failed to load. Check console for details.';
            statusEl.textContent = 'Could not load Strudel. Please check the console for details.';

            // Still hide loading screen after error; enable Auto button so user can retry once
            setTimeout(() => {
                loadingScreen.classList.add('hidden');
                try { if (autoBtn) { autoBtn.disabled = false; setAutoBtnState(false); } } catch (e) {}
            }, 3000);
        });
    </script>
</body>

</html>