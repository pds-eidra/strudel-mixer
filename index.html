<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Strudel Layer Mixer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        :root {
            color-scheme: light dark;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            background: #f0f2f5;
            color: #1c1c1c;
            padding: 1rem;
        }

        @media (prefers-color-scheme: dark) {
            body {
                background: #0f1115;
                color: #e6e9ef;
            }
        }

        header {
            padding: 1rem;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 1rem;
        }

        @media (prefers-color-scheme: dark) {
            header {
                background: rgba(24, 26, 32, 0.85);
            }
        }

        .header-main {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 2rem;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            letter-spacing: -0.02em;
        }

        .header-controls {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: flex-start;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            min-width: 0; /* allow children to shrink in tight containers */
        }

        /* Ensure the label and slider are consistently laid out:
           - label keeps a predictable width so long labels don't push the slider
           - slider uses flex so all sliders visually match regardless of surrounding text */
        .control-group > .control-label {
            flex: 0 0 110px; /* fixed label column width (adjustable) */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .control-group > .control-slider {
            flex: 1 1 200px; /* slider will take remaining space but stay consistent */
            width: auto; /* allow flexbox to control width */
            min-width: 120px;
            max-width: 420px;
        }

        .control-label {
            font-size: 0.85rem;
            opacity: 0.7;
            font-weight: 500;
        }

        .control-input {
            padding: 0.4rem 0.6rem;
            font-size: 0.9rem;
            border-radius: 6px;
            border: 2px solid rgba(0, 0, 0, 0.2);
            background: rgba(255, 255, 255, 0.7);
            color: inherit;
            font-weight: 500;
            width: 70px;
            text-align: center;
        }

        @media (prefers-color-scheme: dark) {
            .control-input {
                background: rgba(255, 255, 255, 0.1);
                border-color: rgba(255, 255, 255, 0.2);
            }
        }

        .control-input:focus {
            outline: 2px solid currentColor;
            outline-offset: 1px;
        }

        .control-slider {
            width: 120px;
            height: 6px;
            border-radius: 3px;
            background: rgba(0, 0, 0, 0.2);
            outline: none;
            appearance: none;
            -webkit-appearance: none;
        }

        @media (prefers-color-scheme: dark) {
            .control-slider {
                background: rgba(255, 255, 255, 0.2);
            }
        }

        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: currentColor;
            cursor: pointer;
            transition: transform 150ms ease;
        }

        .control-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .control-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: currentColor;
            cursor: pointer;
            border: none;
            transition: transform 150ms ease;
        }

        .control-slider::-moz-range-thumb:hover {
            transform: scale(1.2);
        }

        /* Loading screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 500ms ease, visibility 500ms ease;
        }

        @media (prefers-color-scheme: dark) {
            .loading-screen {
                background: #0f1115;
            }
        }

        .loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .loading-content {
            text-align: center;
            color: #1c1c1c;
        }

        @media (prefers-color-scheme: dark) {
            .loading-content {
                color: #e6e9ef;
            }
        }

        .loading-title {
            font-size: 3rem;
            font-weight: 700;
            margin: 0 0 1rem 0;
            letter-spacing: -0.02em;
        }

        .loading-subtitle {
            font-size: 1.2rem;
            opacity: 0.7;
            margin: 0 0 3rem 0;
            font-weight: 400;
        }

        .loading-dice {
            font-size: 5rem;
            margin: 0 auto 2rem;
            user-select: none;
            font-weight: 300;
        }

        .loading-progress {
            font-size: 0.9rem;
            opacity: 0.8;
            font-weight: 500;
            min-height: 1.5rem;
        }

        @keyframes rollDice {
            0% {
                transform: rotate(0deg) scale(1);
            }

            10% {
                transform: rotate(90deg) scale(1.05);
            }

            20% {
                transform: rotate(180deg) scale(1);
            }

            30% {
                transform: rotate(270deg) scale(1.05);
            }

            40% {
                transform: rotate(360deg) scale(1);
            }

            50% {
                transform: rotate(405deg) scale(1.02);
            }

            55% {
                transform: rotate(420deg) scale(1);
            }

            60% {
                transform: rotate(360deg) scale(1);
            }

            100% {
                transform: rotate(360deg) scale(1);
            }
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.05);
                opacity: 0.9;
            }
        }

        .header-main {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 2rem;
        }

        .add-slot-container {
            /* Keep add buttons on a single horizontal row. If there are more buttons
               than fit the viewport, allow horizontal scrolling instead of wrapping. */
            display: flex;
            gap: 0.75rem;
            padding: 0.5rem 0.75rem;
            border-radius: 8px;
            align-items: center;
            flex-wrap: nowrap; /* never wrap to next line */
            overflow-x: auto; /* allow scrolling when content is wider than container */
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
        }



        .add-slot-btn {
            aspect-ratio: 1;
            /* use a responsive width but allow it to shrink so many buttons fit on one line */
            width: clamp(56px, 7.5vw, 100px);
            flex: 0 0 auto; /* don't grow, but don't force a specific basis beyond width */
            padding: 0.4rem;
            font-size: 0.85rem;
            border: 2px solid var(--category-color);
            border-radius: 12px;
            cursor: pointer;
            transition: all 200ms ease;
            background: var(--category-color);
            color: inherit;
            font-weight: 600;
            opacity: 0.8;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            text-align: center;
            min-width: 48px;
        }

        .add-slot-btn-emoji {
            font-size: 2rem;
            line-height: 1;
            font-weight: 300;
        }

        .add-slot-btn-label {
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: capitalize;
        }

        .add-slot-btn:hover {
            opacity: 1;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .slot-type-picker {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            animation: slideIn 200ms ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .slot-type-option {
            padding: 0.5rem 1rem;
            border: 2px solid var(--category-color);
            background: var(--category-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 200ms ease;
            font-size: 0.9rem;
            font-weight: 500;
            opacity: 0.7;
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .slot-type-option:hover {
            opacity: 1;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .prompt-input {
            padding: 0.5rem 1rem;
            font-size: 0.95rem;
            border-radius: 8px;
            border: 2px solid currentColor;
            background: rgba(255, 255, 255, 0.5);
            color: inherit;
            font-weight: 500;
            min-width: 300px;
            flex: 1;
        }

        @media (prefers-color-scheme: dark) {
            .prompt-input {
                background: rgba(255, 255, 255, 0.1);
            }
        }

        .prompt-input::placeholder {
            opacity: 0.5;
        }

        .slot-prompt {
            flex: 1;
            padding: 0.4rem 0.6rem;
            font-size: 0.75rem;
            border-radius: 6px;
            border: 1px solid rgba(0, 0, 0, 0.2);
            background: rgba(255, 255, 255, 0.7);
            color: inherit;
            font-weight: 400;
            min-width: 0;
        }

        @media (prefers-color-scheme: dark) {
            .slot-prompt {
                background: rgba(255, 255, 255, 0.05);
                border-color: rgba(255, 255, 255, 0.2);
            }
        }

        .slot-prompt::placeholder {
            opacity: 0.5;
        }

        .slot-prompt:focus {
            outline: 2px solid currentColor;
            outline-offset: 1px;
        }

        .slot-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            flex-wrap: wrap;
        }

        .status {
            font-size: 0.85rem;
            opacity: 0.7;
        }

        .slots-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(450px, 1fr));
            gap: 0.5rem;
            flex: 1;
        }

        .slot {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            transition: all 300ms ease;
            border-left: 4px solid var(--slot-color);
            position: relative;
            animation: slotAppear 300ms ease-out;
        }

        @keyframes slotAppear {
            from {
                opacity: 0;
                transform: translateX(-20px) scale(0.95);
            }

            to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }
        }

        @keyframes slotDisappear {
            to {
                opacity: 0;
                transform: translateX(20px) scale(0.95);
            }
        }

        .slot.removing {
            animation: slotDisappear 300ms ease-out forwards;
        }

        @media (prefers-color-scheme: dark) {
            .slot {
                background: rgba(24, 26, 32, 0.85);
            }
        }

        /* When a slot is muted we want the slot content to appear dimmed/greyed,
       but keep the unmute button fully visible and clickable. Avoid using
       `opacity` on the parent because that also fades children. Instead
       render a semi-opaque overlay and dim specific content. */
        .slot.is-muted {
            transform: scale(0.98);
            /* create stacking context for overlay and controls */
            position: relative;
        }

        /* soft overlay that greys/dims the slot content but sits under header controls */
        .slot.is-muted::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 12px;
            pointer-events: none;
            z-index: 1;
            /* under controls which will be z-index:2+ */
            /* Use the slot color as the base for the overlay (rgb provided by JS).
         Fallback to white for light mode if the RGB variable isn't present. */
            background: rgba(var(--slot-color-rgb, 255, 255, 255), 0.18);
            mix-blend-mode: luminosity;
            transition: background 200ms ease, opacity 200ms ease;
        }

        /* dim code and decorative emoji more aggressively */
        .slot.is-muted .slot-code,
        .slot.is-muted .slot-code-emoji,
        .slot.is-muted .slot-prompt {
            opacity: 0.35;
        }

        /* ensure interactive controls remain clearly visible above the overlay */
        .slot .slot-mute-btn,
        .slot .slot-delete-btn,
        .slot .slot-dice,
        .slot .slot-spice,
        .slot .slot-rewind {
            position: relative;
            z-index: 3;
        }

        @media (prefers-color-scheme: dark) {

            /* use a darker overlay in dark mode so the dimming feels natural */
            .slot.is-muted::after {
                /* For dark mode, use a stronger tint from the slot color, falling back
           to a near-black if the variable isn't present. This avoids pure black
           while still providing sufficient dimming. */
                background: rgba(var(--slot-color-rgb, 10, 12, 16), 0.30);
                mix-blend-mode: normal;
            }
        }

        .slot-header {
            display: flex;
            flex-direction: column; /* two rows: top row (drag/mute/lifecycle), bottom row (controls) */
            justify-content: flex-start;
            align-items: stretch;
            margin-bottom: 0.75rem;
            gap: 0.5rem;
        }

        /* Make the top row items align horizontally */
        .slot-header > div:first-child {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 0.5rem;
        }

        .slot-mute-btn {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: 2px solid var(--slot-color);
            background: var(--slot-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 200ms ease;
            opacity: 0.9;
            flex-shrink: 0;
        }

        .slot-mute-btn:hover {
            opacity: 1;
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        /* When the slot is muted the button will usually toggle to an "unmute"
       state; keep it fully visible and obvious so the user can unmute quickly. */
        .slot-mute-btn.is-muted {
            opacity: 1;
            background: var(--slot-color);
            color: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: scale(1.05);
            border-color: rgba(0, 0, 0, 0.12);
        }

        .slot-delete-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid rgba(255, 80, 80, 0.8);
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 200ms ease;
            opacity: 0.4;
            color: rgba(255, 80, 80, 0.9);
        }

        .slot-delete-btn:hover {
            opacity: 1;
            transform: scale(1.1) rotate(90deg);
            background: rgba(255, 80, 80, 0.2);
        }

        .slot-color-indicator {
            display: none;
        }

        .slot-reload {
            display: none;
        }

        .slot-dice,
        .slot-spice,
        .slot-rewind {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            border: 2px solid currentColor;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            line-height: 1;
            transition: transform 200ms ease, background 200ms ease;
            opacity: 0.7;
            flex-shrink: 0;
            padding: 0;
        }

        .slot-dice:hover,
        .slot-spice:hover,
        .slot-rewind:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.05);
            transform: scale(1.15);
        }

        @media (prefers-color-scheme: dark) {

            .slot-dice:hover,
            .slot-spice:hover {
                background: rgba(255, 255, 255, 0.1);
            }
        }

        .slot-dice:active,
        .slot-spice:active,
        .slot-rewind:active {
            transform: scale(0.95) rotate(360deg);
        }

        .slot-dice:disabled,
        .slot-spice:disabled,
        .slot-rewind:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .slot-dice.rolling,
        .slot-spice.spicing,
        .slot-rewind.rewinding {
            opacity: 1 !important;
            pointer-events: none;
            font-size: 1.5rem;
            line-height: 1;
            animation: diceSpinCycle 0.4s ease-in-out infinite;
        }

        .slot-spice {
            border-color: currentColor;
        }

        @media (prefers-color-scheme: dark) {
            .slot-spice {
                border-color: currentColor;
            }
        }

        @keyframes diceSpinCycle {
            0% {
                transform: scale(1) rotate(0deg);
            }

            50% {
                transform: scale(1.2) rotate(180deg);
            }

            100% {
                transform: scale(1) rotate(360deg);
            }
        }

        @keyframes rewindPulse {
            0% { transform: scale(1) rotate(0deg); opacity: 1; }
            40% { transform: scale(1.18) rotate(-120deg); opacity: 1; }
            80% { transform: scale(0.98) rotate(-300deg); opacity: 0.95; }
            100% { transform: scale(1) rotate(-360deg); opacity: 1; }
        }

        .slot-rewind.rewinding {
            animation: rewindPulse 420ms cubic-bezier(.2,.9,.3,1) both;
        }

        .slot-code-wrapper {
            flex: 1;
            position: relative;
            display: flex;
        }

        .slot-code-emoji {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12rem;
            opacity: 0.12;
            pointer-events: none;
            z-index: 0;
            user-select: none;
            font-weight: 300;
        }

        .slot-code {
            flex: 1;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.8rem;
            line-height: 1.5;
            padding: 0.75rem;
            border: 1px solid rgba(0, 0, 0, 0.15);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.03);
            color: inherit;
            resize: vertical;
            min-height: 80px;
            position: relative;
            z-index: 1;
        }

        @media (prefers-color-scheme: dark) {
            .slot-code {
                background: rgba(0, 0, 0, 0.3);
                border-color: rgba(255, 255, 255, 0.15);
            }

            .slot-code-emoji {
                opacity: 0.1;
            }
        }

        .slot-code:focus {
            outline: 2px solid currentColor;
            outline-offset: 2px;
        }

        .slot-code::placeholder {
            opacity: 0.4;
            font-style: italic;
        }

        .slot.is-empty .slot-code {
            opacity: 0.5;
        }

        @keyframes flashBorder {

            0%,
            100% {
                border-color: rgba(0, 0, 0, 0.15);
                box-shadow: 0 0 0 0 currentColor;
            }

            50% {
                border-color: currentColor;
                box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.3);
            }
        }

        @media (prefers-color-scheme: dark) {
            @keyframes flashBorder {

                0%,
                100% {
                    border-color: rgba(255, 255, 255, 0.15);
                    box-shadow: 0 0 0 0 currentColor;
                }

                50% {
                    border-color: currentColor;
                    box-shadow: 0 0 0 3px rgba(100, 200, 255, 0.3);
                }
            }
        }

        .slot-code.flash {
            animation: flashBorder 400ms ease-out;
        }

        @media (min-width: 1200px) {
            /* Removed grid layout - using flexbox column instead */
        }

        @media (min-width: 768px) and (max-width: 1199px) {
            /* Removed grid layout - using flexbox column instead */
        }

        /* Drag handle styling */
        .slot-drag-handle {
            cursor: grab;
            padding: 0.25rem;
            opacity: 0.4;
            transition: opacity 200ms ease;
            font-size: 1.2rem;
            user-select: none;
        }

        /* Lifetime badge shown on a slot to indicate remaining bars */
        .slot-lifetime-badge {
            font-size: 0.75rem;
            padding: 0.18rem 0.45rem;
            border-radius: 6px;
            background: rgba(255,255,255,0.12);
            color: inherit;
            border: 1px solid rgba(0,0,0,0.06);
            margin-left: 0.25rem;
            min-width: 42px;
            text-align: center;
            font-weight: 600;
        }
    .slot-lifetime-badge { display: flex; align-items: center; gap: 0.35rem; cursor: default; flex: 1 1 auto; min-width: 0; }
    .slot-lifetime-badge.paused { opacity: 0.85; background: rgba(0,0,0,0.06); }
    .slot-lifetime-text { display: inline-block; min-width: 36px; text-align: center; transition: transform 160ms ease; }
    .slot-lifetime-progress { flex: 1 1 auto; width: auto; height: 6px; background: rgba(0,0,0,0.06); border-radius: 3px; overflow: hidden; }
    /* Use the slot color (rgb) for the progress bar so it matches the card highlight */
    .slot-lifetime-progress-bar { height:100%; width:100%; background: rgba(var(--slot-color-rgb, 0,0,0), 0.18); transform-origin: left center; transition: width 200ms linear; }
        .slot-lifetime-pin { background: transparent; border: none; cursor: pointer; padding: 0; font-size: 0.95rem; opacity: 0.85; }
        .slot-lifetime-badge.pinned { background: rgba(255,255,255,0.06); box-shadow: inset 0 0 0 1px rgba(0,0,0,0.04); }

        .slot-drag-handle:hover {
            opacity: 0.8;
        }

        .slot-drag-handle:active {
            cursor: grabbing;
        }

        .slot.dragging {
            opacity: 0.5;
            transform: scale(1.05);
        }

        .slot.drag-over {
            border-top: 3px solid var(--slot-color);
        }
    </style>
</head>

<body>
    <div class="loading-screen" id="loading-screen">
        <div class="loading-content">
            <div class="loading-title">Strudel Mixer</div>
            <div class="loading-subtitle">Preparing your musical playground...</div>
            <div class="loading-dice" id="loading-dice">⚀</div>
            <div class="loading-progress" id="loading-progress">Initializing...</div>
        </div>
    </div>

    <header>
        <div class="header-main">
            <div class="add-slot-container" id="add-slot-container">
                <!-- Layer type buttons will be generated by JavaScript -->
            </div>
            <div class="header-controls">
                <div class="control-group">
                    <label class="control-label" for="master-volume">Volume:</label>
                    <input type="range" id="master-volume" class="control-slider" min="0" max="1" step="0.01"
                        value="0.7">
                </div>
                <div class="control-group">
                    <label class="control-label" for="master-reverb">Reverb:</label>
                    <input type="range" id="master-reverb" class="control-slider" min="0" max="1" step="0.05" value="0">
                </div>
                <div class="control-group">
                    <label class="control-label" for="creativity">Creativity:</label>
                    <input type="range" id="creativity" class="control-slider" min="0" max="1" step="0.01" value="0.2">
                </div>
                <div id="status" class="status">Preparing Strudel…</div>
            </div>
        </div>
    </header>

    <div class="slots-grid" id="slots-grid">
        <!-- Slots will be generated dynamically by JavaScript -->
    </div>

    <script type="module" src="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2"></script>
    <script src="https://unpkg.com/@strudel/web@1.0.3"></script>
    <script type="module">
        // Import Transformers.js
        import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2';

        // Disable local model loading
        env.allowLocalModels = false;

        (async () => {
            const statusEl = document.getElementById('status');
            const slotsGrid = document.getElementById('slots-grid');
            const addSlotContainer = document.getElementById('add-slot-container');
            const masterVolumeSlider = document.getElementById('master-volume');
            const masterReverbSlider = document.getElementById('master-reverb');
            const creativitySlider = document.getElementById('creativity');
            const loadingScreen = document.getElementById('loading-screen');
            const loadingProgress = document.getElementById('loading-progress');
            const loadingDice = document.getElementById('loading-dice');
            const slots = []; // Will hold slot data dynamically
            let slotIdCounter = 0; // Unique ID for each slot
            let masterVolume = 0.7;
            let masterReverb = 0;
            let creativity = 0.7; // 0 = deterministic, 1 = most creative/random

            // Dice animation for loading screen
            const diceFaces = ['⚀', '⚁', '⚂', '⚃', '⚄', '⚅'];
            let diceIndex = 0;
            let diceInterval = null;

            const startDiceAnimation = () => {
                if (diceInterval) return;
                diceInterval = setInterval(() => {
                    diceIndex = (diceIndex + 1) % diceFaces.length;
                    if (loadingDice) {
                        loadingDice.textContent = diceFaces[diceIndex];
                    }
                }, 200);
            };

            // Add occasional natural rhythmic "skips" to a pattern code so TTS isn't too repetitive
            const maybeApplyNaturalSkipToCode = (code) => {
                try {
                    // Probability to inject skips is influenced by creativity (more creative => more skips)
                    const baseProbability = 0.6;
                    const prob = Math.min(0.95, baseProbability + (creativity * 0.3));
                    if (Math.random() > prob) return code; // no change

                    // Find an existing .n("pattern") call and probabilistically insert rests (~) into the pattern
                    const nRegex = /\.n\(\s*([`'"])([^"`']+)\1\s*\)/;
                    const nMatch = nRegex.exec(code);
                    if (nMatch) {
                        const patternStr = nMatch[2];
                        const tokens = patternStr.split(/\s+/).filter(t => t.length > 0);
                        const skipChance = 0.35 + (creativity * 0.35); // higher creativity -> more skips
                        const newTokens = tokens.map(tok => {
                            // Leave obvious special tokens alone
                            if (tok.includes('~') || tok.includes('(') || tok.includes(')') || tok.includes('<') || tok.includes('>') || tok.includes('[') || tok.includes(']')) return tok;
                            // If token looks like a numeric note or a simple named sample/pitch token, maybe replace with a rest
                            if (/^[0-9a-zA-Z_]+$/.test(tok) && Math.random() < skipChance) return '~';
                            return tok;
                        });

                        const newPattern = newTokens.join(' ');
                        code = code.replace(nRegex, `.n("${newPattern}")`);
                    }

                    // Also check for `.struct("pattern")` and modify 'x' hits into rests probabilistically
                    const structRegex = /\.struct\(\s*([`'"])([^"`']+)\1\s*\)/;
                    const structMatch = structRegex.exec(code);
                    if (structMatch) {
                        const patternStr = structMatch[2];
                        const tokens = patternStr.split(/\s+/).filter(t => t.length > 0);
                        const skipChance = 0.25 + (creativity * 0.45);
                        const newTokens = tokens.map(tok => {
                            // Only consider plain 'x' tokens as hits to replace
                            if (tok === 'x' && Math.random() < skipChance) return '~';
                            return tok;
                        });
                        const newPattern = newTokens.join(' ');
                        return code.replace(structRegex, `.struct("${newPattern}")`);
                    }

                    // If there's no .n() in the code, append a simple pattern that incorporates rests
                    const candidatePatterns = ['.n("0 ~ 0 ~")', '.n("0 ~ ~ 0")', '.n("0 ~ ~ ~")', '.n("0 !4")', '.n("0 !8")'];
                    const chosen = candidatePatterns[Math.floor(Math.random() * candidatePatterns.length)];
                    return code + chosen;
                } catch (e) {
                    console.warn('Could not apply skip to pattern code:', e);
                    return code;
                }
            };

            const stopDiceAnimation = () => {
                if (diceInterval) {
                    clearInterval(diceInterval);
                    diceInterval = null;
                }
            };

            startDiceAnimation();

            // Function to animate dice rolling on a button - cycles through faces while busy
            const animateDiceRoll = (button, callback, animationType = 'rolling') => {
                const diceFaces = ['⚀', '⚁', '⚂', '⚃', '⚄', '⚅'];
                const spiceFaces = ['✦', '✧', '⚛', '※', '⁂', '❋'];

                const faces = animationType === 'spicing' ? spiceFaces : diceFaces;
                let faceIndex = 0;

                button.disabled = true;
                button.classList.add(animationType);

                // Cycle through faces in order, repeating continuously
                const rollInterval = setInterval(() => {
                    button.innerHTML = faces[faceIndex];
                    faceIndex = (faceIndex + 1) % faces.length; // Loop back to start
                }, 400); // Match the animation duration

                // Execute callback and stop animation when done
                if (callback) {
                    callback().finally(() => {
                        clearInterval(rollInterval);
                        // Pick a final random face to land on
                        const finalFace = faces[Math.floor(Math.random() * faces.length)];
                        button.innerHTML = finalFace;
                        button.classList.remove(animationType);
                        button.disabled = false;
                    });
                }
            };

            // Loading progress messages
            const updateLoadingProgress = (message) => {
                loadingProgress.textContent = message;
            };

            // Load the semantic similarity model (using efficient smaller model for fast loading)
            updateLoadingProgress('Loading AI model...');
            statusEl.textContent = 'Loading AI model...';
            let extractor = null;
            let patternEmbeddingsCache = null; // Cache for pre-computed pattern embeddings

            try {
                // Using all-MiniLM-L6-v2: efficient model (22M params) for fast loading and good semantic understanding
                // Much smaller than all-mpnet-base-v2 (420M) while maintaining strong performance
                extractor = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
                console.log('AI model loaded successfully');
                updateLoadingProgress('AI model ready ✓');
            } catch (e) {
                console.error('Failed to load AI model:', e);
                updateLoadingProgress('AI model failed (continuing without AI features)');
            }

            // TTS Web Worker - using module worker to avoid blocking the main thread
            let ttsWorker = null;
            let ttsWorkerReady = false;
            const ttsWorkerPromises = new Map();
            let ttsRequestId = 0;

            const initTTSWorker = async () => {
                if (ttsWorker) return ttsWorker;

                // Create a module worker that can use ES imports
                const workerCode = `
          import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2';
          
          // Disable local model loading
          env.allowLocalModels = false;
          
          let model = null;
          
          self.onmessage = async function(e) {
            const { id, type, text } = e.data;
            
            try {
              if (type === 'init') {
                console.log('[Worker] Loading TTS model...');
                model = await pipeline('text-to-speech', 'Xenova/speecht5_tts', { quantized: false });
                console.log('[Worker] TTS model loaded!');
                self.postMessage({ id, type: 'ready' });
              } else if (type === 'generate') {
                if (!model) {
                  throw new Error('Model not initialized');
                }
                
                console.log('[Worker] Generating speech for:', text);
                const result = await model(text, {
                  speaker_embeddings: 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/speaker_embeddings.bin'
                });
                
                console.log('[Worker] Speech generated!');
                self.postMessage({
                  id,
                  type: 'result',
                  audio: Array.from(result.audio),
                  sampling_rate: result.sampling_rate
                });
              }
            } catch (error) {
              console.error('[Worker] Error:', error);
              self.postMessage({
                id,
                type: 'error',
                message: error.message
              });
            }
          };
        `;

                // Create a blob URL with module type
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const workerUrl = URL.createObjectURL(blob);

                try {
                    // Create module worker
                    ttsWorker = new Worker(workerUrl, { type: 'module' });

                    ttsWorker.onmessage = (e) => {
                        const { id, type } = e.data;

                        if (type === 'ready') {
                            ttsWorkerReady = true;
                            console.log('TTS Worker ready!');
                            if (ttsWorkerPromises.has(id)) {
                                ttsWorkerPromises.get(id).resolve();
                                ttsWorkerPromises.delete(id);
                            }
                        } else if (type === 'result') {
                            if (ttsWorkerPromises.has(id)) {
                                ttsWorkerPromises.get(id).resolve(e.data);
                                ttsWorkerPromises.delete(id);
                            }
                        } else if (type === 'error') {
                            if (ttsWorkerPromises.has(id)) {
                                ttsWorkerPromises.get(id).reject(new Error(e.data.message));
                                ttsWorkerPromises.delete(id);
                            }
                        }
                    };

                    ttsWorker.onerror = (error) => {
                        console.error('TTS Worker error:', error);
                    };

                    // Initialize the worker (load model)
                    console.log('Initializing TTS worker...');
                    const initId = ttsRequestId++;
                    await new Promise((resolve, reject) => {
                        ttsWorkerPromises.set(initId, { resolve, reject });
                        ttsWorker.postMessage({ id: initId, type: 'init' });
                    });

                    return ttsWorker;
                } catch (e) {
                    console.error('Failed to create TTS worker:', e);
                    throw e;
                }
            };

            // Generate TTS using the worker
            const generateTTSAudio = async (text) => {
                if (!ttsWorker) {
                    await initTTSWorker();
                }

                const id = ttsRequestId++;
                const result = await new Promise((resolve, reject) => {
                    ttsWorkerPromises.set(id, { resolve, reject });
                    ttsWorker.postMessage({ id, type: 'generate', text });
                });

                return {
                    audio: result.audio,
                    sampling_rate: result.sampling_rate
                };
            };

            // Pre-generate some common TTS samples to avoid blocking during playback
            // This happens in the background after page load
            const preWarmTTS = async () => {
                try {
                    await new Promise(resolve => setTimeout(resolve, 3000)); // Wait 3s after load
                    console.log('Pre-generating TTS samples...');
                    const commonPhrases = [];
                    for (const phrase of commonPhrases) {
                        // Generate a prompt-specific sample name for each phrase to avoid clobbering
                        await generateTTSSample(phrase);
                        await new Promise(resolve => setTimeout(resolve, 500)); // Small delay between
                    }
                    console.log('TTS samples pre-generated and ready!');
                } catch (e) {
                    console.log('TTS pre-warming skipped:', e.message);
                }
            };

            // Define slot categories for complementary layering
            const slotCategories = [
                { name: 'kick', icon: '■', desc: 'Kick & Bass Drum', color: '#E63946' },
                { name: 'snare', icon: '●', desc: 'Snare & Clap', color: '#EF476F' },
                { name: 'hihat', icon: '≡', desc: 'Hi-hats & Cymbals', color: '#F77F00' },
                { name: 'perc', icon: '◐', desc: 'Percussion & Accents', color: '#F4A261' },
                { name: 'bass', icon: '▬', desc: 'Bass & Low End', color: '#457B9D' },
                { name: 'melody', icon: '◇', desc: 'Melodic Elements', color: '#A8DADC' },
                { name: 'chords', icon: '♬', desc: 'Chords & Harmony', color: '#F4A261' },
                { name: 'texture', icon: '○', desc: 'Texture & FX', color: '#2A9D8F' },
                { name: 'arp', icon: '✦', desc: 'Arpeggiator', color: '#FF69B4' },
                { name: 'tts', icon: '◼', desc: 'Speech', color: '#E9C46A' }
            ];

            // Pattern library with natural language descriptions focused on feelings, moods, and vibes
            const patternLibrary = {
                // Separated drum component categories for modern electronic music
                kick: [
                    { desc: "classic four-on-floor house kick", code: 's("bd*4").gain(0.95).lpf(600).room(0.05)', literal: "four on the floor house kick", tempo: "fast", density: "high", energy: "high", mood: "dance" },
                    { desc: "808 sub kick with occasional pitched follow-ups", code: 's("808bd").n("0 ~ 0 ~").speed("<1 0.85>").lpf(250).gain(0.95)', literal: "pitched 808 sub-kick alternating", tempo: "medium", density: "medium", energy: "high", mood: "club" },
                    { desc: "3/8 euclidean kick for tech-house groove and push", code: 's("bd(3,8)").gain(0.9).lpf(600).distort(0.03)', literal: "3/8 euclidean kick for syncopation", tempo: "medium", density: "medium", energy: "high", mood: "groovy" },
                    { desc: "minimal steady pulse kick — subtle variations and sidechain-ready", code: 's("bd").n("0!4").gain(0.85).lpf(350)', literal: "steady minimal kick pulse", tempo: "medium", density: "steady", energy: "medium", mood: "hypnotic" },
                    { desc: "2-step / garage kick with swing and gated gaps", code: 's("bd ~ bd ~").early("<0 0.06>*4").gain(0.9).lpf(400)', literal: "2-step garage kick with slight swing", tempo: "medium", density: "medium", energy: "medium", mood: "skippy" },
                    { desc: "heavy reverb'd vintage kick for space and lift", code: 's("reverbkick").gain(0.9).room(0.6).lpf(800)', literal: "reverb-heavy vintage kick", tempo: "medium", density: "low", energy: "medium", mood: "lofty" },
                    { desc: "punched acoustic stomp kick for organic thump", code: 's("stomp").n("0 ~").gain(0.95).hpf(40).room(0.08)', literal: "stomped acoustic kick", tempo: "medium", density: "low", energy: "high", mood: "earthy" },
                    { desc: "hard-hitting distorted kick for hardcore/industrial", code: 's("hardkick").gain(1).distort(0.35).lpf(500)', literal: "distorted hard kick", tempo: "fast", density: "high", energy: "very high", mood: "aggressive" },
                    { desc: "subby trap kick with pitched rolls and tail control", code: 's("808bd").n("0 ~ [0 1] ~").speed("<1 0.9>").lpf(220).gain(0.95).room(0.06)', literal: "pitched trap-style 808 hits", tempo: "medium", density: "medium", energy: "high", mood: "trap" },
                    { desc: "lo-fi punch kick with vinyl crackle and soft high-cut", code: 's("future").gain(0.8).lpf(1200).room(0.12).degradeBy(0.12)', literal: "lo-fi filtered kick with texture", tempo: "medium", density: "medium", energy: "medium", mood: "nostalgic" }
                ],
                snare: [
                    { desc: "backbeat clap/snare on 2 and 4 with short room", code: 's("realclaps").struct("~ x ~ x").gain(0.95).room(0.12)', literal: "backbeat claps/snares on 2 & 4", tempo: "fast", density: "medium", energy: "high", mood: "dance" },
                    { desc: "tight hip-hop snare with short decay and punch", code: 's("sd").gain(0.96).lpf(2400).room(0.04)', literal: "tight hip-hop snare", tempo: "medium", density: "medium", energy: "high", mood: "punchy" },
                    { desc: "half-time trap snare with long tail and subtle distortion", code: 's("sd").slow(2).struct("~ x ~ x").gain(0.9).distort(0.06).room(0.28)', literal: "half-time trap snare with reverb tail", tempo: "slow", density: "low", energy: "medium", mood: "moody" },
                    { desc: "ghost-note snare sequence for groove and shuffle", code: 's("sn").struct("~ x(3,8) ~ x").degradeBy(0.12).gain(0.7).room(0.08)', literal: "ghost-note snare groove", tempo: "medium", density: "medium", energy: "low", mood: "groovy" },
                    { desc: "clap roll / snare flurry with subtle stutter", code: 's("realclaps!8").sometimes(x=>x.fast(2)).gain(0.9).room(0.3)', literal: "8th clap rolls with stutter", tempo: "fast", density: "high", energy: "high", mood: "excited" },
                    { desc: "snappy rim/snare hybrid for percussive thrust", code: 's("rm").gain(0.9).hpf(1200).room(0.05)', literal: "rimshot/snare hybrid", tempo: "fast", density: "medium", energy: "high", mood: "sharp" },
                    { desc: "lo-fi snap/snare with tape wobble and warmth", code: 's("sn").gain(0.7).degradeBy(0.18).lpf(2000).room(0.18)', literal: "tape-warm snap", tempo: "medium", density: "medium", energy: "low", mood: "warm" },
                    { desc: "electronic gated snare with tight attack and early", code: 's("sn").struct("x ~ x ~").gain(0.95).hpf(300).lpf(6000).early("<0 0.02>")', literal: "gated electronic snare", tempo: "fast", density: "medium", energy: "high", mood: "forward" },
                    { desc: "big trance clap/snare stack for lifts and drops", code: 's("realclaps").n("0").gain(0.95).room(0.6).lpf(3000)', literal: "big stacked clap for build", tempo: "fast", density: "low", energy: "very high", mood: "epic" },
                    { desc: "broken beat snare pattern with swung accents and echoes", code: 's("sd").struct("~ x ~ x(3,8)").delay(0.125).gain(0.85).room(0.2)', literal: "swung broken-beat snare", tempo: "medium", density: "medium", energy: "medium", mood: "skitter" }
                ],
                hihat: [
                    { desc: "steady 16th closed hats for driving energy", code: 's("hh*16").gain(0.78).hcutoff(9000)', literal: "steady sixteenth hi-hats", tempo: "fast", density: "high", energy: "high", mood: "driving" },
                    { desc: "open hat on the off-beat for roomy groove", code: 's("house").struct("~ oh ~ oh").gain(0.66).room(0.18)', literal: "open hats on off beats", tempo: "fast", density: "medium", energy: "medium", mood: "groovy" },
                    { desc: "16th-triplet hat rolls and fills for trap-style intensity", code: 's("hh!16").sometimes(x=>x.fast(2)).gain(0.85).hcutoff(11000)', literal: "triplet hat rolls", tempo: "medium", density: "very high", energy: "high", mood: "aggressive" },
                    { desc: "shuffled swing hats for two-step and garage", code: 's("hh").struct("x(3,8)").early("<0 0.08 -0.04>").gain(0.72)', literal: "shuffled swing hats", tempo: "medium", density: "medium", energy: "medium", mood: "swing" },
                    { desc: "bright open hat loop with perlin pan for texture", code: 's("hh").n("0 0 0 0").pan(perlin.range(0.2,0.8)).hpf(400).gain(0.6)', literal: "perlin-panned open hats", tempo: "fast", density: "medium", energy: "medium", mood: "textured" },
                    { desc: "crisp vintage Linn-style hats with slight timing jitter", code: 's("linnhats").struct("x x x x").early("<-0.01 0 0.01>").gain(0.82)', literal: "linn-style tight hats", tempo: "fast", density: "high", energy: "high", mood: "retro" },
                    { desc: "soft brush hats and airy top-end for chilled grooves", code: 's("gretsch").gain(0.5).hcutoff(8000).room(0.2)', literal: "brush hats top layer", tempo: "medium", density: "low", energy: "low", mood: "laidback" },
                    { desc: "textured gated hats with stuttered micro-rolls", code: 's("hh").sometimes(x=>x.chop(8)).gain(0.88).hcutoff(10000)', literal: "gated chopped hats", tempo: "fast", density: "high", energy: "high", mood: "electric" },
                    { desc: "sparse, swung hi-hat for downtempo head-nod", code: 's("hh").struct("x ~ ~ x").gain(0.55).hpf(300)', literal: "sparse swung hats", tempo: "slow", density: "low", energy: "low", mood: "mellow" },
                    { desc: "metallic top hats and percussive textures for industrial feel", code: 's("metal").struct("x(5,16)").gain(0.7).distort(0.08).hcutoff(9000)', literal: "metallic textured hats", tempo: "medium", density: "high", energy: "high", mood: "industrial" }
                ],
                perc: [
                    { desc: "shaker pulse for house pocket", code: 's("perc").struct("x(11,16)").gain(0.4).hpf(4500).room(0.1)', literal: "shakers for house groove", tempo: "fast", density: "medium", energy: "medium", mood: "bouncy" },
                    { desc: "metallic techno percs with edge and grit", code: 's("metal").struct("x(5,16)").gain(0.6).distort(0.15).room(0.15)', literal: "metallic percussive percussion", tempo: "medium", density: "high", energy: "high", mood: "driving" },
                    { desc: "short ride/tribal accents for trance builds", code: 's("foo").struct("x(7,16)").gain(0.45).delay(0.125).room(0.25)', literal: "trance ride accents", tempo: "fast", density: "medium", energy: "high", mood: "uplifting" },
                    { desc: "rimshot and conga hybrids for UKG flavor", code: 's("tabla").struct("~ ~ x ~").early("<0 0.06>*4").gain(0.5).hpf(1200)', literal: "rim/conga hybrid fills", tempo: "medium", density: "medium", energy: "medium", mood: "skippy" },
                    { desc: "glitchy chopped percs for transitions", code: 's("perc").chop(8).sometimes(x=>x.rev()).gain(0.6).distort(0.2)', literal: "glitch percussive fills", tempo: "variable", density: "medium", energy: "medium", mood: "edgy" },
                    { desc: "tuned tom/ethnic hits layered for world percussion", code: 's("world").struct("x ~ x(3,8)").gain(0.6).room(0.18)', literal: "world percussion layer", tempo: "medium", density: "medium", energy: "medium", mood: "organic" },
                    { desc: "subtle top-end clicks to add presence without clutter", code: 's("oc").gain(0.25).hpf(4000).sometimes(x=>x.fast(2))', literal: "subtle clicks and top percussion", tempo: "fast", density: "low", energy: "low", mood: "transparent" },
                    { desc: "deep conga-like pulse with swing for groove", code: 's("future").struct("x(5,8)").gain(0.55).delay(0.08).room(0.15)', literal: "deep conga pulse", tempo: "medium", density: "medium", energy: "medium", mood: "groovy" },
                    { desc: "lo-fi percussive bed with vinyl crackle for texture", code: 's("pebbles").gain(0.28).degradeBy(0.2).room(0.2)', literal: "textural low-fi percs", tempo: "medium", density: "low", energy: "low", mood: "nostalgic" },
                    { desc: "high-frequency shimmers and reversed clicks for fills", code: 's("feelfx").sometimes(x=>x.rev()).gain(0.35).delay(0.12)', literal: "shimmering fills and reversed percs", tempo: "variable", density: "low", energy: "low", mood: "ethereal" }
                ],
                // 'drums' legacy removed: use kick/snare/hihat/perc categories instead
                bass: [
                    { desc: "filtered pulsing house low-end — wide but controlled", code: 's("bass").n("0!4").lpf(sine.range(200,800).slow(8)).lpq(5).gain(0.8).room(0.2)', literal: "4/4 pulsing filtered house bass", genre: "house", register: "mid-bass", movement: "pulsing", timbre: "warm", rhythm: "steady" },
                    { desc: "minimal techno sub pulse with grit", code: 's("jungbass").n("0!8").lpf(350).gain(0.86).distort(0.08)', literal: "techno sub pulse with subtle distortion", genre: "techno", register: "sub", movement: "pulsing", timbre: "deep", rhythm: "repetitive" },
                    { desc: "rolling trance bass with modulation and glide", code: 's("jungbass").n("<0 7 9>").fast(2).lpf(900).lpq(8).gain(0.7)', literal: "melodic rolling saw bass common in trance", genre: "trance", register: "mid-bass", movement: "rolling", timbre: "sweeping", rhythm: "flowing" },
                    { desc: "syncopated UKG sub wobble with early micro-shifts", code: 's("bass").n("<0 ~ 2 ~>").early("<0 0.06>*4").lpf(300).gain(0.85)', literal: "syncopated sub wobble typical of UK Garage", genre: "ukg", register: "sub", movement: "wobbling", timbre: "warm", rhythm: "syncopated" },
                    { desc: "pitched 808 melodic sub pattern with tight decay", code: 's("808bd").n("0 ~ [0 1] ~").speed("<1 0.85>").lpf(250).gain(0.95)', literal: "pitched 808 sub pattern used in trap", genre: "trap", register: "sub", movement: "thumping", timbre: "clean", rhythm: "syncopated" },
                    { desc: "rounded electric bass with slap accents for funk/house", code: 's("jvbass").n("<0 2 4>").clip(2).gain(0.8).lpq(6)', literal: "electric rounded bass stabs", genre: "funk", register: "mid-bass", movement: "pulsing", timbre: "round", rhythm: "syncopated" },
                    { desc: "sub growl wobble — perlin modulated low-end for dub/garage", code: 's("jungbass").n("0").lpf(perlin.range(80,400)).gain(0.9).distort(0.06)', literal: "perlin-wobble sub bass", genre: "dub", register: "sub", movement: "wobbling", timbre: "growly", rhythm: "sparse" },
                    { desc: "acid-y resonant bassline with modulation and grit", code: 's("jvbass").n("<0 3 5>").lpq(10).gain(0.85).distort(0.12)', literal: "resonant acid bass", genre: "acid", register: "mid-bass", movement: "squelchy", timbre: "resonant", rhythm: "steady" },
                    { desc: "sub-only drone for ambient passages and weight", code: 's("subroc3d").n("0").slow(8).gain(0.65).lpf(200)', literal: "sustained sub drone", genre: "ambient", register: "sub", movement: "sustained", timbre: "deep", rhythm: "static" },
                    { desc: "pulsing reese-style layered bass for heavy drops", code: 's("bass").n("0 0 5 0").lpq(4).distort(0.18).gain(0.95)', literal: "layered reese bass pulse", genre: "drum & bass", register: "mid-bass", movement: "pulsing", timbre: "thick", rhythm: "driving" }
                ],
                melody: [
                    { desc: "bright arpeggiated synth arps for dancefloor motifs", code: 's("arpy").n("<0 2 4 7>*2").speed(2).lpf(2000).delay(0.125).gain(0.45)', literal: "house arpeggio doubled across octaves", genre: "house", range: "mid-high", contour: "ascending", texture: "bright", articulation: "staccato" },
                    { desc: "short repetitive stab motif for techno heads", code: 's("stab").n("<0 0 0 5>").lpf(800).gain(0.5)', literal: "minimal repeating techno motif", genre: "techno", range: "mid", contour: "repetitive", texture: "sharp", articulation: "staccato" },
                    { desc: "wide saw lead with delay and lush reverb for trance", code: 's("juno").n("<0 5 9 12>").slow(1).lpf(2000).gain(0.5).delay(0.2).room(0.4)', literal: "trance-style wide lead", genre: "trance", range: "high", contour: "melodic", texture: "sustained", articulation: "legato" },
                    { desc: "syncopated organ/key stabs with gate for UKG", code: 's("juno").n("<0 3 5 7>").struct("x ~ x(3,8)").lpf(900).gain(0.45)', literal: "UKG organ stabs and motifs", genre: "ukg", range: "mid", contour: "arch", texture: "percussive", articulation: "detached" },
                    { desc: "chopped vocal/lead with swing and pitch variation typical of trap", code: 's("mouth").n("<0 4 7 12>").chop(8).gain(0.4).delay(0.15).room(0.35)', literal: "vocal-chop melodic lead", genre: "trap", range: "mid-high", contour: "rhythmic", texture: "chopped", articulation: "stutter" },
                    { desc: "plucked arpeggio doubled across octaves for melodic motion", code: 's("pluck").n("<0 4 7>").clip(2).gain(0.5).delay(0.08)', literal: "plucked arpeggio", genre: "melodic", range: "mid", contour: "arcing", texture: "plucky", articulation: "staccato" },
                    { desc: "gliding lead with portamento for emotional lines", code: 's("moog").n("<0 2 4>").speed(0.9).lpf(1500).gain(0.6).lpq(6)', literal: "gliding portamento lead", genre: "synthpop", range: "mid-high", contour: "gliding", texture: "warm", articulation: "legato" },
                    { desc: "short, echoed bell motifs for top-end sparkle", code: 's("pad").n("<0 7>").delay(0.18).gain(0.35).room(0.5).lpf(3000)', literal: "bell-like echoed motifs", genre: "ambient", range: "high", contour: "plucked", texture: "shimmery", articulation: "sustained" },
                    { desc: "minimal piano/keys motif for emotional anchors", code: 's("notes").n("<0 3 7>").struct("x ~").lpf(1200).gain(0.45)', literal: "minimal key motif", genre: "minimal", range: "mid", contour: "simple", texture: "acoustic-like", articulation: "detached" },
                    { desc: "chopped arpeggio with rhythmic displacement for unpredictability", code: 's("pluck").n("<0 2 4 7>").chop(16).sometimes(x=>x.rev()).gain(0.4)', literal: "chopped rhythmic arpeggio", genre: "experimental", range: "mid", contour: "fragmented", texture: "chopped", articulation: "stutter" }
                ],
                chords: [
                    { desc: "punchy filtered triads and stabs for house", code: 's("stab").n("<0 5 10>").struct("x ~ x ~").lpf(900).gain(0.45).room(0.3)', literal: "short house chord stabs", genre: "house", voicing: "compact", quality: "major", density: "sparse", rhythm: "steady" },
                    { desc: "dark evolving pad bed for techno backdrops", code: 's("pad").n("<0 1>").slow(8).lpf(300).gain(0.4).room(0.5)', literal: "dark evolving pad", genre: "techno", voicing: "wide", quality: "minor", density: "sustained", rhythm: "slow" },
                    { desc: "lush trance pad stack with big motion", code: 's("pad").n("<0 4 7>").slow(4).lpf(1200).gain(0.5).room(0.6)', literal: "trance pad stack", genre: "trance", voicing: "wide", quality: "maj", density: "sustained", rhythm: "slow" },
                    { desc: "staccato organ stabs for UKG and garage rhythms", code: 's("juno").n("<0 2 4>").struct("x ~ x(3,8)").lpf(1500).gain(0.45)', literal: "UKG organ stabs", genre: "ukg", voicing: "compact", quality: "major", density: "rhythmic", rhythm: "syncopated" },
                    { desc: "sparse ambient chords and pads for cinematic space", code: 's("padlong").n("<0 3 7>").slow(12).gain(0.3).room(0.8).lpf(1500)', literal: "ambient cinematic pads", genre: "ambient", voicing: "open", quality: "ambiguous", density: "sustained", rhythm: "slow" },
                    { desc: "bright stabs with high-cut and short decay for dance", code: 's("stab").n("<0 4 7>").lpf(2500).gain(0.5).room(0.2)', literal: "bright dance chord stabs", genre: "dance", voicing: "closed", quality: "major", density: "sparse", rhythm: "steady" },
                    { desc: "warm Rhodes-like chord bed for soulful sections", code: 's("juno").n("<0 7 10>").gain(0.45).lpf(1800).room(0.25)', literal: "Rhodes-like warm chords", genre: "soul", voicing: "spread", quality: "maj7", density: "sustained", rhythm: "slow" },
                    { desc: "suspended ambient drones with evolving filters", code: 's("pad").n("<0>").slow(6).lpf(perlin.range(500,2000)).gain(0.35).room(0.6)', literal: "elastic suspended drones", genre: "ambient", voicing: "wide", quality: "suspended", density: "sustained", rhythm: "slow" },
                    { desc: "half-time sparse stabs for trap/pop hybrid", code: 's("pad").n("<0 1>").slow(2).lpf(1200).gain(0.38).room(0.35)', literal: "sparse half-time stabs", genre: "trap", voicing: "compact", quality: "minor", density: "sparse", rhythm: "slow" },
                    { desc: "filtered chord pulses synced to bass motion for tension", code: 's("stab").n("<0 3 7>").struct("x ~ x").lpf(900).gain(0.48).delay(0.06)', literal: "pulsing filtered chord motion", genre: "progressive", voicing: "tight", quality: "maj/min", density: "medium", rhythm: "syncopated" }
                ],
                texture: [
                    { desc: "subtle shaker + vinyl crackle layer for warmth", code: 's("perc").struct("x(11,16)").gain(0.18).hpf(4500).room(0.15)', literal: "subtle shaker pulse and vinyl crackle", genre: "house", frequency: "mid", density: "medium", character: "groovy", placement: "background" },
                    { desc: "industrial metallic hits and gated noise for edge", code: 's("metal").struct("x(5,16)").gain(0.5).distort(0.12).hpf(300).room(0.25)', literal: "industrial metallic texture", genre: "techno", frequency: "mid-high", density: "high", character: "metallic", placement: "foreground" },
                    { desc: "lush shimmer pads and evolving FX for lifts", code: 's("pad").n("<0 4 7>").slow(8).lpf(1200).gain(0.22).room(0.8)', literal: "shimmering pads and spectral motion", genre: "trance", frequency: "variable", density: "sustained", character: "lush", placement: "background" },
                    { desc: "top-end skitter with perlin-panned hats and micro-percs", code: 's("hh(7,16)").n(irand(3)).gain(0.22).hcutoff(8000).pan(perlin.range(0.3,0.7))', literal: "skittering hats and micro-percs", genre: "ukg", frequency: "very high", density: "medium", character: "skittering", placement: "top layer" },
                    { desc: "dark atmos, reverb tails and vocal grains for depth", code: 's("noise2").n("0").slow(8).gain(0.12).lpf(1200).room(0.35).sometimes(x=>s("mouth").chop(16).gain(0.08))', literal: "dark atmos and vocal grains", genre: "trap/ambient", frequency: "low-mid", density: "sparse", character: "atmospheric", placement: "background" },
                    { desc: "top-end sparkle and light percussive flourishes", code: 's("feelfx").sometimes(x=>x.fast(2)).gain(0.25).hcutoff(10000).pan(perlin.range(0,1))', literal: "sparkle FX and flourishes", genre: "electronic", frequency: "high", density: "low", character: "sparkly", placement: "accent" },
                    { desc: "field recordings and outdoor ambiences for realism", code: 's("outdoor").gain(0.28).lpf(2500).room(0.4)', literal: "outdoor ambient field layer", genre: "organic", frequency: "variable", density: "sustained", character: "recorded", placement: "background" },
                    { desc: "soft mechanical clicks and micro-impulses for rhythm glue", code: 's("oc").gain(0.18).hpf(5000).sometimes(x=>x.chop(8))', literal: "mechanical clicks for glue", genre: "minimal", frequency: "very high", density: "low", character: "clicky", placement: "top" },
                    { desc: "low sub rumbles and distant booms for weight", code: 's("subroc3d").n("0").gain(0.18).slow(12).lpf(180).room(0.35)', literal: "sub rumbles for weight", genre: "ambient", frequency: "sub", density: "sparse", character: "rumbling", placement: "background" },
                    { desc: "percussive metallic textures with rhythmic gating", code: 's("glitch").struct("x(5,16)").gain(0.4).distort(0.15).delay(0.06)', literal: "percussive metallic gated textures", genre: "glitch", frequency: "mid-high", density: "medium", character: "metallic", placement: "foreground" }
                ],
                arp: [
                    { desc: "simple chord arpeggio using plucked notes for clarity", code: 'note("c eb g c4").clip(2).s("pluck")', literal: "simple chord arpeggio", tempo: "medium", density: "medium", energy: "low", mood: "melodic" },
                    { desc: "scale-based arpeggio with rhythmic variation and bounce", code: 'n("0 2 4 7").scale("C:minor").clip(2).s("pluck")', literal: "scale-based arpeggio", tempo: "medium", density: "medium", energy: "medium", mood: "uplifting" },
                    { desc: "chord-symbol arpeggio with voiced voicings for harmonic richness", code: 'n("0 1 2 3").chord("Cm").mode("above:c3").voicing().clip(2).s("pluck")', literal: "chord symbol arpeggio", tempo: "medium", density: "medium", energy: "medium", mood: "harmonic" },
                    { desc: "off-beat arpeggio with polyrhythmic displacements", code: 'n("0").off(1/3, add(2)).off(1/2, add(4)).scale("C:minor").s("pluck")', literal: "off-beat arpeggio", tempo: "medium", density: "medium", energy: "medium", mood: "groovy" },
                    { desc: "fast glittering arpeggio for buildups and tension", code: 'n("0 2 4 7").fast(2).clip(1).s("pluck")', literal: "fast glitter arpeggio", tempo: "fast", density: "high", energy: "high", mood: "tense" },
                    { desc: "broken arpeggio that alternates octaves for movement", code: 'n("<0 7>").clip(2).voicing().s("pluck").sometimes(x=>x.rev())', literal: "alternating octave arpeggio", tempo: "medium", density: "medium", energy: "medium", mood: "flowing" },
                    { desc: "sparse ambient arpeggio with slow envelopes and reverb", code: 'n("0").slow(4).s("pad").gain(0.28).room(0.6)', literal: "ambient slow arpeggio", tempo: "slow", density: "low", energy: "low", mood: "ethereal" },
                    { desc: "syncopated arpeggio with swing and micro-timing shifts", code: 'n("0 3 5").struct("x ~ x(3,8)").off(0.06).s("pluck")', literal: "syncopated swung arpeggio", tempo: "medium", density: "medium", energy: "medium", mood: "skippy" },
                    { desc: "motoric repeating arpeggio for trance/techno drive", code: 'n("0!8").fast(1.5).s("pluck").lpf(1200)', literal: "motoric repeating arpeggio", tempo: "fast", density: "high", energy: "high", mood: "driving" },
                    { desc: "granular arpeggio with chopped grains for experimental textures", code: 'n("0 2 4").chop(16).sometimes(x=>x.rev()).s("pluck").gain(0.35)', literal: "granular chopped arpeggio", tempo: "variable", density: "high", energy: "medium", mood: "experimental" }
                ],
                // tts legacy patterns intentionally omitted; TTS is handled by dedicated slot type
            };

            let hasDirtSamples = false;
            let sampleStatusSuffix = '';
            let ttsAudioBuffers = {};  // Store generated TTS audio buffers by text
            const getSchedulerApi = () => window.strudel ?? null;
            let schedulerApi = null;

            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
            const getNow = () => (typeof performance !== 'undefined' && typeof performance.now === 'function'
                ? performance.now()
                : Date.now());

            // Helper function to compute cosine similarity between two embeddings
            const cosineSimilarity = (a, b) => {
                let dotProduct = 0;
                let normA = 0;
                let normB = 0;
                for (let i = 0; i < a.length; i++) {
                    dotProduct += a[i] * b[i];
                    normA += a[i] * a[i];
                    normB += b[i] * b[i];
                }
                return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
            };

            // Pre-compute embeddings for all patterns (one-time operation)
            // Each comma-separated element in pattern.desc gets its own embedding
            const precomputePatternEmbeddings = async () => {
                if (!extractor) return null;

                // Generate a cache key based on the pattern library structure
                const cacheKey = 'strudel_pattern_embeddings_v1';
                const libraryHashKey = 'strudel_pattern_library_hash_v1';

                // Create a simple hash of the pattern library to detect changes
                const libraryHash = JSON.stringify(Object.keys(patternLibrary).sort() +
                    Object.values(patternLibrary).map(p => p.length).join(','));

                try {
                    // Check if we have cached embeddings
                    const cachedEmbeddings = localStorage.getItem(cacheKey);
                    const cachedHash = localStorage.getItem(libraryHashKey);

                    if (cachedEmbeddings && cachedHash === libraryHash) {
                        console.log('✅ Loading cached pattern embeddings from browser storage');
                        updateLoadingProgress('Loading cached embeddings...');
                        const cache = JSON.parse(cachedEmbeddings);
                        console.log(`Loaded ${cache.length} cached pattern embeddings`);
                        return cache;
                    }
                } catch (e) {
                    console.warn('Could not load cached embeddings:', e);
                }

                updateLoadingProgress('Analyzing pattern library...');
                statusEl.textContent = 'Pre-computing pattern embeddings...';
                const cache = [];

                let processedCount = 0;
                let totalDescriptions = 0;

                // Count total descriptions (each comma-separated element)
                for (const patterns of Object.values(patternLibrary)) {
                    for (const pattern of patterns) {
                        const descriptions = pattern.desc.split(',').map(d => d.trim()).filter(d => d.length > 0);
                        totalDescriptions += descriptions.length;
                    }
                }

                for (const [category, patterns] of Object.entries(patternLibrary)) {
                    for (const pattern of patterns) {
                        // Split description by commas - each becomes a separate embedding
                        const descriptions = pattern.desc.split(',').map(d => d.trim()).filter(d => d.length > 0);

                        // Build literal metadata text based on category
                        let literalText = pattern.literal || '';

                        // Add category-specific metadata to embedding text
                        if ((category === 'kick' || category === 'snare' || category === 'hihat' || category === 'perc') && pattern.tempo && pattern.density && pattern.energy && pattern.mood) {
                            literalText += ` tempo: ${pattern.tempo}, density: ${pattern.density}, energy: ${pattern.energy}, mood: ${pattern.mood}`;
                        } else if (category === 'bass' && pattern.register && pattern.movement && pattern.timbre && pattern.rhythm) {
                            literalText += ` register: ${pattern.register}, movement: ${pattern.movement}, timbre: ${pattern.timbre}, rhythm: ${pattern.rhythm}`;
                        } else if (category === 'melody' && pattern.range && pattern.contour && pattern.texture && pattern.articulation) {
                            literalText += ` range: ${pattern.range}, contour: ${pattern.contour}, texture: ${pattern.texture}, articulation: ${pattern.articulation}`;
                        } else if (category === 'chords' && pattern.voicing && pattern.quality && pattern.density && pattern.rhythm) {
                            literalText += ` voicing: ${pattern.voicing}, quality: ${pattern.quality}, density: ${pattern.density}, rhythm: ${pattern.rhythm}`;
                        } else if (category === 'texture' && pattern.frequency && pattern.density && pattern.character && pattern.placement) {
                            literalText += ` frequency: ${pattern.frequency}, density: ${pattern.density}, character: ${pattern.character}, placement: ${pattern.placement}`;
                        }

                        for (const desc of descriptions) {
                            // Combine description with literal metadata for embedding
                            const embeddingText = literalText ? `${desc}, ${literalText}` : desc;
                            const embedding = await extractor(embeddingText, { pooling: 'mean', normalize: true });
                            cache.push({
                                code: pattern.code,
                                desc: desc, // Individual description phrase
                                fullDesc: pattern.desc, // Keep full description for reference
                                literal: pattern.literal || '', // Include literal description
                                category,
                                embedding: Array.from(embedding.data)
                            });
                            processedCount++;

                            // Update progress and yield to event loop every 5 embeddings
                            if (processedCount % 5 === 0 || processedCount === totalDescriptions) {
                                updateLoadingProgress(`Analyzing patterns... ${processedCount}/${totalDescriptions}`);
                                await new Promise(resolve => setTimeout(resolve, 0)); // Yield to event loop
                            }
                        }
                    }
                }

                // Cache the embeddings in localStorage
                try {
                    localStorage.setItem(cacheKey, JSON.stringify(cache));
                    localStorage.setItem(libraryHashKey, libraryHash);
                    console.log(`✅ Cached ${cache.length} pattern embeddings to browser storage`);
                } catch (e) {
                    console.warn('Could not cache embeddings to localStorage:', e);
                }

                console.log(`Pre-computed ${cache.length} pattern embeddings from ${totalDescriptions} descriptions`);
                return cache;
            };

            // IndexedDB helper for TTS caching
            const openTTSCache = () => {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('StrudelTTSCache', 1);

                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('tts')) {
                            db.createObjectStore('tts', { keyPath: 'text' });
                        }
                    };
                });
            };

            const getCachedTTS = async (text) => {
                try {
                    const db = await openTTSCache();
                    return new Promise((resolve, reject) => {
                        const transaction = db.transaction(['tts'], 'readonly');
                        const store = transaction.objectStore('tts');
                        const request = store.get(text);

                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                } catch (e) {
                    console.warn('Could not access TTS cache:', e);
                    return null;
                }
            };

            const saveTTSToCache = async (text, audioData, samplingRate) => {
                try {
                    const db = await openTTSCache();
                    return new Promise((resolve, reject) => {
                        const transaction = db.transaction(['tts'], 'readwrite');
                        const store = transaction.objectStore('tts');
                        const request = store.put({
                            text: text,
                            audio: Array.from(audioData), // Convert Float32Array to regular array for storage
                            sampling_rate: samplingRate,
                            timestamp: Date.now()
                        });

                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                } catch (e) {
                    console.warn('Could not save TTS to cache:', e);
                }
            };

            // Generate TTS audio and register it as a Strudel sample
            // Deterministic, URL-safe sample name derived from the TTS prompt
            const sampleNameForPrompt = (prompt) => {
                if (!prompt) return `tts_${Date.now()}`;
                try {
                    // Encode Unicode safely, base64 it, make it URL-safe and truncate
                    const b64 = btoa(unescape(encodeURIComponent(prompt)));
                    const urlSafe = b64.replace(/=+$/, '').replace(/\+/g, '-').replace(/\//g, '_');
                    return `tts_${urlSafe.slice(0, 20)}`;
                } catch (e) {
                    // Fallback deterministic-ish hash
                    const hash = Math.abs(Array.from(prompt).reduce((h, c) => ((h << 5) - h) + c.charCodeAt(0), 0));
                    return `tts_${hash.toString(36)}`;
                }
            };

            // Map prompt -> registered sample name for quick reuse
            const ttsSampleNameByPrompt = {};

            // Generate TTS audio and register it as a Strudel sample (returns sampleName)
            const generateTTSSample = async (text, providedSampleName = null) => {
                if (!text || !text.trim()) throw new Error('Empty TTS text');

                const sampleName = providedSampleName || sampleNameForPrompt(text);

                // If we've previously registered this prompt under a name, reuse it
                if (ttsSampleNameByPrompt[text]) {
                    // If the mapped name differs from sampleName, prefer mapped name (reused)
                    if (ttsSampleNameByPrompt[text] !== sampleName) {
                        console.log('Reusing existing sample name for prompt:', ttsSampleNameByPrompt[text]);
                        return ttsSampleNameByPrompt[text];
                    }
                    // otherwise fall through and return sampleName after confirming registration
                }

                // In-memory cache check
                if (ttsAudioBuffers[text]) {
                    console.log('✅ Using in-memory cached TTS audio for:', text);
                    ttsSampleNameByPrompt[text] = sampleName;
                    return sampleName;
                }

                // Check IndexedDB cache
                const cached = await getCachedTTS(text);
                if (cached) {
                    console.log('✅ Using cached TTS audio from storage for:', text);
                    try {
                        // Restore to memory cache
                        ttsAudioBuffers[text] = {
                            audio: new Float32Array(cached.audio),
                            sampling_rate: cached.sampling_rate
                        };

                        // Build AudioBuffer and register under sampleName
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const audioBuffer = audioContext.createBuffer(
                            1,
                            cached.audio.length,
                            cached.sampling_rate
                        );
                        audioBuffer.getChannelData(0).set(new Float32Array(cached.audio));

                        const wavData = audioBufferToWav(audioBuffer);
                        const base64 = btoa(String.fromCharCode.apply(null, new Uint8Array(wavData)));
                        const dataUrl = `data:audio/wav;base64,${base64}`;

                        const sampleLoader = typeof window.samples === 'function'
                            ? window.samples
                            : (typeof samples === 'function' ? samples : null);

                        if (sampleLoader) {
                            await sampleLoader({ [sampleName]: [dataUrl] });
                            ttsSampleNameByPrompt[text] = sampleName;
                            console.log('Registered cached TTS sample:', sampleName);
                        }
                        return sampleName;
                    } catch (e) {
                        console.warn('Failed to register cached TTS sample, will regenerate:', e);
                        // fall through to regenerate
                    }
                }

                // Generate fresh audio via worker
                try {
                    console.log('🎙️ Generating speech for prompt...');
                    const result = await generateTTSAudio(text);

                    // store in memory and persistent cache
                    ttsAudioBuffers[text] = { audio: result.audio, sampling_rate: result.sampling_rate };
                    await saveTTSToCache(text, result.audio, result.sampling_rate);

                    // Register as a Strudel sample under the deterministic name
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const audioBuffer = audioContext.createBuffer(1, result.audio.length, result.sampling_rate);
                    audioBuffer.getChannelData(0).set(result.audio);

                    const wavData = audioBufferToWav(audioBuffer);
                    const base64 = btoa(String.fromCharCode.apply(null, new Uint8Array(wavData)));
                    const dataUrl = `data:audio/wav;base64,${base64}`;

                    const sampleLoader = typeof window.samples === 'function'
                        ? window.samples
                        : (typeof samples === 'function' ? samples : null);

                    if (sampleLoader) {
                        await sampleLoader({ [sampleName]: [dataUrl] });
                        ttsSampleNameByPrompt[text] = sampleName;
                        console.log('Registered TTS sample via data URL:', sampleName);
                    } else {
                        console.error('Samples loader not available');
                    }

                    return sampleName;
                } catch (e) {
                    console.error('Error generating TTS sample:', e);
                    throw e;
                }
            };

            // Helper function to convert AudioBuffer to WAV format
            const audioBufferToWav = (buffer) => {
                const length = buffer.length * buffer.numberOfChannels * 2;
                const arrayBuffer = new ArrayBuffer(44 + length);
                const view = new DataView(arrayBuffer);
                const channels = [];
                let offset = 0;
                let pos = 0;

                // Write WAV header
                const setUint16 = (data) => {
                    view.setUint16(pos, data, true);
                    pos += 2;
                };
                const setUint32 = (data) => {
                    view.setUint32(pos, data, true);
                    pos += 4;
                };

                // "RIFF" chunk descriptor
                setUint32(0x46464952); // "RIFF"
                setUint32(36 + length); // file length - 8
                setUint32(0x45564157); // "WAVE"

                // "fmt " sub-chunk
                setUint32(0x20746d66); // "fmt "
                setUint32(16); // subchunk1size
                setUint16(1); // audio format (1 = PCM)
                setUint16(buffer.numberOfChannels);
                setUint32(buffer.sampleRate);
                setUint32(buffer.sampleRate * buffer.numberOfChannels * 2); // byte rate
                setUint16(buffer.numberOfChannels * 2); // block align
                setUint16(16); // bits per sample

                // "data" sub-chunk
                setUint32(0x61746164); // "data"
                setUint32(length);

                // Write interleaved audio data
                for (let i = 0; i < buffer.numberOfChannels; i++) {
                    channels.push(buffer.getChannelData(i));
                }

                while (pos < arrayBuffer.byteLength) {
                    for (let i = 0; i < buffer.numberOfChannels; i++) {
                        let sample = channels[i][offset];
                        sample = Math.max(-1, Math.min(1, sample));
                        view.setInt16(pos, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                        pos += 2;
                    }
                    offset++;
                }

                return arrayBuffer;
            };

            // Generate pattern based on prompt using semantic similarity with STRICT category filtering
            const generatePatternFromPrompt = async (prompt, categoryBias = null) => {
                if (!extractor || !patternEmbeddingsCache || !prompt.trim()) {
                    // Fallback: pick random pattern from the STRICT category only
                    const patterns = categoryBias && patternLibrary[categoryBias]
                        ? patternLibrary[categoryBias]
                        : Object.values(patternLibrary).flat();
                    const selected = patterns[Math.floor(Math.random() * patterns.length)];
                    return { code: selected.code, description: selected.desc };
                }

                try {
                    // Get embedding for the prompt (only one embedding needed now!)
                    const promptEmbedding = await extractor(prompt, { pooling: 'mean', normalize: true });
                    const promptVector = Array.from(promptEmbedding.data);

                    // STRICT filtering: only consider patterns from the slot's category
                    const categoryPatterns = categoryBias
                        ? patternEmbeddingsCache.filter(p => p.category === categoryBias)
                        : patternEmbeddingsCache;

                    // Compute similarities using pre-cached embeddings (only for matching category)
                    const scoredPatterns = categoryPatterns.map(pattern => {
                        const similarity = cosineSimilarity(promptVector, pattern.embedding);
                        return { ...pattern, similarity };
                    });

                    // Sort by similarity
                    scoredPatterns.sort((a, b) => b.similarity - a.similarity);

                    // Use weighted random selection from top matches (add some randomness)
                    const topN = Math.min(5, scoredPatterns.length);
                    const topPatterns = scoredPatterns.slice(0, topN);

                    // Map the UI creativity (0..1) to a temperature value. Lower creativity -> more deterministic.
                    // creativity 0  => temperature ~0.1 (almost deterministic)
                    // creativity 1  => temperature ~1.5 (more exploratory)
                    const temperature = Math.max(0.01, 0.1 + (creativity * 1.4));

                    // If creativity is very low, pick the top match deterministically
                    if (typeof creativity === 'number' && creativity < 0.12) {
                        console.log('Deterministic mode: picking top match');
                        return { code: topPatterns[0].code, description: topPatterns[0].desc };
                    }

                    // Otherwise use a softmax weighted by similarity and temperature
                    const weights = topPatterns.map(p => Math.exp(p.similarity / temperature));
                    const totalWeight = weights.reduce((a, b) => a + b, 0);

                    let random = Math.random() * totalWeight;
                    for (let i = 0; i < topPatterns.length; i++) {
                        random -= weights[i];
                        if (random <= 0) {
                            console.log(`Selected ${topPatterns[i].category}: "${topPatterns[i].desc.substring(0, 40)}..."`);
                            return { code: topPatterns[i].code, description: topPatterns[i].desc };
                        }
                    }

                    // Fallback to top match
                    console.log(`Selected ${topPatterns[0].category}: "${topPatterns[0].desc.substring(0, 40)}..."`);
                    return { code: topPatterns[0].code, description: topPatterns[0].desc };
                } catch (e) {
                    console.error('Error generating pattern:', e);
                    // Fallback to random from the STRICT category
                    const patterns = categoryBias && patternLibrary[categoryBias]
                        ? patternLibrary[categoryBias]
                        : Object.values(patternLibrary).flat();
                    const selected = patterns[Math.floor(Math.random() * patterns.length)];
                    return { code: selected.code, description: selected.desc };
                }
            };

            // Mutate/spice up an existing pattern with richer, multi-step mutations
            const spiceUpPattern = (currentCode, categoryName) => {
                if (!currentCode || !currentCode.trim()) return currentCode;

                const randChoice = (arr) => arr[Math.floor(Math.random() * arr.length)];
                const rand = (min, max) => (Math.random() * (max - min) + min);

                const hasEffect = (code, effectName) => new RegExp(`\\.${effectName}\\(`).test(code);

                // Safely replace a single effect's params (handles nested parens)
                const replaceEffect = (code, effectName, newValue) => {
                    const regex = new RegExp(`\\.${effectName}\\(`);
                    const match = regex.exec(code);
                    if (!match) return code;
                    let start = match.index;
                    let i = start + match[0].length;
                    let depth = 0;
                    for (; i < code.length; i++) {
                        if (code[i] === '(') depth++;
                        else if (code[i] === ')') {
                            if (depth === 0) { i++; break; }
                            depth--;
                        }
                    }
                    return code.substring(0, start) + `.${effectName}(${newValue})` + code.substring(i);
                };

                // Remove first occurrence of an effect
                const removeEffect = (code, effectName) => {
                    const regex = new RegExp(`\\.${effectName}\\(`);
                    const match = regex.exec(code);
                    if (!match) return code;
                    let start = match.index;
                    let i = start + match[0].length;
                    let depth = 0;
                    for (; i < code.length; i++) {
                        if (code[i] === '(') depth++;
                        else if (code[i] === ')') {
                            if (depth === 0) { i++; break; }
                            depth--;
                        }
                    }
                    return code.substring(0, start) + code.substring(i);
                };

                let code = currentCode;

                // A set of focused mutation strategies
                const mutations = [];

                // 1) Structural / rhythmic mutations: edit .struct("...") or .n("...") or n("...")
                mutations.push(() => {
                    // mutate .struct("...")
                    const structMatch = code.match(/\\.struct\\(("|')([^"']+)("|')\\)/);
                    if (structMatch) {
                        let struct = structMatch[2];
                        // add or swap an accent or ghost-note and sometimes insert a roll
                        if (Math.random() < 0.5) {
                            // insert a micro-roll or ghost note
                            struct = struct.replace(/~|x/g, (m) => (Math.random() < 0.18 ? `x(3,8)` : m));
                        } else {
                            // flip some ~ to x or vice-versa
                            struct = struct.split(' ').map(tok => {
                                if (Math.random() < 0.15) return tok === '~' ? 'x' : '~';
                                if (tok.match(/x\(\d+,\d+\)/) && Math.random() < 0.25) {
                                    const v = [3,4,5,6,8,16][Math.floor(Math.random()*6)];
                                    return 'x(' + v + ')';
                                }
                                return tok;
                            }).join(' ');
                        }
                        code = code.replace(structMatch[0], '.struct("' + struct + '")');
                        return true;
                    }

                    // mutate n("...") sequences (notes) by transposing or turning some notes into ranges
                    const nMatch = code.match(/(\b|\.)n\\(("|')([^"']+)("|')\\)/);
                    if (nMatch) {
                        let notes = nMatch[3];
                        // transpose numeric tokens
                        notes = notes.replace(/(-?\d+)/g, (m) => {
                            if (Math.random() < 0.35) return String(parseInt(m) + (Math.random() < 0.5 ? -1 : 1));
                            if (Math.random() < 0.08) {
                                return '<' + Math.max(0, parseInt(m)-2) + ' ' + (parseInt(m)+2) + '>';
                            }
                            return m;
                        });
                        code = code.replace(nMatch[0], `n("${notes}")`);
                        return true;
                    }

                    return false;
                });

                // 2) Add small modulations: pan, gain, perlin and small envelopes
                mutations.push(() => {
                    const additions = [
                        '.pan(sine.slow(4))',
                        '.pan(perlin.slow(6))',
                        '.gain(' + (rand(0.6, 1)).toFixed(2) + ')',
                        '.gain(perlin.range(0.6,1))',
                        '.lpq(4)', '.clip(2)', '.early("<0 0.02>")'
                    ];
                    const pick = randChoice(additions);
                    if (!hasEffect(code, pick.match(/\.(\w+)\(/)[1])) {
                        code = code + pick;
                        return true;
                    }
                    return false;
                });

                // 3) Granular / chopping changes
                mutations.push(() => {
                    const choices = ['.chop(4)', '.chop(8)', '.chop(16)', '.striate(4)', '.striate(8)'];
                    const pick = randChoice(choices);
                    if (!hasEffect(code, pick.match(/\.(\w+)\(/)[1]) || Math.random() < 0.4) {
                        code = code + pick;
                        return true;
                    }
                    return false;
                });

                // 4) Filter / warmth changes
                mutations.push(() => {
                    const choices = ['.hpf(300)', '.hpf(800)', '.lpf(2000)', '.lpf(1200)', '.degradeBy(0.08)', '.distort(0.08)'];
                    code = code + randChoice(choices);
                    return true;
                });

                // 5) Temporal shuffles like fast/slow/sometimes/every
                mutations.push(() => {
                    const choices = ['.fast(2)', '.slow(2)', '.sometimes(x=>x.fast(2))', '.every(2,x=>x.fast(1.5))'];
                    code = code + randChoice(choices);
                    return true;
                });

                // 6) TTS-specific tasteful tweaks
                if (categoryName === 'tts') {
                    // Prefer small, speech-focused variations
                    const ttsChoices = [
                        x => replaceEffect(x, 'speed', String((rand(0.85, 1.15)).toFixed(2))),
                        x => x + '.chop(4)',
                        x => x + '.chop(8)',
                        x => x + '.striate(4)',
                        x => x + '.room(0.4)',
                        x => x + '.hpf(' + Math.floor(rand(100,400)) + ')',
                        x => x + '.lpf(' + Math.floor(rand(2500,6000)) + ')',
                        x => x + '.delay(0.25)'
                    ];
                    // apply 1-2 tts-specific mutations
                    const count = 1 + Math.floor(Math.random() * 2);
                    for (let i = 0; i < count; i++) {
                        code = randChoice(ttsChoices)(code);
                    }
                    return code;
                }

                // Decide how many focused mutations to attempt (1..3)
                const attempts = 1 + Math.floor(Math.random() * 3);
                const picked = [];
                for (let i = 0; i < attempts; i++) {
                    // pick a mutation that hasn't run yet if possible
                    const available = mutations.filter((m, idx) => !picked.includes(idx));
                    const idx = Math.floor(Math.random() * available.length);
                    const idxGlobal = mutations.indexOf(available[idx]);
                    picked.push(idxGlobal);
                    try {
                        const applied = available[idx]();
                        // if mutation didn't apply, try another in the same pass
                        if (!applied && Math.random() < 0.4) {
                            // append a small random addition
                            code = code + randChoice(['.gain(0.9)', '.room(0.25)', '.delay(0.125)']);
                        }
                    } catch (e) {
                        console.warn('Spice mutation failed:', e);
                    }
                }

                // small chance to perform a dramatic morph: swap in a short pattern from the library
                if (Math.random() < 0.06) {
                    const samplePatterns = Object.values(patternLibrary).flat();
                    const sample = randChoice(samplePatterns);
                    if (sample && sample.code) code = sample.code + '.gain(0.95)';
                }

                // Trim redundant whitespace and return
                return code.replace(/\s+/g, ' ').trim();
            };

            const waitForScheduler = async (timeoutMs = 5000) => {
                const start = getNow();
                let api = getSchedulerApi();
                let attempts = 0;

                while (getNow() - start < timeoutMs) {
                    if (api && typeof api.setPattern === 'function' && typeof api.setCps === 'function') {
                        return api;
                    }

                    await sleep(50);
                    api = getSchedulerApi();
                    attempts++;

                    // Update progress every few attempts to show activity
                    if (attempts % 5 === 0) {
                        updateLoadingProgress(`Waiting for audio engine...`);
                    }
                }

                return api;
            };

            updateLoadingProgress('Loading Strudel and samples...');
            statusEl.textContent = 'Loading Strudel and samples…';

            await initStrudel({
                // Load the classic Dirt sample pack so bd/sn/hh/etc. are available.
                prebake: async () => {
                    updateLoadingProgress('Loading sample library...');
                    const sampleLoader = typeof window.samples === 'function'
                        ? window.samples
                        : (typeof samples === 'function' ? samples : null);
                    if (!sampleLoader) {
                        console.warn('Strudel samples loader unavailable. Using synth fallback for drums and percussion.');
                        updateLoadingProgress('Using synth fallback...', false);
                        return;
                    }

                    // Load ALL the sample packs - comprehensive loading
                    const allSamplePacks = [
                        { url: 'github:tidalcycles/Dirt-Samples', name: 'Dirt-Samples (main)' },
                        { url: 'github:yaxu/clean-breaks', name: 'breaks' },
                    ];

                    let loadedCount = 0;
                    for (let i = 0; i < allSamplePacks.length; i++) {
                        const pack = allSamplePacks[i];
                        try {
                            updateLoadingProgress(`Loading ${pack.name}... (${i + 1}/${allSamplePacks.length})`);
                            await sampleLoader(pack.url);
                            console.log(`✓ Loaded: ${pack.url}`);
                            loadedCount++;
                            if (i === 0) hasDirtSamples = true; // First pack is main Dirt samples
                        } catch (e) {
                            console.warn(`✗ Failed to load ${pack.url}:`, e.message || e);
                            // Continue trying other packs even if one fails
                        }
                    }

                    console.log(`Successfully loaded ${loadedCount}/${allSamplePacks.length} sample packs`);
                    updateLoadingProgress(`Loaded ${loadedCount} sample packs ✓`);

                    updateLoadingProgress('Sample libraries loaded ✓');
                }
            });

            // initStrudel has completed, now start the audio engine
            updateLoadingProgress('Starting audio system...');

            schedulerApi = await waitForScheduler();

            if (!schedulerApi) {
                console.warn('Strudel scheduler did not become ready in time.');
            }

            updateLoadingProgress('Configuring audio settings...');

            if (!hasDirtSamples) {
                sampleStatusSuffix = ' (samples not loaded)';
            }

            updateLoadingProgress('Audio engine ready ✓');

            // Pre-compute pattern embeddings if AI model is available
            if (extractor) {
                patternEmbeddingsCache = await precomputePatternEmbeddings();
                updateLoadingProgress('Pattern library ready ✓');
            }

            updateLoadingProgress('Setting up interface...');

            // small helper: convert hex color (#rrggbb or #rgb) to "r,g,b" string
            const hexToRgbString = (hex) => {
                if (!hex) return '0,0,0';
                // remove # if present
                let h = hex.replace('#', '');
                if (h.length === 3) {
                    h = h.split('').map(c => c + c).join('');
                }
                const intVal = parseInt(h, 16);
                const r = (intVal >> 16) & 255;
                const g = (intVal >> 8) & 255;
                const b = intVal & 255;
                return `${r}, ${g}, ${b}`;
            };

            // -------- Lifetime helpers (deterministic 8-bar default, clickable +1) --------
            const getBarMs = () => {
                // Try to read BPM from scheduler if available, otherwise default to 120
                let bpm = 120;
                try {
                    if (schedulerApi && typeof schedulerApi.getBpm === 'function') {
                        bpm = schedulerApi.getBpm();
                    } else if (schedulerApi && typeof schedulerApi.bpm === 'number') {
                        bpm = schedulerApi.bpm;
                    } else if (typeof window.bpm === 'number') {
                        bpm = window.bpm;
                    }
                } catch (e) {
                    // fallback to default
                }
                // assuming 4/4 bars
                return (60 / Math.max(1, bpm)) * 1000 * 4;
            };

            // Try to read transport time (in seconds) from the Strudel scheduler if available.
            // We attempt several common API names; fall back to wall-clock seconds.
            const getTransportSeconds = () => {
                try {
                    if (schedulerApi) {
                        // common patterns
                        if (typeof schedulerApi.getPosition === 'function') {
                            // assume seconds
                            return schedulerApi.getPosition();
                        }
                        if (typeof schedulerApi.getNow === 'function') {
                            const v = schedulerApi.getNow();
                            // if large, assume milliseconds
                            if (v > 1e6) return v / 1000;
                            return v;
                        }
                        if (schedulerApi.transport && typeof schedulerApi.transport.position === 'number') {
                            return schedulerApi.transport.position;
                        }
                        if (typeof schedulerApi.position === 'number') {
                            return schedulerApi.position;
                        }
                        if (typeof schedulerApi.getBeat === 'function') {
                            // convert beats to seconds when BPM known
                            const beats = schedulerApi.getBeat();
                            const bpm = (typeof schedulerApi.getBpm === 'function') ? schedulerApi.getBpm() : (schedulerApi.bpm || 120);
                            return (beats * 60) / bpm;
                        }
                    }
                } catch (e) {
                    console.warn('Transport time read failed:', e);
                }
                return Date.now() / 1000;
            };

            // Detect whether the scheduler/transport is currently playing.
            // We try a few common property/method names and fall back to checking
            // whether any slot has code and is unmuted (best-effort).
            const isTransportPlaying = () => {
                try {
                    if (schedulerApi) {
                        if (typeof schedulerApi.isPlaying === 'boolean') return schedulerApi.isPlaying;
                        if (typeof schedulerApi.isPlaying === 'function') return !!schedulerApi.isPlaying();
                        if (schedulerApi.transport) {
                            if (typeof schedulerApi.transport.isPlaying === 'boolean') return schedulerApi.transport.isPlaying;
                            if (typeof schedulerApi.transport.playing === 'boolean') return schedulerApi.transport.playing;
                        }
                        if (typeof schedulerApi.playing === 'boolean') return schedulerApi.playing;
                    }
                } catch (e) {
                    // ignore and fall through to fallback
                }
                try {
                    // fallback: if any slot has code and isn't muted, assume playback is active
                    return slots && Array.isArray(slots) && slots.some(s => s.code && !s.isMuted);
                } catch (e) {
                    return false;
                }
            };

            const destroySlot = (slotObj, reason) => {
                if (!slotObj || !slotObj.element) return;
                // clear any timers
                if (slotObj.lifetimeTimer) { clearTimeout(slotObj.lifetimeTimer); slotObj.lifetimeTimer = null; }
                if (slotObj.lifetimeInterval) { clearInterval(slotObj.lifetimeInterval); slotObj.lifetimeInterval = null; }

                // If already removed from DOM, do nothing
                if (!slotObj.element.parentNode) return;

                slotObj.element.classList.add('removing');
                setTimeout(() => {
                    const index = slots.findIndex(s => s.id === slotObj.id);
                    if (index !== -1) slots.splice(index, 1);
                    try { slotObj.element.remove(); } catch(e) {}
                    refreshPlayback();
                    updateStatus();
                    console.log(`Slot ${slotObj.id} removed (${reason || 'expired/deleted'})`);
                }, 300);
            };

            const scheduleSlotLifetime = (slotObj, barsParam) => {
                if (!slotObj) return;

                // If pinned, do not schedule lifetime — show infinity and locked icon
                if (slotObj.pinned) {
                    if (slotObj.lifetimeBadge) slotObj.lifetimeBadge.classList.add('pinned');
                    if (slotObj.lifetimeText) slotObj.lifetimeText.textContent = '∞';
                    if (slotObj.lifetimePinBtn) slotObj.lifetimePinBtn.innerHTML = '🔒';
                    // when pinned, show full progress bar so it's visually persistent
                    if (slotObj.lifetimeProgressBar) slotObj.lifetimeProgressBar.style.width = '100%';
                    if (slotObj.lifetimeTimer) { clearTimeout(slotObj.lifetimeTimer); slotObj.lifetimeTimer = null; }
                    if (slotObj.lifetimeInterval) { clearInterval(slotObj.lifetimeInterval); slotObj.lifetimeInterval = null; }
                    return;
                }

                // Clear existing lifetime timers
                if (slotObj.lifetimeTimer) { clearTimeout(slotObj.lifetimeTimer); slotObj.lifetimeTimer = null; }
                if (slotObj.lifetimeInterval) { clearInterval(slotObj.lifetimeInterval); slotObj.lifetimeInterval = null; }

                const barMs = getBarMs();

                // Decide bars to schedule:
                // - If barsParam provided, use it
                // - Else if a lifetimeBars value exists (pending or set), use that
                // - Else if an expiry is already set in the future, use remaining bars
                // - Otherwise default to 8 bars
                let bars;
                if (typeof barsParam === 'number' && barsParam > 0) {
                    bars = Math.max(1, Math.floor(barsParam));
                } else if (typeof slotObj.lifetimeBars === 'number' && slotObj.lifetimeBars > 0) {
                    // honor an existing stored bars count (created while idle)
                    bars = Math.max(1, Math.floor(slotObj.lifetimeBars));
                } else if (slotObj.lifetimeExpiresAt && slotObj.lifetimeExpiresAt > Date.now()) {
                    bars = Math.max(1, Math.ceil((slotObj.lifetimeExpiresAt - Date.now()) / barMs));
                } else {
                    bars = 8; // default deterministic lifetime
                }

                // Store the bars count (used for display while idle and when playback begins)
                slotObj.lifetimeBars = bars;

                // If transport/audio is not currently playing, do not start timers.
                // Instead, show the bars count and reset progress to 0 — the actual
                // countdown will start when `refreshPlayback` detects playback and
                // calls `scheduleSlotLifetime` again (which will create timers).
                if (!isTransportPlaying()) {
                    if (slotObj.lifetimeBadge) {
                        slotObj.lifetimeBadge.classList.remove('pinned');
                        slotObj.lifetimeBadge.classList.add('paused');
                    }
                    // show the bars count but replace it with a pause symbol to indicate paused state
                    if (slotObj.lifetimeText) slotObj.lifetimeText.textContent = `⏸`;
                    if (slotObj.lifetimeProgressBar) slotObj.lifetimeProgressBar.style.width = '0%';
                    // clear any timers just in case
                    if (slotObj.lifetimeTimer) { clearTimeout(slotObj.lifetimeTimer); slotObj.lifetimeTimer = null; }
                    if (slotObj.lifetimeInterval) { clearInterval(slotObj.lifetimeInterval); slotObj.lifetimeInterval = null; }
                    console.log(`Deferred scheduling slot ${slotObj.id} (${bars} bar(s)) until playback starts`);
                    return;
                }

                // Transport is playing — compute an expiry aligned to the transport's bar boundary
                try {
                    const bpm = 240000 / barMs; // derive bpm from barMs
                    const transportSec = getTransportSeconds();
                    const beatsElapsed = transportSec * (bpm / 60);
                    const barsElapsed = beatsElapsed / 4;
                    const nextBar = Math.ceil(barsElapsed); // next whole bar index
                    const nextBarBeat = nextBar * 4; // beat number at next bar
                    const beatsUntilNextBar = nextBarBeat - beatsElapsed;
                    const secsUntilNextBar = beatsUntilNextBar * (60 / bpm);

                    const totalMs = Math.round(secsUntilNextBar * 1000) + ((bars - 1) * barMs);
                    slotObj.lifetimeExpiresAt = Date.now() + totalMs;
                } catch (e) {
                    // fallback: simple wall-clock scheduling
                    slotObj.lifetimeExpiresAt = Date.now() + bars * barMs;
                }

                // Ensure the badge element exists and has text/progress elements
                    if (slotObj.lifetimeBadge) {
                        slotObj.lifetimeBadge.classList.remove('pinned');
                        slotObj.lifetimeBadge.classList.remove('paused');
                        if (slotObj.lifetimePinBtn && !slotObj.pinned) slotObj.lifetimePinBtn.innerHTML = '🔓';
                    const updateBadge = () => {
                        const msLeft = Math.max(0, slotObj.lifetimeExpiresAt - Date.now());
                        const barsLeft = Math.max(0, Math.ceil(msLeft / barMs));
                        if (slotObj.lifetimeText) slotObj.lifetimeText.textContent = `${barsLeft}`;
                        // progress within current bar
                        const withinBar = msLeft % barMs;
                        const pct = Math.max(0, Math.min(1, withinBar / barMs));
                        if (slotObj.lifetimeProgressBar) slotObj.lifetimeProgressBar.style.width = `${pct * 100}%`;
                    };
                    updateBadge();
                    slotObj.lifetimeInterval = setInterval(updateBadge, 200);
                }

                const totalMs = Math.max(0, slotObj.lifetimeExpiresAt - Date.now());

                slotObj.lifetimeTimer = setTimeout(() => {
                    if (slotObj.pinned) return;
                    destroySlot(slotObj, 'lifetime expired');
                }, totalMs);

                console.log(`Scheduled slot ${slotObj.id} to expire in ${bars} bar(s)`);
            };
            // ---------------------------------------------------------------

            // Function to create a new slot
            const createSlot = (categoryName) => {
                const slotId = slotIdCounter++;
                const category = slotCategories.find(c => c.name === categoryName) || slotCategories[0];

                const slotDiv = document.createElement('div');
                slotDiv.className = 'slot';
                slotDiv.style.setProperty('--slot-color', category.color);
                // also expose an rgb triplet for CSS use (e.g. overlay tint)
                slotDiv.style.setProperty('--slot-color-rgb', hexToRgbString(category.color));
                slotDiv.dataset.slotId = slotId;

                const header = document.createElement('div');
                header.className = 'slot-header';

                const leftGroup = document.createElement('div');
                leftGroup.style.display = 'flex';
                leftGroup.style.alignItems = 'center';
                leftGroup.style.gap = '0.5rem';

                // Drag handle
                const dragHandle = document.createElement('div');
                dragHandle.className = 'slot-drag-handle';
                dragHandle.innerHTML = '⋮⋮';
                dragHandle.title = 'Drag to reorder';
                dragHandle.draggable = true;

                const muteBtn = document.createElement('button');
                muteBtn.className = 'slot-mute-btn';
                muteBtn.innerHTML = '🔊';
                muteBtn.setAttribute('aria-label', 'Mute/unmute layer');
                muteBtn.title = 'Mute/unmute';

                // place mute button on the left, then drag handle, then expanding lifecycle badge
                leftGroup.appendChild(muteBtn);
                leftGroup.appendChild(dragHandle);

                // Lifetime badge (will show remaining bars once scheduled)
                const lifetimeBadge = document.createElement('div');
                lifetimeBadge.className = 'slot-lifetime-badge';

                const lifetimeText = document.createElement('span');
                lifetimeText.className = 'slot-lifetime-text';
                // show default 8 bars on creation (do not start countdown until playback)
                lifetimeText.textContent = '8';

                // Decrement button (-) to the left of the number
                const decBtn = document.createElement('button');
                decBtn.className = 'slot-lifetime-decrement';
                decBtn.title = 'Decrease lifetime by 1 bar';
                // use a minus sign (unicode) which looks nicer than a hyphen
                decBtn.innerHTML = '−';

                // Increment button (+) to the right of the number
                const incBtn = document.createElement('button');
                incBtn.className = 'slot-lifetime-increment';
                incBtn.title = 'Increase lifetime by 1 bar';
                incBtn.innerHTML = '+';

                const lifetimeProgress = document.createElement('div');
                lifetimeProgress.className = 'slot-lifetime-progress';
                const lifetimeProgressBar = document.createElement('div');
                lifetimeProgressBar.className = 'slot-lifetime-progress-bar';
                // default to empty progress until playback begins
                lifetimeProgressBar.style.width = '0%';
                lifetimeProgress.appendChild(lifetimeProgressBar);

                const pinBtn = document.createElement('button');
                pinBtn.className = 'slot-lifetime-pin';
                pinBtn.title = 'Pin/Unpin from auto-delete';
                // show unlocked icon by default (unpin = unlocked)
                pinBtn.innerHTML = '🔓';

                // Arrange: [ - ] [ number ] [ + ] [ progress ] [ pin ]
                lifetimeBadge.appendChild(decBtn);
                lifetimeBadge.appendChild(lifetimeText);
                lifetimeBadge.appendChild(incBtn);
                lifetimeBadge.appendChild(lifetimeProgress);
                lifetimeBadge.appendChild(pinBtn);

                leftGroup.appendChild(lifetimeBadge);

                // If transport is not playing at creation time, show paused UI
                try {
                    if (!isTransportPlaying()) {
                        lifetimeBadge.classList.add('paused');
                        // show pause in the lifetime text rather than replacing the pin
                        if (lifetimeText) lifetimeText.textContent = '⏸';
                        // keep pin button showing unlocked by default
                        if (pinBtn) pinBtn.innerHTML = '🔓';
                    }
                } catch (e) {
                    // ignore
                }

                const controlsGroup = document.createElement('div');
                controlsGroup.className = 'slot-controls';

                const slotPromptInput = document.createElement('input');
                slotPromptInput.type = 'text';
                slotPromptInput.className = 'slot-prompt';
                const slotPlaceholders = {
                    kick: 'Describe the kick (four-on-floor, 808, syncopated...)',
                    snare: 'Describe the snare/clap (backbeat, half-time, ghost notes...)',
                    hihat: 'Describe hi-hat pattern (steady 16ths, trap rolls, shuffle...)',
                    perc: 'Describe percussion (shaker, conga, rim, toms...)',
                    bass: 'Describe the bass (sub, wobble, pluck...)',
                    melody: 'Describe the melody (lead, arps, or motifs...)',
                    chords: 'Describe chord style (pad, stabs, piano...)',
                    texture: 'Describe texture/FX (sweeps, washes, grain...)',
                    arp: 'Describe arpeggios (fast, slow, rhythmic, dreamy...)',
                    tts: 'What would you like to say...'
                };
                slotPromptInput.placeholder = slotPlaceholders[category.name] || 'Describe the vibe...';
                slotPromptInput.disabled = !extractor;

                const dice = document.createElement('button');
                dice.className = 'slot-dice';
                dice.innerHTML = '⚅';
                dice.setAttribute('aria-label', `Generate ${category.desc} pattern`);
                dice.title = `Roll for ${category.desc}`;
                dice.disabled = !extractor;

                const spice = document.createElement('button');
                spice.className = 'slot-spice';
                spice.innerHTML = '✦';
                spice.setAttribute('aria-label', `Add spice to ${category.desc} pattern`);
                spice.title = `Add spice - mutate current pattern`;
                spice.disabled = !extractor;

                // Rewind button: step back to previous pattern after a roll or mutation
                const rewindBtn = document.createElement('button');
                rewindBtn.className = 'slot-rewind';
                // Use a plain Unicode rewind symbol (non-emoji)
                rewindBtn.innerHTML = '↺';
                rewindBtn.title = 'Rewind to previous pattern';
                rewindBtn.setAttribute('aria-label', `Rewind ${category.desc} to previous pattern`);
                rewindBtn.disabled = true;

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'slot-delete-btn';
                deleteBtn.innerHTML = '×';
                deleteBtn.setAttribute('aria-label', 'Delete layer');
                deleteBtn.title = 'Delete layer';

                const textarea = document.createElement('textarea');
                textarea.className = 'slot-code';
                textarea.placeholder = category.name === 'tts'
                    ? 'Click ↻ to generate speech, then edit and press Enter to apply...'
                    : 'Click ↻ to generate, or enter Strudel code and press Enter...';

                const codeWrapper = document.createElement('div');
                codeWrapper.className = 'slot-code-wrapper';

                const emojiBackground = document.createElement('div');
                emojiBackground.className = 'slot-code-emoji';
                emojiBackground.textContent = category.icon;

                codeWrapper.appendChild(emojiBackground);
                codeWrapper.appendChild(textarea);

                controlsGroup.appendChild(slotPromptInput);
                controlsGroup.appendChild(dice);
                controlsGroup.appendChild(spice);
                controlsGroup.appendChild(rewindBtn);
                controlsGroup.appendChild(deleteBtn);

                header.appendChild(leftGroup);
                header.appendChild(controlsGroup);
                slotDiv.appendChild(header);
                slotDiv.appendChild(codeWrapper);

                // Create slot object
                const slotObj = {
                    id: slotId,
                    code: '',
                    element: slotDiv,
                    diceButton: dice,
                    spiceButton: spice,
                    textarea: textarea,
                    promptInput: slotPromptInput,
                    muteButton: muteBtn,
                    deleteButton: deleteBtn,
                    isMuted: false,
                    category: category.name,
                    dragHandle: dragHandle
                    , lifetimeBadge: lifetimeBadge,
                    lifetimeText: lifetimeText,
                    lifetimeProgressBar: lifetimeProgressBar,
                    lifetimePinBtn: pinBtn,
                    lifetimeTimer: null,
                    lifetimeInterval: null,
                    lifetimeBars: 8, // default visible lifetime (but not ticking until playback)
                    lifetimeExpiresAt: null,
                    pinned: false
                    ,
                    // history / rewind support
                    history: [],
                    rewindButton: rewindBtn,
                    _lastCommittedCode: ''
                };

                // History helper: push the previous code state so rewind can restore it.
                const pushToHistory = (prevCode) => {
                    try {
                        // normalize prevCode to string
                        const codeStr = (typeof prevCode === 'string') ? prevCode : '';
                        // capture the current prompt text so we can restore it on rewind
                        // prefer the visible prompt input, but fall back to any dataset-stored tts text
                        let promptStr = '';
                        try {
                            if (slotPromptInput && typeof slotPromptInput.value === 'string' && slotPromptInput.value.trim()) {
                                promptStr = slotPromptInput.value.trim();
                            } else if (textarea && textarea.dataset && typeof textarea.dataset.ttsText === 'string' && textarea.dataset.ttsText.trim()) {
                                promptStr = textarea.dataset.ttsText.trim();
                            }
                        } catch (e) { promptStr = ''; }
                        // If we couldn't capture a prompt text but the code references a concrete
                        // TTS sample (e.g. s("tts_xxx:0")), attempt a reverse lookup into
                        // ttsSampleNameByPrompt so we can restore a visible prompt when rewinding.
                        if (!promptStr && codeStr) {
                            try {
                                const m = codeStr.match(/s\((['\"])([^'\"]+):\d+\1\)/);
                                if (m && m[2]) {
                                    const sampleName = m[2];
                                    for (const [p, n] of Object.entries(ttsSampleNameByPrompt)) {
                                        if (n === sampleName) { promptStr = p; break; }
                                    }
                                }
                            } catch (e) { /* ignore reverse lookup errors */ }
                        }
                        // detect if the code references a concrete registered sample name
                        let sampleNameStr = '';
                        try {
                            const sm = codeStr.match(/s\((['"])([^'\"]+):\d+\1\)/);
                            if (sm && sm[2]) sampleNameStr = sm[2];
                        } catch (e) { sampleNameStr = ''; }
                        // prefer any explicit current sampleName stored on the slot
                        try {
                            if (!sampleNameStr && slotObj && slotObj.currentTtsSampleName) sampleNameStr = slotObj.currentTtsSampleName;
                        } catch (e) {}

                        const entry = { code: codeStr, prompt: promptStr, sampleName: sampleNameStr };
                        // Avoid pushing duplicates in a row (compare by code)
                        const last = slotObj.history.length > 0 ? slotObj.history[slotObj.history.length - 1] : null;
                        if (!last || last.code !== entry.code) {
                            slotObj.history.push(entry);
                            try { console.log('[history] push:', { slotId: slotObj.id, entry }); } catch (e) {}
                        }
                        // enable rewind UI
                        if (slotObj.rewindButton) slotObj.rewindButton.disabled = slotObj.history.length === 0;
                    } catch (e) {
                        console.warn('Could not push to history:', e);
                    }
                };

                const updateRewindButton = () => {
                    if (slotObj.rewindButton) slotObj.rewindButton.disabled = slotObj.history.length === 0;
                };

                // Mute button handler
                muteBtn.addEventListener('click', () => {
                    slotObj.isMuted = !slotObj.isMuted;
                    muteBtn.classList.toggle('is-muted', slotObj.isMuted);
                    muteBtn.innerHTML = slotObj.isMuted ? '🔇' : '🔊';
                    slotDiv.classList.toggle('is-muted', slotObj.isMuted);

                    if (slotObj.isMuted) {
                        // stop any lifetime countdown when muted
                        if (slotObj.lifetimeTimer) { clearTimeout(slotObj.lifetimeTimer); slotObj.lifetimeTimer = null; }
                        if (slotObj.lifetimeInterval) { clearInterval(slotObj.lifetimeInterval); slotObj.lifetimeInterval = null; }
                        // show the stored bars (or default 8) and reset visual progress
                        if (slotObj.lifetimeText) slotObj.lifetimeText.textContent = '⏸';
                        if (slotObj.lifetimeProgressBar) slotObj.lifetimeProgressBar.style.width = '0%';
                        if (slotObj.lifetimeBadge) slotObj.lifetimeBadge.classList.add('paused');
                        // keep pin icon as unlocked unless pinned
                        if (slotObj.lifetimePinBtn && !slotObj.pinned) slotObj.lifetimePinBtn.innerHTML = '🔓';
                    } else {
                        // when unmuted, reset lifetime to 8 bars (unless pinned)
                        if (!slotObj.pinned) {
                            slotObj.lifetimeBadge && slotObj.lifetimeBadge.classList.remove('paused');
                            slotObj.lifetimeBars = 8;
                            try { scheduleSlotLifetime(slotObj, 8); } catch (err) { console.warn('Could not schedule after unmute:', err); }
                        } else {
                            // if pinned, ensure infinity UI
                            if (slotObj.lifetimeText) slotObj.lifetimeText.textContent = '∞';
                            if (slotObj.lifetimePinBtn) slotObj.lifetimePinBtn.innerHTML = '🔒';
                        }
                    }

                    refreshPlayback();
                });

                // Pin button handler (toggle auto-delete)
                pinBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    slotObj.pinned = !slotObj.pinned;
                    if (slotObj.pinned) {
                        // clear any timers and mark as pinned
                        if (slotObj.lifetimeTimer) { clearTimeout(slotObj.lifetimeTimer); slotObj.lifetimeTimer = null; }
                        if (slotObj.lifetimeInterval) { clearInterval(slotObj.lifetimeInterval); slotObj.lifetimeInterval = null; }
                        slotObj.lifetimeBadge.classList.remove('paused');
                        slotObj.lifetimeBadge.classList.add('pinned');
                        // show infinity sign when pinned
                        if (slotObj.lifetimeText) slotObj.lifetimeText.textContent = '∞';
                        if (slotObj.lifetimePinBtn) slotObj.lifetimePinBtn.innerHTML = '🔒';
                        if (slotObj.lifetimeProgressBar) slotObj.lifetimeProgressBar.style.width = '100%';
                    } else {
                        // unpinned: remove pinned UI, show unlocked icon and reset lifetime to exactly 8 bars
                        slotObj.lifetimeBadge.classList.remove('pinned');
                        slotObj.lifetimeBadge.classList.remove('paused');
                        if (slotObj.lifetimePinBtn) slotObj.lifetimePinBtn.innerHTML = '🔓';
                        try { scheduleSlotLifetime(slotObj, 8); } catch (err) { console.warn('Could not schedule after unpin:', err); }
                    }
                });

                    // Clicking the + / - buttons adjusts bars (left = -, right = +)
                    incBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        try {
                            const barMs = getBarMs();
                            const add = 1;
                            // If pinned, keep pinned but still extend an internal expiry value
                            if (!slotObj.lifetimeExpiresAt || slotObj.lifetimeExpiresAt < Date.now()) {
                                // If there's no expiry, create one equal to now + add
                                slotObj.lifetimeExpiresAt = Date.now() + add * barMs;
                            } else {
                                slotObj.lifetimeExpiresAt = slotObj.lifetimeExpiresAt + add * barMs;
                            }

                            // Update lifetimeBars approx
                            slotObj.lifetimeBars = Math.max(1, Math.ceil((slotObj.lifetimeExpiresAt - Date.now()) / barMs));

                            // If not pinned, (re)schedule timers to reflect increased lifetime
                            if (!slotObj.pinned) {
                                try { scheduleSlotLifetime(slotObj); } catch (err) { console.warn('Could not reschedule after add:', err); }
                            } else {
                                // keep showing infinity when pinned
                                if (slotObj.lifetimeText) slotObj.lifetimeText.textContent = '∞';
                            }

                            // tiny visual feedback
                            lifetimeText.style.transform = 'scale(1.15)';
                            setTimeout(() => lifetimeText.style.transform = '', 140);
                        } catch (e) {
                            console.warn('Could not add bars:', e);
                        }
                    });

                    decBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        try {
                            const barMs = getBarMs();

                            // If pinned, ignore decrement (showing infinity)
                            if (slotObj.pinned) {
                                // brief visual cue to show it's pinned
                                lifetimeText.style.transform = 'scale(0.95)';
                                setTimeout(() => lifetimeText.style.transform = '', 140);
                                return;
                            }

                            const sub = 1;
                            const now = Date.now();

                            // Determine current ms left; fall back to lifetimeBars if no expiry
                            let msLeft = 0;
                            if (slotObj.lifetimeExpiresAt && slotObj.lifetimeExpiresAt > now) {
                                msLeft = slotObj.lifetimeExpiresAt - now;
                            } else {
                                const baseBars = (typeof slotObj.lifetimeBars === 'number' && slotObj.lifetimeBars > 0) ? slotObj.lifetimeBars : 8;
                                msLeft = baseBars * barMs;
                            }

                            msLeft = Math.max(barMs, msLeft - sub * barMs); // never go below 1 bar
                            slotObj.lifetimeExpiresAt = now + msLeft;

                            slotObj.lifetimeBars = Math.max(1, Math.ceil((slotObj.lifetimeExpiresAt - now) / barMs));

                            // (re)schedule timers to reflect decreased lifetime
                            try { scheduleSlotLifetime(slotObj); } catch (err) { console.warn('Could not reschedule after subtract:', err); }

                            // tiny visual feedback
                            lifetimeText.style.transform = 'scale(0.95)';
                            setTimeout(() => lifetimeText.style.transform = '', 140);
                        } catch (e) {
                            console.warn('Could not remove bars:', e);
                        }
                    });

                // Delete button handler
                deleteBtn.addEventListener('click', () => {
                    // Clear any lifetime timers before removal
                    if (slotObj.lifetimeTimer) { clearTimeout(slotObj.lifetimeTimer); slotObj.lifetimeTimer = null; }
                    if (slotObj.lifetimeInterval) { clearInterval(slotObj.lifetimeInterval); slotObj.lifetimeInterval = null; }

                    slotDiv.classList.add('removing');
                    setTimeout(() => {
                        const index = slots.findIndex(s => s.id === slotId);
                        if (index !== -1) {
                            slots.splice(index, 1);
                        }
                        slotDiv.remove();
                        refreshPlayback();
                        updateStatus();
                    }, 300);
                });

                // Code change handler - apply on input
                textarea.addEventListener('input', () => {
                    slotObj.code = textarea.value.trim();
                });

                // Enter key handler - apply changes (Cmd/Ctrl+Enter for new line)
                textarea.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.metaKey) {
                        e.preventDefault();

                        // Add flash animation for visual feedback
                        textarea.classList.add('flash');
                        setTimeout(() => textarea.classList.remove('flash'), 400);

                        if (category.name === 'tts') {
                            // For TTS, regenerate with current text
                            const text = textarea.dataset.ttsText || slotPromptInput.value.trim() || 'Welcome';
                            const previousDiceIcon = dice.innerHTML;
                            dice.disabled = true;
                            dice.innerHTML = '⏳';

                            // helper: replace any generic tts token references in code with the concrete sampleName
                            const rewriteTtsReferences = (code, sampleName) => {
                                if (!code || !sampleName) return code;
                                try {
                                    return code.replace(/s\((['"])(.*?)\1\)/g, (m, q, inner) => {
                                        // if inner starts with 'tts' assume it's a generic/legacy tts token and rewrite
                                        if (inner && inner.startsWith('tts')) {
                                            return `s("${sampleName}:0")`;
                                        }
                                        return m;
                                    });
                                } catch (e) {
                                    return code;
                                }
                            };

                            generateTTSSample(text).then((sampleName) => {
                                // If this slot didn't already have a pattern, set a default TTS playback code
                                if (!slotObj.code || !slotObj.code.trim()) {
                                    let defaultTtsCode = `s("${sampleName}:0").n("0 ~ 0 ~")`;
                                    defaultTtsCode = maybeApplyNaturalSkipToCode(defaultTtsCode);
                                    slotObj.code = defaultTtsCode;
                                    textarea.value = defaultTtsCode;
                                    textarea.dataset.ttsText = text;
                                    textarea.dataset.ttsSampleName = sampleName;
                                    try { if (slotPromptInput) slotPromptInput.value = text; } catch (e) {}
                                    try { slotObj.currentTtsSampleName = sampleName; } catch (e) {}
                                } else {
                                    // If there was existing code that referenced a generic tts token, rewrite it to the concrete sampleName
                                    try {
                                        const rewritten = rewriteTtsReferences(slotObj.code, sampleName);
                                        if (rewritten !== slotObj.code) {
                                            slotObj.code = rewritten;
                                            textarea.value = rewritten;
                                        }
                                    } catch (e) { /* ignore */ }
                                }

                                refreshPlayback();
                                // Assign a randomized lifetime for this newly-generated pattern
                                try { scheduleSlotLifetime(slotObj); } catch (e) { console.warn('Could not schedule lifetime:', e); }
                            }).catch(e => {
                                console.error('Error generating TTS:', e);
                            }).finally(() => {
                                dice.disabled = false;
                                dice.innerHTML = previousDiceIcon;
                            });
                        } else {
                            // For regular code, commit the manual edit and enable rewind
                            try {
                                if (slotObj._lastCommittedCode !== slotObj.code) {
                                    // Push the current code before committing the new state so rewind restores correctly
                                    pushToHistory(slotObj.code || '');
                                    slotObj._lastCommittedCode = slotObj.code;
                                }
                            } catch (e) { /* ignore */ }

                            if (!slotObj.isMuted && slotObj.code) {
                                refreshPlayback();
                                try { scheduleSlotLifetime(slotObj); } catch (e) { console.warn('Could not schedule lifetime:', e); }
                            }
                        }
                    }
                });

                // Dice button handler
                dice.addEventListener('click', () => {
                    // Prevent multiple clicks while processing
                    if (dice.disabled) return;

                    if (category.name === 'tts') {
                        const text = slotPromptInput.value.trim() || 'Welcome to the Strudel Mixer';
                        slotPromptInput.value = text;

                        const originalStatus = statusEl.textContent;
                        statusEl.textContent = 'Generating speech...';

                        animateDiceRoll(dice, async () => {
                            try {
                                // Generate and register sample; generateTTSSample returns the concrete sampleName
                                const sampleName = await generateTTSSample(text);

                                // Generate TTS with random effects/variations using the concrete sampleName
                                const ttsVariations = [
                                    `s("${sampleName}:0").speed(1)`,
                                    `s("${sampleName}:0").speed(0.9).room(0.5)`,
                                    `s("${sampleName}:0").speed(1.1).delay(0.25)`,
                                    `s("${sampleName}:0").chop(4).speed(0.95)`,
                                    `s("${sampleName}:0").chop(8).room(0.3)`,
                                    `s("${sampleName}:0").speed("<1 0.9>").room(0.4)`,
                                    `s("${sampleName}:0").striate(4).speed(0.95)`,
                                    `s("${sampleName}:0").sometimes(x=>x.speed(0.8)).delay(0.3)`,
                                    `s("${sampleName}:0").chunk(4, x=>x.fast(rand.range(0.8,1.2)))`,
                                    `s("${sampleName}:0").speed(perlin.range(0.9,1.1)).room(0.5)`,
                                    `s("${sampleName}:0").chop(16).speed(1.05)`,
                                    `s("${sampleName}:0").fast(2).chop(2)`,
                                    `s("${sampleName}:0").slow(2).room(0.7)`,
                                    // TTS-specific rhythmic variations with rests to make speech patterns less repetitive
                                    `s("${sampleName}:0").n("0 ~ 0 ~").speed(1)`,
                                    `s("${sampleName}:0").n("0 ~ ~ 0").speed(0.95).room(0.25)`,
                                    `s("${sampleName}:0").n("0 ~ ~ ~").speed(0.95).room(0.3)`,
                                    `s("${sampleName}:0").speed(1).hpf(200).lpf(3000)`,
                                    `s("${sampleName}:0").speed(rand.range(0.85,1.15)).delay(0.4)`,
                                ];

                                // Avoid generating the same variation if there's already code
                                let ttsCode;
                                const currentCode = slotObj.code || '';

                                // push previous state so user can rewind
                                try { pushToHistory(currentCode); } catch (e) { /* ignore */ }

                                const availableVariations = ttsVariations.filter(v => v !== currentCode);

                                if (availableVariations.length > 0) {
                                    ttsCode = availableVariations[Math.floor(Math.random() * availableVariations.length)];
                                } else {
                                    ttsCode = ttsVariations[Math.floor(Math.random() * ttsVariations.length)];
                                }

                                // Apply a small chance to inject a natural-skip into the pattern code so TTS
                                // playback doesn't feel too repetitive. This is influenced by the "creativity" slider.
                                ttsCode = maybeApplyNaturalSkipToCode(ttsCode);

                                slotObj.code = ttsCode;
                                textarea.value = ttsCode;
                                textarea.dataset.ttsText = text;
                                textarea.dataset.ttsSampleName = sampleName;
                                try { if (slotPromptInput) slotPromptInput.value = text; } catch (e) {}
                                try { slotObj.currentTtsSampleName = sampleName; } catch (e) {}
                                slotObj._lastCommittedCode = slotObj.code;

                                statusEl.textContent = 'Speech generated!';
                                setTimeout(() => {
                                    statusEl.textContent = originalStatus;
                                }, 2000);

                                if (!slotObj.isMuted) {
                                    refreshPlayback();
                                }
                                // Schedule lifetime for this generated TTS pattern (reset to 8 bars)
                                try { scheduleSlotLifetime(slotObj, 8); } catch (e) { console.warn('Could not schedule lifetime:', e); }
                            } catch (e) {
                                console.error('Error generating TTS:', e);
                                statusEl.textContent = 'TTS generation failed';
                                setTimeout(() => {
                                    statusEl.textContent = originalStatus;
                                }, 3000);
                            }
                        });
                    } else {
                        // Category-specific default prompts for cohesive minimal techno
                        const defaultPrompts = {
                            kick: 'four on the floor house kick, 808 heavy sub, or syncopated techno kick',
                            snare: 'backbeat clap or snare with ghost notes and tight reverb',
                            hihat: 'steady 16th hats, triplets, or shuffled hats for groove',
                            perc: 'conga, shaker, rimshots, or polyrhythmic percussion',
                            bass: 'minimal techno pulse, hypnotic repetitive throb, sub bass',
                            melody: 'arpeggiated synth line or bright saw lead melody',
                            chords: 'warm chord stabs, sustained pad or punchy synth chords',
                            texture: 'spacey risers, filtered noise, subtle ambience and fx',
                            arp: 'fast rhythmic arpeggios, dreamy sequences, or evolving patterns'
                        };

                        const prompt = slotPromptInput.value.trim() || defaultPrompts[slotObj.category] || 'minimal techno';

                        animateDiceRoll(dice, async () => {
                            try {
                                let result = await generatePatternFromPrompt(prompt, slotObj.category);

                                // If we got the exact same code, try one more time
                                if (result.code === slotObj.code) {
                                    result = await generatePatternFromPrompt(prompt, slotObj.category);
                                }

                                // push previous state for rewind
                                try { pushToHistory(slotObj.code || ''); } catch (e) { /* ignore */ }

                                slotObj.code = result.code;
                                textarea.value = result.code;
                                slotObj._lastCommittedCode = slotObj.code;

                                // Update the prompt input with the pattern's description
                                slotPromptInput.value = result.description;

                                if (!slotObj.isMuted) {
                                    refreshPlayback();
                                }
                                // Rolling the dice resets lifetime to 8 bars (unless pinned)
                                try { scheduleSlotLifetime(slotObj, 8); } catch (e) { console.warn('Could not schedule lifetime:', e); }
                            } catch (e) {
                                console.error('Error generating pattern:', e);
                            }
                        });
                    }
                });

                // Spice button handler - mutate existing pattern
                spice.addEventListener('click', () => {
                    // Prevent multiple clicks while processing
                    if (spice.disabled) return;

                    // Need existing code to mutate
                    if (!slotObj.code || !slotObj.code.trim()) {
                        console.log('No pattern to spice up - roll the dice first!');
                        return;
                    }

                    if (category.name === 'tts') {
                        // For TTS, apply spice to the existing TTS code
                        animateDiceRoll(spice, async () => {
                            const currentCode = slotObj.code;
                            try { pushToHistory(currentCode); } catch (e) {}
                            const spicedCode = spiceUpPattern(currentCode, category.name);

                            if (spicedCode !== currentCode) {
                                slotObj.code = spicedCode;
                                textarea.value = spicedCode;
                                slotObj._lastCommittedCode = slotObj.code;

                                if (!slotObj.isMuted) {
                                    refreshPlayback();
                                }
                                try { scheduleSlotLifetime(slotObj); } catch (e) { console.warn('Could not schedule lifetime:', e); }
                            }
                        }, 'spicing');
                    } else {
                        // For regular patterns, apply mutations
                        animateDiceRoll(spice, async () => {
                            const currentCode = slotObj.code;
                            try { pushToHistory(currentCode); } catch (e) {}
                            const spicedCode = spiceUpPattern(currentCode, category.name);

                            if (spicedCode !== currentCode) {
                                slotObj.code = spicedCode;
                                textarea.value = spicedCode;
                                slotObj._lastCommittedCode = slotObj.code;

                                if (!slotObj.isMuted) {
                                    refreshPlayback();
                                }
                                try { scheduleSlotLifetime(slotObj); } catch (e) { console.warn('Could not schedule lifetime:', e); }
                            }
                        }, 'spicing');
                    }
                });

                // Rewind handler: pop last saved code state and restore it
                rewindBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!slotObj.history || slotObj.history.length === 0) return;
                    // animate the button briefly for feedback
                    try {
                        rewindBtn.classList.add('rewinding');
                        setTimeout(() => rewindBtn.classList.remove('rewinding'), 520);
                    } catch (err) {
                        /* ignore animation errors */
                    }
                    // Pop the last entry. If the entry has no code and no prompt,
                    // continue popping until we find a meaningful entry or history is empty.
                    let prev = slotObj.history.pop();
                    // skip empty tombstone entries (often from initial empty pushes)
                    while (prev && !prev.code && !prev.prompt && slotObj.history.length > 0) {
                        try { console.log('[history] skipping empty tombstone for slot', slotObj.id); } catch (e) {}
                        prev = slotObj.history.pop();
                    }
                    try { console.log('[history] pop:', { slotId: slotObj.id, prev, remaining: slotObj.history.length }); } catch (e) {}
                    try {
                        const prevCode = prev && typeof prev.code === 'string' ? prev.code : '';
                        const prevPrompt = prev && typeof prev.prompt === 'string' ? prev.prompt : '';

                        // If this is a TTS slot, ensure the sample is registered for the restored prompt
                        const rewriteTtsReferences = (code, sampleName) => {
                            if (!code || !sampleName) return code;
                            try {
                                return code.replace(/s\((['"])(.*?)\1\)/g, (m, q, inner) => {
                                    if (inner && inner.startsWith('tts')) {
                                        return `s("${sampleName}:0")`;
                                    }
                                    return m;
                                });
                            } catch (e) { return code; }
                        };

                        if (slotObj.category === 'tts') {
                            // Try to determine the prompt by reverse lookup from sample name in code
                            let promptToRestore = '';
                            let sampleNameFromCode = null;
                            // If history entry explicitly included a sampleName, prefer it
                            let historySampleName = prev && prev.sampleName ? prev.sampleName : '';
                            try {
                                const m = prevCode && prevCode.match(/s\((['"])([^'\"]+):\d+\1\)/);
                                if (m && m[2]) sampleNameFromCode = m[2];
                            } catch (e) { /* ignore */ }

                            // Use the sample name to reverse lookup the prompt
                            const sampleNameForLookup = historySampleName || sampleNameFromCode;
                            if (sampleNameForLookup) {
                                try {
                                    for (const [p, n] of Object.entries(ttsSampleNameByPrompt)) {
                                        if (n === sampleNameForLookup) { promptToRestore = p; break; }
                                    }
                                } catch (e) { /* ignore reverse lookup errors */ }
                            }
                            // Fallback to saved prompt if reverse lookup failed
                            if (!promptToRestore) {
                                promptToRestore = prevPrompt || '';
                            }

                            // helper to rewrite generic tts tokens to a concrete sample name
                            const rewriteTtsReferences = (code, sampleName) => {
                                if (!code || !sampleName) return code;
                                try {
                                    return code.replace(/s\((['"])(.*?)\1\)/g, (m, q, inner) => {
                                        if (inner && inner.startsWith('tts')) {
                                            return `s("${sampleName}:0")`;
                                        }
                                        return m;
                                    });
                                } catch (e) { return code; }
                            };

                            // If the history entry included an explicit sampleName, prefer restoring
                            // using that exact sample id (less brittle than regenerating by prompt).
                            if (historySampleName) {
                                try {
                                    const sampleName = historySampleName;
                                    // If prevCode already references this sampleName, keep it as-is.
                                    let restoredCode = prevCode;
                                    try {
                                        const contains = prevCode && prevCode.indexOf(sampleName) !== -1;
                                        if (!contains) {
                                            // rewrite only generic/legacy tts tokens to the concrete sampleName
                                            restoredCode = rewriteTtsReferences(prevCode, sampleName);
                                        }
                                    } catch (e) { /* ignore */ }

                                    slotObj.code = restoredCode;
                                    textarea.value = restoredCode;
                                    try { textarea.dataset.ttsSampleName = sampleName; } catch (e) {}
                                    try { slotObj.currentTtsSampleName = sampleName; } catch (e) {}
                                    // Always try reverse lookup for the correct prompt for this sample
                                    let promptToSet = '';
                                    try {
                                        for (const [p, n] of Object.entries(ttsSampleNameByPrompt)) {
                                            if (n === sampleName) { promptToSet = p; break; }
                                        }
                                    } catch (e) {}
                                    // Fallback to saved prompt if reverse lookup failed
                                    if (!promptToSet) {
                                        promptToSet = prevPrompt || '';
                                    }
                                    textarea.dataset.ttsText = promptToSet;
                                    try { if (slotPromptInput) slotPromptInput.value = promptToSet; } catch (e) {}

                                    if (typeof slotObj.id === 'number' && Array.isArray(slots)) {
                                        const idx = slots.findIndex(s => s.id === slotObj.id);
                                        if (idx !== -1) {
                                            slots[idx].code = restoredCode;
                                            console.log('[rewind] Updated slots[' + idx + '].code (by historySampleName):', slots[idx].code);
                                        }
                                    }

                                    slotObj._lastCommittedCode = slotObj.code;
                                    updateRewindButton();
                                    // ensure sample is registered if we have a prompt for it
                                    if (prevPrompt) {
                                        generateTTSSample(prevPrompt).then(() => {
                                            setTimeout(() => { if (!slotObj.isMuted) refreshPlayback(); }, 40);
                                        }).catch(() => { setTimeout(() => { if (!slotObj.isMuted) refreshPlayback(); }, 60); });
                                    } else {
                                        // no prompt available - play and hope the sample remains registered
                                        setTimeout(() => { if (!slotObj.isMuted) refreshPlayback(); }, 60);
                                    }
                                    try { scheduleSlotLifetime(slotObj); } catch (err) { console.warn('Could not schedule after rewind:', err); }
                                } catch (e) {
                                    console.warn('Rewind using history.sampleName failed:', e);
                                }
                            }
                            // If we have a prompt, (re)ensure the sample is registered and then restore.
                            else if (promptToRestore) {
                                try {
                                    generateTTSSample(promptToRestore).then((sampleName) => {
                                        try { console.log('[rewind] generateTTSSample returned sampleName:', sampleName); } catch (e) {}
                                        try {
                                            const rewritten = rewriteTtsReferences(prevCode, sampleName);
                                            slotObj.code = rewritten;
                                            try { console.log('[rewind] restored code for slot', slotObj.id, slotObj.code); } catch (e) {}
                                            textarea.value = rewritten;
                                            // record the restored sample name so UI and future history entries know
                                            try { textarea.dataset.ttsSampleName = sampleName; } catch (e) {}
                                            try { slotObj.currentTtsSampleName = sampleName; } catch (e) {}
                                            // Ensure global slots array is updated before playback
                                            if (typeof slotObj.id === 'number' && Array.isArray(slots)) {
                                                const idx = slots.findIndex(s => s.id === slotObj.id);
                                                if (idx !== -1) {
                                                    slots[idx].code = rewritten;
                                                    console.log('[rewind] Updated slots[' + idx + '].code:', slots[idx].code);
                                                }
                                            }
                                            // ensure dataset and visible prompt are synchronized
                                            textarea.dataset.ttsText = promptToRestore;
                                            try { if (slotPromptInput) slotPromptInput.value = promptToRestore; } catch (e) {}
                                            slotObj._lastCommittedCode = slotObj.code;
                                            updateRewindButton();
                                            // small delay to ensure sample registration is settled before playback
                                            setTimeout(() => { if (!slotObj.isMuted) refreshPlayback(); }, 60);
                                            try { scheduleSlotLifetime(slotObj); } catch (err) { console.warn('Could not schedule after rewind:', err); }
                                        } catch (e) {
                                            console.warn('Rewind TTS rewrite failed:', e);
                                        }
                                    }).catch(e => {
                                        console.warn('Failed to regenerate TTS during rewind:', e);
                                        // fallback to restoring raw code/prompt
                                        slotObj.code = prevCode;
                                        try { console.log('[rewind] restored code for slot', slotObj.id, slotObj.code); } catch (e) {}
                                        textarea.value = prevCode;
                                        if (typeof slotObj.id === 'number' && Array.isArray(slots)) {
                                            const idx = slots.findIndex(s => s.id === slotObj.id);
                                            if (idx !== -1) {
                                                slots[idx].code = prevCode;
                                                console.log('[rewind] Updated slots[' + idx + '].code:', slots[idx].code);
                                            }
                                        }
                                        // restore dataset & visible prompt
                                        try { textarea.dataset.ttsText = prevPrompt; } catch (e) {}
                                        try { if (slotPromptInput) slotPromptInput.value = prevPrompt; } catch (e) {}
                                        slotObj._lastCommittedCode = slotObj.code;
                                        updateRewindButton();
                                        setTimeout(() => { if (!slotObj.isMuted) refreshPlayback(); }, 60);
                                        try { scheduleSlotLifetime(slotObj); } catch (err) { console.warn('Could not schedule after rewind:', err); }
                                    });
                                } catch (e) {
                                    // if async regeneration fails, fall back to raw restore
                                    slotObj.code = prevCode;
                                    try { console.log('[rewind] restored code for slot', slotObj.id, slotObj.code); } catch (e) {}
                                    textarea.value = prevCode;
                                    if (typeof slotObj.id === 'number' && Array.isArray(slots)) {
                                        const idx = slots.findIndex(s => s.id === slotObj.id);
                                        if (idx !== -1) {
                                            slots[idx].code = prevCode;
                                            console.log('[rewind] Updated slots[' + idx + '].code:', slots[idx].code);
                                        }
                                    }
                                    try { if (slotPromptInput) slotPromptInput.value = prevPrompt; } catch (e) {}
                                    slotObj._lastCommittedCode = slotObj.code;
                                    updateRewindButton();
                                    if (!slotObj.isMuted) refreshPlayback();
                                    try { scheduleSlotLifetime(slotObj); } catch (err) { console.warn('Could not schedule after rewind:', err); }
                                }
                            } else if (sampleNameFromCode) {
                                // We don't have the original prompt text, but the code already references
                                // a concrete sample name. Restore using that sampleName and try to
                                // recover a visible prompt via reverse mapping if possible.
                                try {
                                    const rewritten = rewriteTtsReferences(prevCode, sampleNameFromCode);
                                    slotObj.code = rewritten;
                                    textarea.value = rewritten;
                                    try { textarea.dataset.ttsSampleName = sampleNameFromCode; } catch (e) {}
                                    try { slotObj.currentTtsSampleName = sampleNameFromCode; } catch (e) {}
                                    if (typeof slotObj.id === 'number' && Array.isArray(slots)) {
                                        const idx = slots.findIndex(s => s.id === slotObj.id);
                                        if (idx !== -1) {
                                            slots[idx].code = rewritten;
                                            console.log('[rewind] Updated slots[' + idx + '].code:', slots[idx].code);
                                        }
                                    }
                                    // attempt reverse lookup for a visible prompt
                                    let recoveredPrompt = '';
                                    try {
                                        for (const [p, n] of Object.entries(ttsSampleNameByPrompt)) {
                                            if (n === sampleNameFromCode) { recoveredPrompt = p; break; }
                                        }
                                    } catch (e) { /* ignore */ }
                                    textarea.dataset.ttsText = recoveredPrompt || '';
                                    try { if (slotPromptInput) slotPromptInput.value = recoveredPrompt || ''; } catch (e) {}
                                    slotObj._lastCommittedCode = slotObj.code;
                                    updateRewindButton();
                                    setTimeout(() => { if (!slotObj.isMuted) refreshPlayback(); }, 60);
                                    try { scheduleSlotLifetime(slotObj); } catch (err) { console.warn('Could not schedule after rewind:', err); }
                                } catch (e) {
                                    console.warn('Rewind restore with concrete sampleName failed:', e);
                                    // fallback to raw restore
                                    slotObj.code = prevCode;
                                    textarea.value = prevCode;
                                    try { if (slotPromptInput) slotPromptInput.value = prevPrompt; } catch (e) {}
                                    slotObj._lastCommittedCode = slotObj.code;
                                    updateRewindButton();
                                    if (!slotObj.isMuted) refreshPlayback();
                                    try { scheduleSlotLifetime(slotObj); } catch (err) { console.warn('Could not schedule after rewind:', err); }
                                }
                            } else {
                                // No prompt and no concrete sample name available; simple restore
                                slotObj.code = prevCode;
                                try { console.log('[rewind] restored code for slot', slotObj.id, slotObj.code); } catch (e) {}
                                textarea.value = prevCode;
                                if (typeof slotObj.id === 'number' && Array.isArray(slots)) {
                                    const idx = slots.findIndex(s => s.id === slotObj.id);
                                    if (idx !== -1) {
                                        slots[idx].code = prevCode;
                                        console.log('[rewind] Updated slots[' + idx + '].code:', slots[idx].code);
                                    }
                                }
                                try { if (slotPromptInput) slotPromptInput.value = prevPrompt; } catch (e) {}
                                slotObj._lastCommittedCode = slotObj.code;
                                updateRewindButton();
                                if (!slotObj.isMuted) refreshPlayback();
                                try { scheduleSlotLifetime(slotObj); } catch (err) { console.warn('Could not schedule after rewind:', err); }
                            }
                        } else {
                            // Non-TTS slot: simple restore
                            slotObj.code = prevCode;
                            try { console.log('[rewind] restored code for slot', slotObj.id, slotObj.code); } catch (e) {}
                            textarea.value = prevCode;
                            if (typeof slotObj.id === 'number' && Array.isArray(slots)) {
                                const idx = slots.findIndex(s => s.id === slotObj.id);
                                if (idx !== -1) {
                                    slots[idx].code = prevCode;
                                    console.log('[rewind] Updated slots[' + idx + '].code:', slots[idx].code);
                                }
                            }
                            try { if (slotPromptInput) slotPromptInput.value = prevPrompt; } catch (e) {}
                            slotObj._lastCommittedCode = slotObj.code;
                            updateRewindButton();
                            if (!slotObj.isMuted) refreshPlayback();
                            try { scheduleSlotLifetime(slotObj); } catch (err) { console.warn('Could not schedule after rewind:', err); }
                        }
                    } catch (e) {
                        console.warn('Rewind failed:', e);
                    }
                });

                // Prompt input Enter key handler - trigger dice roll
                slotPromptInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !dice.disabled) {
                        e.preventDefault();
                        dice.click();
                    }
                });

                // Drag and drop handlers
                dragHandle.addEventListener('dragstart', (e) => {
                    slotDiv.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', slotId);
                });

                dragHandle.addEventListener('dragend', () => {
                    slotDiv.classList.remove('dragging');
                    document.querySelectorAll('.slot').forEach(el => el.classList.remove('drag-over'));
                });

                slotDiv.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    const dragging = document.querySelector('.dragging');
                    if (dragging && dragging !== slotDiv) {
                        slotDiv.classList.add('drag-over');
                    }
                });

                slotDiv.addEventListener('dragleave', () => {
                    slotDiv.classList.remove('drag-over');
                });

                slotDiv.addEventListener('drop', (e) => {
                    e.preventDefault();
                    slotDiv.classList.remove('drag-over');

                    const draggedId = parseInt(e.dataTransfer.getData('text/plain'));
                    const draggedSlot = slots.find(s => s.id === draggedId);
                    const targetSlot = slots.find(s => s.id === slotId);

                    if (draggedSlot && targetSlot && draggedSlot !== targetSlot) {
                        // Reorder in array
                        const draggedIndex = slots.indexOf(draggedSlot);
                        const targetIndex = slots.indexOf(targetSlot);

                        slots.splice(draggedIndex, 1);
                        slots.splice(targetIndex, 0, draggedSlot);

                        // Reorder in DOM
                        slotsGrid.innerHTML = '';
                        slots.forEach(slot => slotsGrid.appendChild(slot.element));

                        refreshPlayback();
                    }
                });

                return slotObj;
            };

            // Create add layer buttons for each category
            slotCategories.forEach(category => {
                const addBtn = document.createElement('button');
                addBtn.className = 'add-slot-btn';
                addBtn.style.setProperty('--category-color', category.color);

                const emoji = document.createElement('div');
                emoji.className = 'add-slot-btn-emoji';
                emoji.textContent = category.icon;

                const label = document.createElement('div');
                label.className = 'add-slot-btn-label';
                label.textContent = category.desc;

                addBtn.appendChild(emoji);
                addBtn.appendChild(label);
                addBtn.title = `Add ${category.desc} layer`;

                addBtn.addEventListener('click', () => {
                    const slot = createSlot(category.name);
                    slots.push(slot);
                    slotsGrid.appendChild(slot.element);
                    updateStatus();
                });

                addSlotContainer.appendChild(addBtn);
            });

            // Update status message
            const updateStatus = () => {
                const activeCount = slots.filter(s => !s.isMuted && s.code).length;
                statusEl.textContent = `${slots.length} layers (${activeCount} active)${sampleStatusSuffix}`;
            };

            masterVolumeSlider.addEventListener('input', () => {
                masterVolume = parseFloat(masterVolumeSlider.value);
                refreshPlayback();
            });

            masterReverbSlider.addEventListener('input', () => {
                masterReverb = parseFloat(masterReverbSlider.value);
                refreshPlayback();
            });

            if (creativitySlider) {
                creativitySlider.addEventListener('input', () => {
                    creativity = parseFloat(creativitySlider.value);
                    // Update status briefly to reflect change
                    statusEl.textContent = `Creativity: ${Math.round(creativity * 100)}%`;
                    setTimeout(() => updateStatus(), 900);
                });
            }

            const refreshPlayback = () => {
                if (!schedulerApi) {
                    console.warn('Scheduler is not ready yet.');
                    return;
                }

                // Collect all unmuted slots with code
                const activePatterns = [];
                slots.forEach((slot, index) => {
                    if (!slot.isMuted && slot.code) {
                        try {
                            console.log(`Evaluating slot ${slot.id} (${slot.category}):`, slot.code);
                            const pattern = eval(slot.code);
                            console.log(`Slot ${slot.id} pattern:`, pattern);
                            activePatterns.push(pattern);
                        } catch (e) {
                            console.error(`Error evaluating slot ${slot.id}:`, e);
                            console.error('Code was:', slot.code);
                        }
                    }
                });

                if (activePatterns.length === 0) {
                    // Try to pause the transport instead of stopping completely
                    if (schedulerApi?.pause) {
                        schedulerApi.pause();
                    } else if (typeof window.pause === 'function') {
                        window.pause();
                    } else if (schedulerApi?.hush) {
                        schedulerApi.hush();
                    } else if (typeof window.hush === 'function') {
                        window.hush();
                    }
                    updateStatus();
                    return;
                }

                // Stack all active patterns together
                let mixedPattern = stack(...activePatterns);

                // Apply master controls
                if (masterVolume !== 1) {
                    mixedPattern = mixedPattern.gain(masterVolume);
                }

                if (masterReverb > 0) {
                    mixedPattern = mixedPattern.room(masterReverb);
                }

                try {
                    if (schedulerApi?.setPattern) {
                        schedulerApi.setPattern(mixedPattern, false);
                    } else {
                        mixedPattern.play();
                    }
                } catch (e) {
                    console.error('Error setting pattern:', e);
                }

                updateStatus();

                // If audio is playing (or we've just engaged playback), ensure any
                // slots with pending lifetimeBars start their countdowns. We only
                // start timers when the transport appears to be playing so that
                // lifetimes don't tick down while the system is idle.
                const playing = isTransportPlaying();
                if (playing) {
                    slots.forEach(s => {
                        try {
                            if (!s) return;
                            if (s.pinned) return;
                            // If a slot has lifetimeBars set but no active timer, schedule it
                            if ((typeof s.lifetimeBars === 'number') && !s.lifetimeTimer) {
                                // schedule with remaining bars if expiresAt present
                                try { scheduleSlotLifetime(s); } catch (err) { /* ignore */ }
                            }
                        } catch (e) {}
                    });
                }
            };

            // Enable prompt inputs when AI model is ready
            if (extractor) {
                // AI is ready, users can add slots
            }

            stopDiceAnimation();
            updateLoadingProgress('All systems ready!');
            statusEl.textContent = `Ready! ${sampleStatusSuffix}`;

            // Hide loading screen with a slight delay
            setTimeout(() => {
                loadingScreen.classList.add('hidden');
            }, 500);

            // Pre-warm TTS samples in the background (optional)
            // This helps avoid audio freezing during playback
            // Uncomment the next line to enable:
            // preWarmTTS();

        })().catch((error) => {
            console.error('Strudel init failed', error);
            const statusEl = document.getElementById('status');
            const loadingProgress = document.getElementById('loading-progress');
            const loadingScreen = document.getElementById('loading-screen');

            loadingProgress.textContent = '❌ Failed to load. Check console for details.';
            statusEl.textContent = 'Could not load Strudel. Please check the console for details.';

            // Still hide loading screen after error
            setTimeout(() => {
                loadingScreen.classList.add('hidden');
            }, 3000);
        });
    </script>
</body>

</html>