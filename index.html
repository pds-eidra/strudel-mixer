<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Strudel Layer Mixer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        :root {
            color-scheme: light dark;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            background: #f0f2f5;
            color: #1c1c1c;
            padding: 1rem;
        }

        @media (prefers-color-scheme: dark) {
            body {
                background: #0f1115;
                color: #e6e9ef;
            }
        }

        header {
            padding: 1rem;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 1rem;
        }

        @media (prefers-color-scheme: dark) {
            header {
                background: rgba(24, 26, 32, 0.85);
            }
        }

        .header-main {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 2rem;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            letter-spacing: -0.02em;
        }

        .header-controls {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: flex-start;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            min-width: 0; /* allow children to shrink in tight containers */
        }

        /* Ensure the label and slider are consistently laid out:
           - label keeps a predictable width so long labels don't push the slider
           - slider uses flex so all sliders visually match regardless of surrounding text */
        .control-group > .control-label {
            flex: 0 0 110px; /* fixed label column width (adjustable) */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .control-group > .control-slider {
            flex: 1 1 200px; /* slider will take remaining space but stay consistent */
            width: auto; /* allow flexbox to control width */
            min-width: 120px;
            max-width: 420px;
        }

        .control-label {
            font-size: 0.85rem;
            opacity: 0.7;
            font-weight: 500;
        }

        .control-input {
            padding: 0.4rem 0.6rem;
            font-size: 0.9rem;
            border-radius: 6px;
            border: 2px solid rgba(0, 0, 0, 0.2);
            background: rgba(255, 255, 255, 0.7);
            color: inherit;
            font-weight: 500;
            width: 70px;
            text-align: center;
        }

        @media (prefers-color-scheme: dark) {
            .control-input {
                background: rgba(255, 255, 255, 0.1);
                border-color: rgba(255, 255, 255, 0.2);
            }
        }

        .control-input:focus {
            outline: 2px solid currentColor;
            outline-offset: 1px;
        }

        .control-slider {
            width: 120px;
            height: 6px;
            border-radius: 3px;
            background: rgba(0, 0, 0, 0.2);
            outline: none;
            appearance: none;
            -webkit-appearance: none;
        }

        @media (prefers-color-scheme: dark) {
            .control-slider {
                background: rgba(255, 255, 255, 0.2);
            }
        }

        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: currentColor;
            cursor: pointer;
            transition: transform 150ms ease;
        }

        .control-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .control-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: currentColor;
            cursor: pointer;
            border: none;
            transition: transform 150ms ease;
        }

        .control-slider::-moz-range-thumb:hover {
            transform: scale(1.2);
        }

        /* Loading screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 500ms ease, visibility 500ms ease;
        }

        @media (prefers-color-scheme: dark) {
            .loading-screen {
                background: #0f1115;
            }
        }

        .loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .loading-content {
            text-align: center;
            color: #1c1c1c;
        }

        @media (prefers-color-scheme: dark) {
            .loading-content {
                color: #e6e9ef;
            }
        }

        .loading-title {
            font-size: 3rem;
            font-weight: 700;
            margin: 0 0 1rem 0;
            letter-spacing: -0.02em;
        }

        .loading-subtitle {
            font-size: 1.2rem;
            opacity: 0.7;
            margin: 0 0 3rem 0;
            font-weight: 400;
        }

        .loading-dice {
            font-size: 5rem;
            margin: 0 auto 2rem;
            user-select: none;
            font-weight: 300;
        }

        .loading-progress {
            font-size: 0.9rem;
            opacity: 0.8;
            font-weight: 500;
            min-height: 1.5rem;
        }

        @keyframes rollDice {
            0% {
                transform: rotate(0deg) scale(1);
            }

            10% {
                transform: rotate(90deg) scale(1.05);
            }

            20% {
                transform: rotate(180deg) scale(1);
            }

            30% {
                transform: rotate(270deg) scale(1.05);
            }

            40% {
                transform: rotate(360deg) scale(1);
            }

            50% {
                transform: rotate(405deg) scale(1.02);
            }

            55% {
                transform: rotate(420deg) scale(1);
            }

            60% {
                transform: rotate(360deg) scale(1);
            }

            100% {
                transform: rotate(360deg) scale(1);
            }
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.05);
                opacity: 0.9;
            }
        }

        .header-main {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 2rem;
        }

        .add-slot-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 100px));
            gap: 1.25rem;
            padding: 0.75rem;
            border-radius: 8px;
            min-width: 750px;
        }



        .add-slot-btn {
            aspect-ratio: 1;
            padding: 0.5rem;
            font-size: 0.85rem;
            border: 2px solid var(--category-color);
            border-radius: 12px;
            cursor: pointer;
            transition: all 200ms ease;
            background: var(--category-color);
            color: inherit;
            font-weight: 600;
            opacity: 0.8;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            text-align: center;
        }

        .add-slot-btn-emoji {
            font-size: 2rem;
            line-height: 1;
            font-weight: 300;
        }

        .add-slot-btn-label {
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: capitalize;
        }

        .add-slot-btn:hover {
            opacity: 1;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .slot-type-picker {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            animation: slideIn 200ms ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .slot-type-option {
            padding: 0.5rem 1rem;
            border: 2px solid var(--category-color);
            background: var(--category-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 200ms ease;
            font-size: 0.9rem;
            font-weight: 500;
            opacity: 0.7;
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .slot-type-option:hover {
            opacity: 1;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .prompt-input {
            padding: 0.5rem 1rem;
            font-size: 0.95rem;
            border-radius: 8px;
            border: 2px solid currentColor;
            background: rgba(255, 255, 255, 0.5);
            color: inherit;
            font-weight: 500;
            min-width: 300px;
            flex: 1;
        }

        @media (prefers-color-scheme: dark) {
            .prompt-input {
                background: rgba(255, 255, 255, 0.1);
            }
        }

        .prompt-input::placeholder {
            opacity: 0.5;
        }

        .slot-prompt {
            flex: 1;
            padding: 0.4rem 0.6rem;
            font-size: 0.75rem;
            border-radius: 6px;
            border: 1px solid rgba(0, 0, 0, 0.2);
            background: rgba(255, 255, 255, 0.7);
            color: inherit;
            font-weight: 400;
            min-width: 0;
        }

        @media (prefers-color-scheme: dark) {
            .slot-prompt {
                background: rgba(255, 255, 255, 0.05);
                border-color: rgba(255, 255, 255, 0.2);
            }
        }

        .slot-prompt::placeholder {
            opacity: 0.5;
        }

        .slot-prompt:focus {
            outline: 2px solid currentColor;
            outline-offset: 1px;
        }

        .slot-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            flex-wrap: wrap;
        }

        .status {
            font-size: 0.85rem;
            opacity: 0.7;
        }

        .slots-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(450px, 1fr));
            gap: 0.5rem;
            flex: 1;
        }

        .slot {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            transition: all 300ms ease;
            border-left: 4px solid var(--slot-color);
            position: relative;
            animation: slotAppear 300ms ease-out;
        }

        @keyframes slotAppear {
            from {
                opacity: 0;
                transform: translateX(-20px) scale(0.95);
            }

            to {
                opacity: 1;
                transform: translateX(0) scale(1);
            }
        }

        @keyframes slotDisappear {
            to {
                opacity: 0;
                transform: translateX(20px) scale(0.95);
            }
        }

        .slot.removing {
            animation: slotDisappear 300ms ease-out forwards;
        }

        @media (prefers-color-scheme: dark) {
            .slot {
                background: rgba(24, 26, 32, 0.85);
            }
        }

        /* When a slot is muted we want the slot content to appear dimmed/greyed,
       but keep the unmute button fully visible and clickable. Avoid using
       `opacity` on the parent because that also fades children. Instead
       render a semi-opaque overlay and dim specific content. */
        .slot.is-muted {
            transform: scale(0.98);
            /* create stacking context for overlay and controls */
            position: relative;
        }

        /* soft overlay that greys/dims the slot content but sits under header controls */
        .slot.is-muted::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 12px;
            pointer-events: none;
            z-index: 1;
            /* under controls which will be z-index:2+ */
            /* Use the slot color as the base for the overlay (rgb provided by JS).
         Fallback to white for light mode if the RGB variable isn't present. */
            background: rgba(var(--slot-color-rgb, 255, 255, 255), 0.18);
            mix-blend-mode: luminosity;
            transition: background 200ms ease, opacity 200ms ease;
        }

        /* dim code and decorative emoji more aggressively */
        .slot.is-muted .slot-code,
        .slot.is-muted .slot-code-emoji,
        .slot.is-muted .slot-prompt {
            opacity: 0.35;
        }

        /* ensure interactive controls remain clearly visible above the overlay */
        .slot .slot-mute-btn,
        .slot .slot-delete-btn,
        .slot .slot-dice,
        .slot .slot-spice {
            position: relative;
            z-index: 3;
        }

        @media (prefers-color-scheme: dark) {

            /* use a darker overlay in dark mode so the dimming feels natural */
            .slot.is-muted::after {
                /* For dark mode, use a stronger tint from the slot color, falling back
           to a near-black if the variable isn't present. This avoids pure black
           while still providing sufficient dimming. */
                background: rgba(var(--slot-color-rgb, 10, 12, 16), 0.30);
                mix-blend-mode: normal;
            }
        }

        .slot-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            gap: 0.5rem;
        }

        .slot-mute-btn {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            border: 2px solid var(--slot-color);
            background: var(--slot-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 200ms ease;
            opacity: 0.9;
            flex-shrink: 0;
        }

        .slot-mute-btn:hover {
            opacity: 1;
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        /* When the slot is muted the button will usually toggle to an "unmute"
       state; keep it fully visible and obvious so the user can unmute quickly. */
        .slot-mute-btn.is-muted {
            opacity: 1;
            background: var(--slot-color);
            color: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: scale(1.05);
            border-color: rgba(0, 0, 0, 0.12);
        }

        .slot-delete-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid rgba(255, 80, 80, 0.8);
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 200ms ease;
            opacity: 0.4;
            color: rgba(255, 80, 80, 0.9);
        }

        .slot-delete-btn:hover {
            opacity: 1;
            transform: scale(1.1) rotate(90deg);
            background: rgba(255, 80, 80, 0.2);
        }

        .slot-color-indicator {
            display: none;
        }

        .slot-reload {
            display: none;
        }

        .slot-dice,
        .slot-spice {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            border: 2px solid currentColor;
            background: transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            line-height: 1;
            transition: transform 200ms ease, background 200ms ease;
            opacity: 0.7;
            flex-shrink: 0;
            padding: 0;
        }

        .slot-dice:hover,
        .slot-spice:hover {
            opacity: 1;
            background: rgba(0, 0, 0, 0.05);
            transform: scale(1.15);
        }

        @media (prefers-color-scheme: dark) {

            .slot-dice:hover,
            .slot-spice:hover {
                background: rgba(255, 255, 255, 0.1);
            }
        }

        .slot-dice:active,
        .slot-spice:active {
            transform: scale(0.95) rotate(360deg);
        }

        .slot-dice:disabled,
        .slot-spice:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .slot-dice.rolling,
        .slot-spice.spicing {
            opacity: 1 !important;
            pointer-events: none;
            font-size: 1.5rem;
            line-height: 1;
            animation: diceSpinCycle 0.4s ease-in-out infinite;
        }

        .slot-spice {
            border-color: currentColor;
        }

        @media (prefers-color-scheme: dark) {
            .slot-spice {
                border-color: currentColor;
            }
        }

        @keyframes diceSpinCycle {
            0% {
                transform: scale(1) rotate(0deg);
            }

            50% {
                transform: scale(1.2) rotate(180deg);
            }

            100% {
                transform: scale(1) rotate(360deg);
            }
        }

        .slot-code-wrapper {
            flex: 1;
            position: relative;
            display: flex;
        }

        .slot-code-emoji {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12rem;
            opacity: 0.12;
            pointer-events: none;
            z-index: 0;
            user-select: none;
            font-weight: 300;
        }

        .slot-code {
            flex: 1;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.8rem;
            line-height: 1.5;
            padding: 0.75rem;
            border: 1px solid rgba(0, 0, 0, 0.15);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.03);
            color: inherit;
            resize: vertical;
            min-height: 80px;
            position: relative;
            z-index: 1;
        }

        @media (prefers-color-scheme: dark) {
            .slot-code {
                background: rgba(0, 0, 0, 0.3);
                border-color: rgba(255, 255, 255, 0.15);
            }

            .slot-code-emoji {
                opacity: 0.1;
            }
        }

        .slot-code:focus {
            outline: 2px solid currentColor;
            outline-offset: 2px;
        }

        .slot-code::placeholder {
            opacity: 0.4;
            font-style: italic;
        }

        .slot.is-empty .slot-code {
            opacity: 0.5;
        }

        @keyframes flashBorder {

            0%,
            100% {
                border-color: rgba(0, 0, 0, 0.15);
                box-shadow: 0 0 0 0 currentColor;
            }

            50% {
                border-color: currentColor;
                box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.3);
            }
        }

        @media (prefers-color-scheme: dark) {
            @keyframes flashBorder {

                0%,
                100% {
                    border-color: rgba(255, 255, 255, 0.15);
                    box-shadow: 0 0 0 0 currentColor;
                }

                50% {
                    border-color: currentColor;
                    box-shadow: 0 0 0 3px rgba(100, 200, 255, 0.3);
                }
            }
        }

        .slot-code.flash {
            animation: flashBorder 400ms ease-out;
        }

        @media (min-width: 1200px) {
            /* Removed grid layout - using flexbox column instead */
        }

        @media (min-width: 768px) and (max-width: 1199px) {
            /* Removed grid layout - using flexbox column instead */
        }

        /* Drag handle styling */
        .slot-drag-handle {
            cursor: grab;
            padding: 0.25rem;
            opacity: 0.4;
            transition: opacity 200ms ease;
            font-size: 1.2rem;
            user-select: none;
        }

        .slot-drag-handle:hover {
            opacity: 0.8;
        }

        .slot-drag-handle:active {
            cursor: grabbing;
        }

        .slot.dragging {
            opacity: 0.5;
            transform: scale(1.05);
        }

        .slot.drag-over {
            border-top: 3px solid var(--slot-color);
        }
    </style>
</head>

<body>
    <div class="loading-screen" id="loading-screen">
        <div class="loading-content">
            <div class="loading-title">Strudel Mixer</div>
            <div class="loading-subtitle">Preparing your musical playground...</div>
            <div class="loading-dice" id="loading-dice">⚀</div>
            <div class="loading-progress" id="loading-progress">Initializing...</div>
        </div>
    </div>

    <header>
        <div class="header-main">
            <h1>Strudel<br>Mixer</h1>
            <div class="add-slot-container" id="add-slot-container">
                <!-- Layer type buttons will be generated by JavaScript -->
            </div>
            <div class="header-controls">
                <div class="control-group">
                    <label class="control-label" for="master-volume">Volume:</label>
                    <input type="range" id="master-volume" class="control-slider" min="0" max="1" step="0.01"
                        value="0.7">
                </div>
                <div class="control-group">
                    <label class="control-label" for="master-reverb">Reverb:</label>
                    <input type="range" id="master-reverb" class="control-slider" min="0" max="1" step="0.05" value="0">
                </div>
                <div class="control-group">
                    <label class="control-label" for="creativity">Creativity:</label>
                    <input type="range" id="creativity" class="control-slider" min="0" max="1" step="0.01" value="0.66">
                </div>
                <div id="status" class="status">Preparing Strudel…</div>
            </div>
        </div>
    </header>

    <div class="slots-grid" id="slots-grid">
        <!-- Slots will be generated dynamically by JavaScript -->
    </div>

    <script type="module" src="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2"></script>
    <script src="https://unpkg.com/@strudel/web@1.0.3"></script>
    <script type="module">
        // Import Transformers.js
        import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2';

        // Disable local model loading
        env.allowLocalModels = false;

        (async () => {
            const statusEl = document.getElementById('status');
            const slotsGrid = document.getElementById('slots-grid');
            const addSlotContainer = document.getElementById('add-slot-container');
            const masterVolumeSlider = document.getElementById('master-volume');
            const masterReverbSlider = document.getElementById('master-reverb');
            const creativitySlider = document.getElementById('creativity');
            const loadingScreen = document.getElementById('loading-screen');
            const loadingProgress = document.getElementById('loading-progress');
            const loadingDice = document.getElementById('loading-dice');
            const slots = []; // Will hold slot data dynamically
            let slotIdCounter = 0; // Unique ID for each slot
            let masterVolume = 0.7;
            let masterReverb = 0;
            let creativity = 0.7; // 0 = deterministic, 1 = most creative/random

            // Dice animation for loading screen
            const diceFaces = ['⚀', '⚁', '⚂', '⚃', '⚄', '⚅'];
            let diceIndex = 0;
            let diceInterval = null;

            const startDiceAnimation = () => {
                if (diceInterval) return;
                diceInterval = setInterval(() => {
                    diceIndex = (diceIndex + 1) % diceFaces.length;
                    if (loadingDice) {
                        loadingDice.textContent = diceFaces[diceIndex];
                    }
                }, 200);
            };

            const stopDiceAnimation = () => {
                if (diceInterval) {
                    clearInterval(diceInterval);
                    diceInterval = null;
                }
            };

            startDiceAnimation();

            // Function to animate dice rolling on a button - cycles through faces while busy
            const animateDiceRoll = (button, callback, animationType = 'rolling') => {
                const diceFaces = ['⚀', '⚁', '⚂', '⚃', '⚄', '⚅'];
                const spiceFaces = ['✦', '✧', '⚛', '※', '⁂', '❋'];

                const faces = animationType === 'spicing' ? spiceFaces : diceFaces;
                let faceIndex = 0;

                button.disabled = true;
                button.classList.add(animationType);

                // Cycle through faces in order, repeating continuously
                const rollInterval = setInterval(() => {
                    button.innerHTML = faces[faceIndex];
                    faceIndex = (faceIndex + 1) % faces.length; // Loop back to start
                }, 400); // Match the animation duration

                // Execute callback and stop animation when done
                if (callback) {
                    callback().finally(() => {
                        clearInterval(rollInterval);
                        // Pick a final random face to land on
                        const finalFace = faces[Math.floor(Math.random() * faces.length)];
                        button.innerHTML = finalFace;
                        button.classList.remove(animationType);
                        button.disabled = false;
                    });
                }
            };

            // Loading progress messages
            const updateLoadingProgress = (message) => {
                loadingProgress.textContent = message;
            };

            // Load the semantic similarity model (using efficient smaller model for faster loading)
            updateLoadingProgress('Loading AI model...');
            statusEl.textContent = 'Loading AI model...';
            let extractor = null;
            let patternEmbeddingsCache = null; // Cache for pre-computed pattern embeddings

            try {
                // Using all-MiniLM-L6-v2: efficient model (22M params) for fast loading and good semantic understanding
                // Much smaller than all-mpnet-base-v2 (420M) while maintaining strong performance
                extractor = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
                console.log('AI model loaded successfully');
                updateLoadingProgress('AI model ready ✓');
            } catch (e) {
                console.error('Failed to load AI model:', e);
                updateLoadingProgress('AI model failed (continuing without AI features)');
            }

            // TTS Web Worker - using module worker to avoid blocking the main thread
            let ttsWorker = null;
            let ttsWorkerReady = false;
            const ttsWorkerPromises = new Map();
            let ttsRequestId = 0;

            const initTTSWorker = async () => {
                if (ttsWorker) return ttsWorker;

                // Create a module worker that can use ES imports
                const workerCode = `
          import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2';
          
          // Disable local model loading
          env.allowLocalModels = false;
          
          let model = null;
          
          self.onmessage = async function(e) {
            const { id, type, text } = e.data;
            
            try {
              if (type === 'init') {
                console.log('[Worker] Loading TTS model...');
                model = await pipeline('text-to-speech', 'Xenova/speecht5_tts', { quantized: false });
                console.log('[Worker] TTS model loaded!');
                self.postMessage({ id, type: 'ready' });
              } else if (type === 'generate') {
                if (!model) {
                  throw new Error('Model not initialized');
                }
                
                console.log('[Worker] Generating speech for:', text);
                const result = await model(text, {
                  speaker_embeddings: 'https://huggingface.co/datasets/Xenova/transformers.js-docs/resolve/main/speaker_embeddings.bin'
                });
                
                console.log('[Worker] Speech generated!');
                self.postMessage({
                  id,
                  type: 'result',
                  audio: Array.from(result.audio),
                  sampling_rate: result.sampling_rate
                });
              }
            } catch (error) {
              console.error('[Worker] Error:', error);
              self.postMessage({
                id,
                type: 'error',
                message: error.message
              });
            }
          };
        `;

                // Create a blob URL with module type
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                const workerUrl = URL.createObjectURL(blob);

                try {
                    // Create module worker
                    ttsWorker = new Worker(workerUrl, { type: 'module' });

                    ttsWorker.onmessage = (e) => {
                        const { id, type } = e.data;

                        if (type === 'ready') {
                            ttsWorkerReady = true;
                            console.log('TTS Worker ready!');
                            if (ttsWorkerPromises.has(id)) {
                                ttsWorkerPromises.get(id).resolve();
                                ttsWorkerPromises.delete(id);
                            }
                        } else if (type === 'result') {
                            if (ttsWorkerPromises.has(id)) {
                                ttsWorkerPromises.get(id).resolve(e.data);
                                ttsWorkerPromises.delete(id);
                            }
                        } else if (type === 'error') {
                            if (ttsWorkerPromises.has(id)) {
                                ttsWorkerPromises.get(id).reject(new Error(e.data.message));
                                ttsWorkerPromises.delete(id);
                            }
                        }
                    };

                    ttsWorker.onerror = (error) => {
                        console.error('TTS Worker error:', error);
                    };

                    // Initialize the worker (load model)
                    console.log('Initializing TTS worker...');
                    const initId = ttsRequestId++;
                    await new Promise((resolve, reject) => {
                        ttsWorkerPromises.set(initId, { resolve, reject });
                        ttsWorker.postMessage({ id: initId, type: 'init' });
                    });

                    return ttsWorker;
                } catch (e) {
                    console.error('Failed to create TTS worker:', e);
                    throw e;
                }
            };

            // Generate TTS using the worker
            const generateTTSAudio = async (text) => {
                if (!ttsWorker) {
                    await initTTSWorker();
                }

                const id = ttsRequestId++;
                const result = await new Promise((resolve, reject) => {
                    ttsWorkerPromises.set(id, { resolve, reject });
                    ttsWorker.postMessage({ id, type: 'generate', text });
                });

                return {
                    audio: result.audio,
                    sampling_rate: result.sampling_rate
                };
            };

            // Pre-generate some common TTS samples to avoid blocking during playback
            // This happens in the background after page load
            const preWarmTTS = async () => {
                try {
                    await new Promise(resolve => setTimeout(resolve, 3000)); // Wait 3s after load
                    console.log('Pre-generating TTS samples...');
                    const commonPhrases = [];
                    for (const phrase of commonPhrases) {
                        await generateTTSSample(phrase, 'tts');
                        await new Promise(resolve => setTimeout(resolve, 500)); // Small delay between
                    }
                    console.log('TTS samples pre-generated and ready!');
                } catch (e) {
                    console.log('TTS pre-warming skipped:', e.message);
                }
            };

            // Define slot categories for complementary layering
            const slotCategories = [
                { name: 'drums', icon: '◆', desc: 'Drums & Percussion', color: '#E63946' },
                { name: 'bass', icon: '▬', desc: 'Bass & Low End', color: '#457B9D' },
                { name: 'melody', icon: '◇', desc: 'Melodic Elements', color: '#A8DADC' },
                { name: 'chords', icon: '●', desc: 'Chords & Harmony', color: '#F4A261' },
                { name: 'texture', icon: '○', desc: 'Texture & FX', color: '#2A9D8F' },
                { name: 'tts', icon: '◼', desc: 'Speech', color: '#E9C46A' }
            ];

            // Pattern library with natural language descriptions focused on feelings, moods, and vibes
            const patternLibrary = {
                drums: [
                    { desc: "energetic dance party feel with steady driving beat, happy uplifting groove perfect for dancing and celebration, pumping four on the floor rhythm", code: 's("bd*4, ~ cp, [~ hh]*4, hh(3,8)").gain(0.8).room(0.2)', literal: "four-on-floor kick, clap on 2 and 4, continuous hi-hats, euclidean hi-hat pattern", tempo: "fast", density: "high", energy: "high", mood: "happy" },
                    { desc: "quirky offbeat rhythm, playful and unexpected syncopation, fun bouncy feeling with scattered hits", code: 's("bd(3,8), [~ sd] ~ sd").gain(0.7).room(0.3)', literal: "euclidean kick pattern, syncopated snare with rest, sparse placement", tempo: "medium", density: "low", energy: "medium", mood: "playful" },
                    { desc: "sleek modern minimal vibe, clean precise hits, futuristic robot-like precision, cold mechanical energy", code: 's("bd*4, [~ cp]*2, hh*8").gain("0.9 0.75 0.35").room(0.15)', literal: "steady quarter note kicks, half-time claps, eighth note hi-hats, varying gain", tempo: "fast", density: "medium", energy: "medium", mood: "cool" },
                    { desc: "intense fast chaotic energy, aggressive rapid fire drums, frantic rushed feeling, high intensity adrenaline jungle rhythm", code: 's("[bd [bd bd?0.4], [~ sd] ~ sd, [hh!3 hh*3]/4]").fast(2).gain(0.8)', literal: "nested kick patterns with probability, doubled tempo, layered snare and hi-hats", tempo: "very fast", density: "very high", energy: "very high", mood: "aggressive" },
                    { desc: "smooth sophisticated jazz lounge atmosphere, relaxed classy evening feel, elegant swinging rhythm, vintage cocktail bar mood", code: 's("[~ ~ hh]*4").speed("<1 1.15>*4").gain(perlin.range(0.25,0.5)).stack(s("bd(3,8)").gain(0.5), s("~ cp").gain(0.4))', literal: "swung hi-hats with speed variation, euclidean kick, backbeat clap, perlin noise dynamics", tempo: "medium", density: "medium", energy: "low", mood: "sophisticated" },
                    { desc: "lazy chill afternoon vibes, relaxed nostalgic feeling, mellow downtempo groove, cozy bedroom production aesthetic", code: 's("bd ~ ~ sd").slow(2).stack(s("[~ hh]*4").degradeBy(0.3)).gain(0.7).lpf(2000)', literal: "half-tempo kick-snare pattern, degraded hi-hats, low-pass filtered, sparse", tempo: "slow", density: "low", energy: "low", mood: "relaxed" },
                    { desc: "powerful aggressive angry intense dark industrial pounding, harsh mechanical dystopian energy, brutal heavy hitting", code: 's("bd*4").gain(0.95).distort(0.3).hcutoff(200)', literal: "continuous quarter note kicks, distorted, high-cut filtered, loud gain", tempo: "fast", density: "high", energy: "very high", mood: "aggressive" },
                    { desc: "spacious peaceful calm meditative atmosphere, gentle sparse hits, quiet contemplative mood, serene floating ethereal percussion", code: 's("bd(3,8), ~ rm(2,8)").gain(0.6).room(0.9).delay(0.5)', literal: "euclidean kick and rim patterns, heavy reverb, delayed, sparse quiet hits", tempo: "slow", density: "very low", energy: "very low", mood: "peaceful" },
                    { desc: "groovy funky danceable rhythm, playful bouncy feel good energy, infectious head-nodding beat with swagger", code: 's("bd ~ bd ~, ~ cp ~ [cp cp?0.3], [hh hh?0.5]*4").gain(0.75).room(0.25)', literal: "syncopated kick pattern, clap with probability variations, probabilistic hi-hats", tempo: "medium", density: "medium", energy: "medium", mood: "groovy" },
                    { desc: "exotic worldly mystical tribal ceremony, ancient primal rhythms, spiritual hypnotic trance-inducing polyrhythmic patterns", code: 's("bd(5,8), perc(7,12)").n(irand(8)).gain(0.7).room(0.4)', literal: "5/8 euclidean kick, 7/12 percussion pattern, random sample selection, polyrhythmic", tempo: "medium", density: "high", energy: "medium", mood: "mystical" },
                    { desc: "old school hip hop nostalgic 90s breakbeat, classic vintage sample feel, authentic rough textured street beats", code: 's("amen").speed(1.2).gain(0.8).room(0.2)', literal: "amen break, slightly sped up, dry room, classic break", tempo: "medium", density: "high", energy: "medium", mood: "nostalgic" },
                    { desc: "warm organic natural acoustic drum kit, human live performance feel, realistic intimate drummer playing, authentic studio recording", code: 's("drum").n("0 ~ 2 ~").speed(0.9).gain(0.75).room(0.3)', literal: "acoustic drum samples, alternating hits with rests, slightly slowed, natural room", tempo: "medium", density: "low", energy: "medium", mood: "warm" },
                    { desc: "raw rebellious grunge rock energy, distorted gritty 90s alternative feel, angsty teenage rebellion mood", code: 's("drum").n("[0 1]*2").speed(rand.range(0.95,1.05)).gain(0.8).distort(0.2)', literal: "repeated drum hits, random speed variations, distorted, gritty texture", tempo: "medium", density: "medium", energy: "high", mood: "rebellious" },
                    { desc: "retro 80s electronic hip hop vibe, classic drum machine nostalgia, vintage synthesized beats, old school rap production", code: 's("bd*4, ~ sd ~, [hh hh?0.5]*4").gain(0.85).room(0.1).lpf(1200)', literal: "four-on-floor kick, backbeat snare, probabilistic hi-hats, low-passed vintage sound", tempo: "medium", density: "medium", energy: "medium", mood: "retro" },
                    { desc: "spiritual sacred eastern meditation rhythm, peaceful zen traditional instruments, cultural authentic world music percussion", code: 's("tabla:0 ~ tabla:1 tabla:2").speed("<1 0.95 1.05>*4").gain(0.7).room(0.5)', literal: "tabla pattern with specific articulations, varying speed, reverberant space", tempo: "medium", density: "medium", energy: "low", mood: "spiritual" },
                    { desc: "explosive trap hi-hat rolls, modern hip hop energy, rapid machine gun triplets, aggressive urban street beats", code: 's("bd ~ sd ~, [hh!16]/4").sometimes(x=>x.ply(3)).gain(0.8).room(0.1).hcutoff(10000)', literal: "basic kick-snare pattern, 16th note hi-hat rolls, occasional triplets, bright filtered", tempo: "medium", density: "very high", energy: "high", mood: "aggressive" },
                    { desc: "stuttering glitchy breakcore, chaotic digital destruction, unpredictable frantic rhythm, intense overwhelming hyperactive energy", code: 's("<amen funkydrummer apache think>").chop(16).sometimes(x=>x.rev()).fast(rand.range(1,4)).gain(0.85).distort(0.3)', literal: "cycling break samples, chopped into 16 pieces, sometimes reversed, random tempo, distorted", tempo: "variable", density: "very high", energy: "very high", mood: "chaotic" },
                    { desc: "laid-back reggae one-drop, sunny caribbean island vibe, relaxed positive beach atmosphere, smooth offbeat riddim", code: 's("~ bd, ~ ~ sd ~, [~ hh]*2").slow(2).gain(0.7).room(0.4).lpf(5000)', literal: "delayed kick on 3, snare on 3, offbeat hi-hats, half tempo, low-passed", tempo: "slow", density: "low", energy: "low", mood: "relaxed" },
                    { desc: "marching military precision, disciplined synchronized rhythm, powerful authoritative cadence, ceremonial parade drums", code: 's("sd*4").n("<0 1>*2").gain("<0.9 0.7 0.9 0.85>").room(0.6).hcutoff(4000)', literal: "continuous snare pattern, alternating samples, dynamic accents, reverberant march", tempo: "medium", density: "high", energy: "medium", mood: "militant" },
                    { desc: "samba carnival party, joyful festive celebration rhythm, colorful brazilian dance energy, infectious tropical groove", code: 's("bd(3,8), perc(5,8)").n(irand(5)).gain(0.75).room(0.3).speed(rand.range(0.95,1.05))', literal: "euclidean kick and percussion, random sample selection, slight tempo variations", tempo: "fast", density: "high", energy: "high", mood: "joyful" },
                    { desc: "broken beat future garage shuffle, skippy syncopated 2-step groove, moody UK underground vibe, sophisticated electronic swing", code: 's("bd ~ [~ bd] ~, ~ ~ sd [sd ~], hh*4").gain(0.7).room(0.5).sometimes(x=>x.degradeBy(0.2))', literal: "syncopated kick placement, delayed snare hits, continuous hi-hats, occasional degradation", tempo: "medium", density: "medium", energy: "medium", mood: "moody" },
                    { desc: "ticking clock mechanical rhythm, precise metronome pulse, hypnotic repetitive time-keeping, minimalist conceptual pattern", code: 's("rm*8").gain("<0.3 0.5>*4").room(0.1).hpf(3000)', literal: "eighth note rim shots, alternating dynamics, dry sound, high-passed clicks", tempo: "medium", density: "high", energy: "low", mood: "mechanical" },
                    { desc: "explosive dramatic cinematic hits, epic movie trailer impacts, powerful orchestral percussion, goosebumps-inducing intensity", code: 's("~ ~ bd ~, ~ ~ ~ sd").gain(1).distort(0.1).room(0.9).lpf(300).slow(2)', literal: "sparse powerful hits, half tempo, heavily reverbed, low-passed, distorted impacts", tempo: "very slow", density: "very low", energy: "high", mood: "dramatic" },
                    { desc: "shuffled swing groove, loose human timing feel, organic live drummer imperfection, natural breathable pocket", code: 's("bd ~ bd ~, ~ sd ~ sd").early("<0 0.1 -0.05 0.08>*4").gain(0.75).room(0.3)', literal: "basic kick-snare pattern, timing variations with early parameter, swung feel", tempo: "medium", density: "low", energy: "medium", mood: "groovy" },
                    { desc: "afrobeat polyrhythmic layers, complex interlocking patterns, hypnotic repetitive groove, west african traditional fusion", code: 's("bd(5,8)").stack(s("perc(7,16)").n(irand(8)), s("hh(11,16)")).gain(0.7).room(0.4)', literal: "5/8 kick, 7/16 percussion, 11/16 hi-hat, stacked polyrhythms, random percussion samples", tempo: "medium", density: "very high", energy: "medium", mood: "hypnotic" },
                ],
                bass: [
                    { desc: "deep powerful rolling rumbling bass, heavy wobbling low end, massive subwoofer shaking foundation, ominous dark threatening energy", code: 's("jungbass").n("<0 1 2 3>").slow(2).speed(rand.range(0.8,1.2)).lpf(sine.range(300,600).slow(8)).lpq(12).gain(0.85)', literal: "cycling bass notes, half tempo, pitch variations, sweeping low-pass filter with high resonance", register: "sub", movement: "wobbling", timbre: "dark", rhythm: "slow" },
                    { desc: "sleek futuristic minimal bass, clean modern sophisticated low end, hypnotic pulsing movement, sci-fi cyberpunk aesthetic", code: 's("jungbass").n("<7 9 11>").slow(2).lpf(sine.range(400,1200).slow(8)).room(0.3).gain(0.7)', literal: "higher bass notes, half tempo, sweeping filter 400-1200Hz, reverberant space", register: "mid-bass", movement: "pulsing", timbre: "clean", rhythm: "slow" },
                    { desc: "groovy funky danceable bass line, playful bouncy slap bass feel, upbeat positive energy, makes you want to move", code: 's("pluck").n("0 ~ [3 7] ~").speed(0.5).lpf(800).gain(0.6)', literal: "root note, rest, chord tones on 3rd beat, plucked sound, filtered at 800Hz", register: "mid-bass", movement: "bouncy", timbre: "plucky", rhythm: "syncopated" },
                    { desc: "smooth sophisticated jazz walking bass, elegant classy lounge vibe, refined mature evening mood, cocktail bar atmosphere", code: 's("jvbass").n("<0 3 5 7>*2").slow(2).lpf(800).gain(0.65)', literal: "chromatic walking pattern, doubled notes, half tempo, low-passed at 800Hz", register: "mid-bass", movement: "walking", timbre: "warm", rhythm: "steady" },
                    { desc: "aggressive intense wobbling bass, violent shaking modulation, angry heavy dubstep energy, destructive powerful low frequencies", code: 's("jungbass").n("13").lpf(sine.range(200,2000).fast(8)).lpq(20).gain(0.9).distort(0.2)', literal: "single bass note, rapid filter sweep 200-2000Hz, extreme resonance, distorted", register: "sub", movement: "wobbling", timbre: "aggressive", rhythm: "sustained" },
                    { desc: "peaceful ethereal floating bass pad, calm meditative drone, serene spacious atmosphere, gentle soothing sustained tone", code: 's("pad").n("<0 1 2>").slow(8).lpf(400).gain(sine.range(0.4,0.6).slow(16)).room(0.8)', literal: "slow cycling pad notes, very slow tempo, sub-bass filter, breathing dynamics, heavy reverb", register: "sub", movement: "floating", timbre: "soft", rhythm: "very slow" },
                    { desc: "psychedelic trippy squelchy acid bass, weird bubbly resonant sound, hypnotic repetitive pattern, rave party energy", code: 's("jungbass").n("<5 5 5 4>").lpf(sine.range(500,1000).slow(8)).lpq(8).gain(0.8)', literal: "mostly repeated note with variation, sweeping filter 500-1000Hz, moderate resonance", register: "mid-bass", movement: "squelchy", timbre: "acidic", rhythm: "repetitive" },
                    { desc: "warm cozy nostalgic lofi bass, comfortable relaxed bedroom vibe, soft fuzzy analog feeling, intimate close production", code: 's("bass").n("<0 2 3 1>").slow(4).lpf(800).gain(0.65).delay(0.4)', literal: "simple chord progression, quarter tempo, low-passed, delayed echoes", register: "mid-bass", movement: "gentle", timbre: "warm", rhythm: "slow" },
                    { desc: "harsh aggressive distorted bass stabs, angry violent punchy hits, intense dark industrial energy, gritty raw power", code: 's("jungbass").n("<0 2 4 6>").struct("x ~ x [~ x]").lpf(1200).gain(0.7).distort(0.4)', literal: "chromatic bass notes, stab pattern with rests, distorted, filtered at 1200Hz", register: "mid-bass", movement: "stabbing", timbre: "distorted", rhythm: "syncopated" },
                    { desc: "melodic singing bass riff, smooth flowing musical line, catchy memorable tune, warm inviting harmonic movement", code: 's("pluck").n("0 3 5 7 5 3").speed(0.4).lpf(1000).gain(0.6).room(0.2)', literal: "ascending then descending scale pattern, slow speed, plucked tone, filtered", register: "mid-bass", movement: "melodic", timbre: "musical", rhythm: "flowing" },
                    { desc: "gritty authentic sampled bass, real organic instrument character, vintage old school hip hop texture, raw unpolished quality", code: 's("bass").n("0 ~ 2 1").slow(2).gain(0.8).lpf(600).room(0.2)', literal: "simple bass pattern with rest, half tempo, dark low-pass filter, dry sound", register: "mid-bass", movement: "groovy", timbre: "gritty", rhythm: "slow" },
                    { desc: "massive chest-thumping sub bass, physically felt rumble, earthquake vibrations, powerful foundation underneath everything", code: 's("bass").n("<0 1 2>*4").slow(4).gain(0.9).lpf(200).room(0.1)', literal: "repeated low notes, very slow tempo, extreme low-pass at 200Hz, dry, loud", register: "sub", movement: "rumbling", timbre: "massive", rhythm: "very slow" },
                    { desc: "retro 80s electronic bass drum, classic vintage synthesizer, nostalgic old school drum machine, boom bap hip hop foundation", code: 's("808bd").n("0 ~ 0 ~").speed("<1 0.8 0.9>").gain(0.85).lpf(400)', literal: "808 kick pattern with rests, varying pitch, low-passed, vintage sound", register: "sub", movement: "thumping", timbre: "retro", rhythm: "steady" },
                    { desc: "happy uplifting positive bass groove, cheerful optimistic feeling, smile-inducing rhythm, feel-good party energy", code: 's("bass").n("<0 2 4 3>").speed(0.95).gain(0.75).lpf(800).room(0.3)', literal: "major scale bass line, slightly slowed, moderate filter, reverberant", register: "mid-bass", movement: "bouncy", timbre: "bright", rhythm: "groovy" },
                    { desc: "weird experimental glitchy bass, unpredictable chaotic textures, strange futuristic digital artifacts, avant-garde sound design", code: 's("bass").n(irand(6)).sometimes(x=>x.speed(rand.range(0.7,1.3))).gain(0.7).lpf(sine.range(300,900).slow(4))', literal: "random bass notes, occasional pitch shifts, sweeping filter with slow modulation", register: "mid-bass", movement: "erratic", timbre: "glitchy", rhythm: "unpredictable" },
                    { desc: "rubber bouncy FM bass, tight snappy 80s slap sound, bright percussive attack, energetic retro video game character", code: 's("pluck").n("<0 3>*4").speed(1.5).lpf(1500).gain(0.7).hpf(100)', literal: "alternating root and third, fast speed, brighter filter, high-pass filtered bottom", register: "mid-bass", movement: "bouncy", timbre: "bright", rhythm: "fast" },
                    { desc: "haunting eerie sub bass drone, unsettling ominous undertone, horror movie atmosphere, creeping dread tension", code: 's("pad").n("0").slow(8).gain(sine.range(0.5,0.7).slow(32)).lpf(120).room(0.9)', literal: "single sustained note, very slow, breathing dynamics, extreme low-pass at 120Hz, huge reverb", register: "sub", movement: "droning", timbre: "dark", rhythm: "sustained" },
                    { desc: "tribal didgeridoo-like bass, ancient ceremonial drone, earthy organic resonance, primal spiritual vibration", code: 's("jungbass").n("15").lpf(400).lpq(5).gain(0.75).room(0.4)', literal: "single low note, sub-bass filter with moderate resonance, reverberant drone", register: "sub", movement: "droning", timbre: "organic", rhythm: "sustained" },
                    { desc: "reese bass neurofunk techstep, metallic sci-fi character, aggressive rolling modulation, dark underground jungle sound", code: 's("jungbass").n("<10 11>").lpf(sine.range(250,500).slow(4)).lpq(15).gain(0.85).distort(0.15)', literal: "two alternating notes, slow filter sweep with high resonance, slightly distorted", register: "sub", movement: "rolling", timbre: "metallic", rhythm: "steady" },
                    { desc: "bouncy plucky synth bass, cute playful cartoon character, quirky upbeat melody, fun video game aesthetic", code: 's("pluck").n("<0 3 7 12>").speed(2).lpf(2000).gain(0.6).delay(0.125)', literal: "arpeggiating chord tones, doubled speed, bright filter, short delay", register: "mid-bass", movement: "bouncy", timbre: "plucky", rhythm: "fast" },
                    { desc: "808 sub kick thump, hip hop trap foundation, chest-hitting punch, modern urban production staple", code: 's("808bd").n("0 ~ [0 1] ~").speed("<1 0.85>*2").gain(0.9).lpf(250).room(0.05)', literal: "808 kick with pitched variation, alternating speed, extreme low-pass, dry", register: "sub", movement: "thumping", timbre: "punchy", rhythm: "syncopated" },
                    { desc: "sliding portamento bass, smooth gliding pitch transitions, expressive vocal-like movement, soulful funky character", code: 's("jvbass").n("<0 3 5 7>").lpf(900).gain(0.7).speed("<1 0.9 1.1 0.95>")', literal: "bass line with pitch variations, varied speeds for gliding effect, smooth transitions", register: "mid-bass", movement: "sliding", timbre: "smooth", rhythm: "expressive" },
                    { desc: "filtered house bass pulse, classic four-to-floor foundation, warm analog resonance, dancefloor groove essential", code: 's("bass").n("0!4").lpf(sine.range(200,800).slow(8)).lpq(5).gain(0.75).room(0.2)', literal: "repeated root note, sweeping filter with resonance, steady pulse", register: "mid-bass", movement: "pulsing", timbre: "warm", rhythm: "steady" },
                    { desc: "detuned supersaw bass, massive wide stereo spread, powerful cinematic low end, epic trailer sound design", code: 's("jungbass").n("16").stack(s("jungbass").n("17")).lpf(500).gain(0.8)', literal: "two layered detuned bass notes, sub-bass filter, thick stereo", register: "sub", movement: "sustained", timbre: "massive", rhythm: "sustained" },
                    { desc: "minimal techno pulse, hypnotic repetitive throb, stripped-down club tool, late-night warehouse vibe", code: 's("bass").n("0!16").sometimes(x=>x.speed(2)).gain(sine.range(0.6,0.8).slow(16)).lpf(300)', literal: "continuous root note, occasional pitch jump, breathing dynamics, dark filter", register: "sub", movement: "pulsing", timbre: "minimal", rhythm: "repetitive" },
                ],
                melody: [
                    { desc: "sparkling bright cheerful uplifting melody, happy optimistic twinkling sounds, cascading crystalline notes, joyful shimmering arpeggio", code: 's("arpy").n("<0 2 3 5>*2").off(1/8, x=>x.speed(2)).lpf(2000).delay(0.25).delaytime(0.125).gain(0.4)', literal: "major scale pattern doubled, layered with octave up, delayed echoes, bright arpeggios", range: "high", contour: "ascending", texture: "sparkly", articulation: "staccato" },
                    { desc: "dreamy ethereal floating atmosphere, peaceful calm ambient soundscape, serene meditative gentle pad, heavenly clouds drifting", code: 's("pad").n("<0 1 2>").slow(8).lpf(1000).room(0.9).gain(0.4)', literal: "slow cycling pad notes, very slow tempo, filtered, heavily reverbed sustained tones", range: "mid", contour: "static", texture: "smooth", articulation: "sustained" },
                    { desc: "sophisticated jazzy improvised solo, elegant classy lounge music, smooth refined bebop lines, intellectual cocktail bar sophistication", code: 's("sax").n("<0 3 5 7 10 7 5 3>*2").lpf(3000).gain(0.4)', literal: "chromatic jazz phrase ascending and descending, doubled, saxophone sound", range: "mid", contour: "arch", texture: "smooth", articulation: "legato" },
                    { desc: "punchy aggressive staccato hits, sharp edgy robotic stabs, mechanical precise energy, modern futuristic rhythm", code: 's("stab").n("<0 5 10 15>").fast(2).lpf(1600).gain(0.5)', literal: "chromatic stab pattern, doubled tempo, short sharp attacks", range: "mid", contour: "ascending", texture: "sharp", articulation: "staccato" },
                    { desc: "magical mystical bell tones, enchanting fairy tale atmosphere, delicate whimsical sparkles, fantasy dreamlike quality", code: 's("arpy").n("<0 2 3 7>").degradeBy(0.2).delay(0.35).gain(0.3).room(0.6).speed(2)', literal: "scale fragments, some notes randomly removed, delayed, high pitched arpeggios, reverberant", range: "high", contour: "ascending", texture: "delicate", articulation: "plucked" },
                    { desc: "frantic chaotic fast arpeggios, intense rapid movement, urgent rushing energy, hyperactive jungle rhythm", code: 's("arpy").n(irand(16)).struct("x(13,16)").lpf(2500).gain(0.35).delay(0.125)', literal: "random notes in dense euclidean pattern, 13 of 16 steps, fast arpeggio", range: "high", contour: "random", texture: "busy", articulation: "rapid" },
                    { desc: "quirky cute playful bleeps, fun video game sounds, nostalgic retro 8-bit character, childlike innocent charm", code: 's("space").n("<0 5 7>").struct("x(5,16)").delay(0.5).gain(0.25)', literal: "perfect fourth and fifth intervals, sparse euclidean pattern, delayed bleeps", range: "high", contour: "static", texture: "thin", articulation: "staccato" },
                    { desc: "warm emotional singing lead synth, expressive human-like melody, soulful heartfelt tone, nostalgic vintage analog warmth", code: 's("moog").n("<0 2 4>").slow(2).lpf(1500).gain(0.5).room(0.3)', literal: "simple three-note phrase, half tempo, moog synth, warm filtered tone", range: "mid", contour: "ascending", texture: "thick", articulation: "legato" },
                    { desc: "organic acoustic plucked strings, natural folk instrument feel, earthy authentic texture, intimate campfire guitar-like melody", code: 's("pluck").n("<0 3 5 7 5 3>").lpf(2000).gain(0.45).room(0.25)', literal: "ascending then descending scale, plucked string sound, natural reverb", range: "mid", contour: "arch", texture: "organic", articulation: "plucked" },
                    { desc: "otherworldly alien cosmic sounds, mysterious outer space atmosphere, sci-fi soundtrack vibes, vast galactic echoes", code: 's("space").n("<5 12 8 15>").slow(2).lpf(3000).delay(0.4).delayfb(0.6).room(0.7).gain(0.35)', literal: "wide interval jumps, half tempo, feedback delay, space sounds, reverberant", range: "mid-high", contour: "jumping", texture: "ethereal", articulation: "sustained" },
                    { desc: "bright energetic cascading patterns, fast exciting rolling notes, dynamic movement, uplifting positive momentum", code: 's("arpy").n("<0 2 4 5>*4").speed(2).gain(0.45).delay(0.25).room(0.4)', literal: "repeating major scale fragment, quadrupled, doubled speed, delayed", range: "high", contour: "ascending", texture: "bright", articulation: "rapid" },
                    { desc: "mysterious vast universe soundscape, infinite cosmic expanse, celestial star-gazing atmosphere, awe-inspiring space theme", code: 's("pad").n("<0 1>").slow(4).lpf(3000).delay(0.4).delayfb(0.6).room(0.7).gain(0.35)', literal: "two alternating notes, quarter tempo, pad sound, heavy delay and reverb", range: "mid", contour: "static", texture: "vast", articulation: "sustained" },
                    { desc: "nostalgic 80s toy keyboard, retro cheap synthesizer charm, vintage childhood memories, playful corny preset sounds", code: 's("casio").n("0 3 5 7").speed(1.2).gain(0.5).lpf(2000).room(0.3)', literal: "major seventh chord arpeggio, slightly faster, casio preset sound", range: "mid", contour: "ascending", texture: "retro", articulation: "staccato" },
                    { desc: "robotic vocoder speech melody, futuristic talking synthesizer, cyberpunk AI voice, electronic digital human sound", code: 's("numbers").n("<0 4 7 12>").speed(1.5).gain(0.45).delay(0.2).room(0.5)', literal: "octave with fifth, fast speed, vocoded number samples, delayed", range: "mid", contour: "ascending", texture: "synthetic", articulation: "spoken" },
                    { desc: "elegant classical arpeggio phrases, beautiful refined musical passages, sophisticated concert hall performance, romantic emotional melodies", code: 's("arpy").n("<0 2 4 7>").slow(2).speed(0.9).gain(0.55).room(0.4).lpf(3000)', literal: "major seventh arpeggio, half tempo, slightly slowed, concert hall reverb", range: "mid-high", contour: "ascending", texture: "elegant", articulation: "flowing" },
                    { desc: "exotic eastern metallic bells, mysterious asian temple sounds, ancient spiritual chimes, mystical cultural instruments", code: 's("arpy").n("<0 3 7 10>").speed(1.8).gain(0.4).delay(0.3).room(0.6).hpf(1000)', literal: "pentatonic-like intervals, fast speed, metallic arpeggios, delayed echoes, bright", range: "high", contour: "ascending", texture: "metallic", articulation: "struck" },
                    { desc: "descending waterfall cascade, rushing downward melodic runs, dramatic falling motion, cinematic gravity pull", code: 's("notes").n("<12 10 8 7 5 3 2 0>").fast(2).lpf(3000).gain(0.4).delay(0.125)', literal: "chromatic descending run from high to low, doubled tempo, cascading", range: "full", contour: "descending", texture: "flowing", articulation: "rapid" },
                    { desc: "haunting music box lullaby, creepy nostalgic childhood memory, eerie innocent melody, unsettling Victorian atmosphere", code: 's("notes").n("<0 2 3 2 5 3 2 0>").slow(2).lpf(2000).gain(0.35).room(0.8).delay(0.5)', literal: "simple lullaby pattern, half tempo, music box tone, heavily reverbed", range: "high", contour: "arch", texture: "delicate", articulation: "plucked" },
                    { desc: "epic heroic fanfare, triumphant victorious brass melody, powerful orchestral announcement, adventure quest beginning", code: 's("stab").n("<0 5 10>").slow(2).lpf(2500).gain(0.5).room(0.4)', literal: "rising intervals, half tempo, brass stabs, concert hall space", range: "mid", contour: "ascending", texture: "bold", articulation: "accented" },
                    { desc: "minimalist repetitive piano motif, Philip Glass-style cycling pattern, hypnotic meditative pulse, contemporary classical vibe", code: 's("notes").n("<0 2 4 5 4 2>").lpf(2000).gain(0.4).room(0.3)', literal: "ascending then descending scale fragment, repeating pattern, piano sound", range: "mid", contour: "arch", texture: "clean", articulation: "detached" },
                    { desc: "glitchy stuttering digital melody, broken fragmented sound, experimental electronic texture, deconstructed IDM character", code: 's("arpy").n(irand(12)).chop(8).sometimes(x=>x.rev()).gain(0.4).delay(0.125).room(0.5).hpf(500)', literal: "random notes chopped into 8 pieces, sometimes reversed, high-passed", range: "high", contour: "fragmented", texture: "glitchy", articulation: "stuttering" },
                    { desc: "lonely whistling tune, solitary western desert vibe, sparse melancholic melody, Sergio Leone soundtrack feeling", code: 's("notes").n("<0 3 5 7>").struct("x ~ x(3,8)").gain(0.35).room(0.7).delay(0.4)', literal: "scale fragments with rests and euclidean pattern, sparse placement, reverberant", range: "mid", contour: "ascending", texture: "sparse", articulation: "sustained" },
                    { desc: "tropical steel drum melody, caribbean island paradise, sunny beach holiday vibe, relaxed vacation atmosphere", code: 's("notes").n("<0 2 4 7 9 7 4 2>").lpf(3000).gain(0.5).room(0.3).pan(rand.range(0.3,0.7))', literal: "major scale ascending and descending, stereo panning, bright tone", range: "mid-high", contour: "arch", texture: "metallic", articulation: "struck" },
                    { desc: "soaring emotional string line, cinematic sweeping melody, heartfelt orchestral voice, tear-jerking movie soundtrack", code: 's("moog").n("<0 2 4>").slow(4).lpf(2000).gain(0.45).room(0.6)', literal: "simple three-note phrase, very slow, string-like synth, cinematic reverb", range: "mid", contour: "ascending", texture: "lush", articulation: "legato" },
                    { desc: "choppy fragmented vocal cuts, sampled voice melody, rhythmic speech pattern, experimental hip hop production", code: 's("numbers").n("<0 4 7 12 14 7 4 0>").chop(4).gain(0.4).delay(0.25).room(0.4).speed(rand.range(0.9,1.1))', literal: "ascending then descending pattern, chopped into 4 pieces, vocal samples, random pitch", range: "mid-high", contour: "arch", texture: "fragmented", articulation: "chopped" },
                ],
                chords: [
                    { desc: "sophisticated elegant jazz harmony, classy lounge chord progressions, refined mature evening atmosphere, intellectual cocktail bar sophistication", code: 's("juno").n("<0 2 4>").struct("~ x ~ [x ~]").lpf(1200).gain(0.4).room(0.4)', literal: "synth chords with syncopated rhythm, rests and variations, filtered warm sound", voicing: "spread", quality: "extended", density: "sparse", rhythm: "syncopated" },
                    { desc: "powerful uplifting dance anthem chords, euphoric emotional chord stabs, epic festival moment, goosebumps-inducing harmony", code: 's("stab").n("<0 5 10>").slow(4).lpf(700).gain(0.35).room(0.5)', literal: "rising chord progression, quarter tempo, bass-heavy filter, reverberant stabs", voicing: "compact", quality: "major", density: "sparse", rhythm: "sustained" },
                    { desc: "peaceful ethereal floating pad chords, calm dreamy atmosphere, serene gentle harmony, meditative soothing sustained tones", code: 's("pad").n("<0 1 2>").slow(8).lpf(sine.range(600,1200).slow(16)).room(0.8).gain(0.3)', literal: "slow cycling pad chords, very slow tempo, breathing filter movement, heavy reverb", voicing: "wide", quality: "ambient", density: "sustained", rhythm: "very slow" },
                    { desc: "beautiful emotional piano chords, touching heartfelt progression, cinematic soundtrack quality, tear-jerking romantic harmony", code: 's("notes").n("<0 3 5 7>").struct("x ~ [~ x] ~").lpf(2000).gain(0.35).room(0.5)', literal: "major seventh progression, syncopated placement with rests, piano-like tone", voicing: "spread", quality: "major seventh", density: "sparse", rhythm: "syncopated" },
                    { desc: "dark moody mysterious chords, ominous threatening atmosphere, eerie suspenseful tension, gothic melancholic sadness", code: 's("pad").n("<0 1>").slow(4).lpf(900).gain(0.45).room(0.6)', literal: "two alternating dark chords, quarter tempo, dark low-pass filter, reverberant", voicing: "wide", quality: "minor", density: "sustained", rhythm: "slow" },
                    { desc: "bright cheerful happy major chords, optimistic sunny day feeling, uplifting positive energy, smile-inducing harmony", code: 's("juno").n("<0 2 4>").struct("x(3,8)").lpf(1500).gain(0.4).room(0.4)', literal: "major triad, euclidean 3-of-8 rhythm, bright synth, moderately filtered", voicing: "compact", quality: "major", density: "rhythmic", rhythm: "euclidean" },
                    { desc: "tense anticipation building chords, unresolved suspenseful harmony, dramatic cinematic tension, waiting for resolution feeling", code: 's("stab").n("<0 5 10 15>").slow(2).lpf(1000).gain(0.5).room(0.5)', literal: "ascending chromatic chord progression, half tempo, stabby attacks, reverberant", voicing: "compact", quality: "dissonant", density: "sparse", rhythm: "slow" },
                    { desc: "punchy rhythmic chord stabs, energetic driving harmony hits, aggressive powerful chordal rhythm, electronic dance energy", code: 's("stab").n("<0 5 10>").struct("x ~ x ~").lpf(1200).gain(0.5).room(0.3)', literal: "three-chord progression, on-off rhythm pattern, sharp stabs, moderate filter", voicing: "compact", quality: "fifths", density: "rhythmic", rhythm: "steady" },
                    { desc: "warm rich harmonic chord layers, full lush harmonic texture, classical concert hall grandeur, sophisticated orchestral depth", code: 's("arpy").n("<[0,4,7] [2,5,9] [5,9,12]>").slow(4).gain(0.5).room(0.5).lpf(2500)', literal: "explicit voiced triads, quarter tempo, arpeggiated sound, concert hall reverb", voicing: "wide", quality: "major triads", density: "sustained", rhythm: "slow" },
                    { desc: "nostalgic retro 80s preset pads, vintage cheap keyboard sound, corny old-fashioned synthesizer, childhood memories triggered", code: 's("casio").n("<0 3 7>").slow(8).speed(0.8).gain(0.45).room(0.7).lpf(1800)', literal: "perfect fourth intervals, very slow, vintage casio preset, detuned slightly", voicing: "spread", quality: "sus4", density: "sustained", rhythm: "very slow" },
                    { desc: "vast cosmic space chords, infinite universe atmosphere, otherworldly alien harmony, sci-fi soundtrack ambience", code: 's("pad").n("<0 1 2>").slow(8).lpf(sine.range(400,800).slow(16)).gain(0.4).room(0.9).delay(0.5)', literal: "slow cycling pads, sweeping low filter, huge reverb and delay, atmospheric", voicing: "wide", quality: "ambient", density: "sustained", rhythm: "very slow" },
                    { desc: "shimmering crystalline chord layers, bright sparkling harmonic textures, magical twinkling quality, enchanting fairy tale atmosphere", code: 's("arpy").n("<[0,4,7] [2,5,9]>*2").speed(0.5).gain(0.35).room(0.6).delay(0.3)', literal: "major triad arpeggios, doubled pattern, slow speed, delayed sparkles", voicing: "spread", quality: "major triads", density: "arpeggiated", rhythm: "flowing" },
                    { desc: "dissonant cluster chords, experimental avant-garde harmony, challenging intellectual music, contemporary classical tension", code: 's("stab").n("<0 5 10 15>*2").slow(4).lpf(1500).gain(0.4).room(0.7)', literal: "chromatic cluster, doubled pattern, quarter tempo, reverberant stabs", voicing: "tight", quality: "dissonant", density: "sustained", rhythm: "slow" },
                    { desc: "gospel church organ chords, spiritual uplifting sunday morning, soulful religious harmony, powerful choir-like voicing", code: 's("juno").n("<0 2 4>").slow(4).lpf(2000).gain(0.45).room(0.5)', literal: "simple chord progression, quarter tempo, organ-like synth, church reverb", voicing: "spread", quality: "major", density: "sustained", rhythm: "slow" },
                    { desc: "bossa nova jazz voicings, sophisticated latin harmony, sunny Rio beach vibe, elegant Brazilian chord quality", code: 's("notes").n("<0 3 5 7>").struct("x ~ x(3,8)").lpf(2500).gain(0.4).room(0.3)', literal: "seventh chord tones, syncopated rhythm with euclidean pattern, bright tone", voicing: "spread", quality: "major seventh", density: "rhythmic", rhythm: "syncopated" },
                    { desc: "heavy metal power chords, aggressive distorted rock harmony, headbanging energy, arena concert intensity", code: 's("stab").n("<0 10 20>").struct("x ~ x [x x]").lpf(1500).gain(0.6).distort(0.4).room(0.3)', literal: "power chord intervals, syncopated hits, heavily distorted, arena reverb", voicing: "compact", quality: "fifths", density: "rhythmic", rhythm: "syncopated" },
                    { desc: "ambient drone cluster, slowly evolving harmonic texture, patient atmospheric development, Brian Eno-style soundscape", code: 's("pad").n("<0 1 2>").slow(16).lpf(sine.range(400,1000).slow(32)).gain(0.35).room(0.95)', literal: "three cycling pad notes, very slow tempo, extremely slow filter sweep, massive reverb", voicing: "wide", quality: "ambient", density: "sustained", rhythm: "glacial" },
                    { desc: "ragtime stride piano, bouncing alternating bass chords, playful vintage early jazz, saloon entertainment vibe", code: 's("notes").n("<0 3 5 7>").lpf(2000).gain(0.5).room(0.2)', literal: "walking bass-style chord tones, piano sound, dry room, stride rhythm", voicing: "spread", quality: "seventh", density: "steady", rhythm: "walking" },
                    { desc: "video game chord progression, nostalgic 16-bit JRPG adventure, retro console town theme, cheerful innocent harmony", code: 's("space").n("<0 5 10 15>").lpf(2000).gain(0.45).room(0.4).delay(0.25)', literal: "ascending intervals, chiptune sound, delayed echoes, retro console aesthetic", voicing: "spread", quality: "open fifths", density: "sustained", rhythm: "steady" },
                    { desc: "suspended unresolved chords, floating uncertain harmony, dreamlike ambiguous tonality, no clear home feeling", code: 's("pad").n("<0 1 2>").slow(8).lpf(1200).gain(0.4).room(0.8)', literal: "cycling ambiguous chords, very slow, filtered sustain, floating in reverb", voicing: "wide", quality: "suspended", density: "sustained", rhythm: "very slow" },
                ],
                texture: [
                    { desc: "nostalgic vintage vinyl record crackle, old dusty analog warmth, retro lo-fi atmosphere, cozy scratchy texture", code: 's("~ perc").n(irand(8)).gain(0.3).degradeBy(0.5).delay(0.4).hpf(2000).room(0.5)', literal: "random percussion hits, 50% degradation, high-passed, delayed, sparse crackle", frequency: "high", density: "sparse", character: "noisy", placement: "background" },
                    { desc: "mysterious atmospheric wind sweeps, cinematic background ambience, subtle movement underneath, eerie quiet tension", code: 's("wind").n("<0 1>").slow(4).lpf(perlin.range(100,3000).slow(32)).gain(0.15).room(0.9)', literal: "wind samples, quarter tempo, slowly sweeping filter with perlin noise, quiet, reverberant", frequency: "variable", density: "sustained", character: "smooth", placement: "background" },
                    { desc: "chaotic glitchy digital errors, broken computer sounds, futuristic technology malfunction, cyberpunk aesthetics", code: 's("~ <cp [cp cp:1] [cp!2 cp:2*4]>").fast(2).sometimes(x=>x.speed(rand.range(0.95,1.05))).gain(0.65).hcutoff(2000)', literal: "complex clap patterns, doubled tempo, occasional pitch variations, high-cut filtered", frequency: "mid-high", density: "high", character: "glitchy", placement: "foreground" },
                    { desc: "shimmering bright high-end sparkle, airy delicate cymbal wash, ethereal crystalline shimmer, floating gentle texture", code: 's("hh(7,16)").n(irand(3)).gain(sine.range(0.2,0.4).slow(8)).hcutoff(8000).pan(perlin.range(0.3,0.7))', literal: "euclidean hi-hats 7 of 16, random samples, breathing dynamics, very bright, stereo panning", frequency: "very high", density: "medium", character: "shimmery", placement: "top layer" },
                    { desc: "scattered random percussion accents, unpredictable playful hits, quirky rhythmic decoration, sparse textural details", code: 's("~ perc:4").fast(2).struct("x(5,8)").gain(0.4).hpf(3000).delay(0.125).room(0.4)', literal: "specific percussion sample, doubled tempo, euclidean 5 of 8, high-passed, short delay", frequency: "high", density: "sparse", character: "percussive", placement: "accent" },
                    { desc: "breathy airy hi-hat accents, open spacious feeling, light subtle rhythm enhancement, gentle atmospheric percussion", code: 's("~ oh").fast(2).gain(0.4).room(0.3).pan(0.5)', literal: "open hi-hat with rest, doubled tempo, center panned, moderate reverb", frequency: "high", density: "sparse", character: "airy", placement: "accent" },
                    { desc: "spacious reverberant depth layer, cavernous hall ambience, adding dimension and size, creating big room feel", code: 's("~ ~ ~ cp").gain(0.5).room(0.8).delay(0.3)', literal: "clap on 4th beat only, heavy reverb and delay, creating space", frequency: "mid", density: "very sparse", character: "reverberant", placement: "spatial" },
                    { desc: "whooshing white noise bursts, sudden air rush sounds, dramatic transition effects, cinematic sweep moments", code: 's("~").gain(0).sometimes(x=>s("~").gain(rand.range(0.1,0.3)).hpf(rand.range(2000,8000)).lpf(rand.range(5000,12000)).room(0.6))', literal: "silence with occasional filtered noise bursts, random band-pass filter, reverb", frequency: "variable", density: "very sparse", character: "whooshing", placement: "effect" },
                    { desc: "vast cosmic outer space ambience, infinite universe atmosphere, mysterious alien soundscape, sci-fi movie background", code: 's("space").n("<0 5 10>").slow(2).lpf(perlin.range(100,500).slow(16)).gain(0.3).room(0.9).delay(0.6)', literal: "space sounds, half tempo, very dark sweeping filter, huge reverb and delay", frequency: "low-mid", density: "sustained", character: "atmospheric", placement: "background" },
                    { desc: "natural organic breath and wind, human inhale exhale sounds, intimate close microphone, living breathing quality", code: 's("wind").n("<0 1 2>").slow(2).speed(0.7).gain(0.35).room(0.8).hpf(500)', literal: "wind samples slowed down, half tempo, high-pass filtered, reverberant breath sounds", frequency: "mid", density: "sustained", character: "organic", placement: "background" },
                    { desc: "robotic voice fragments, chopped vocal samples, futuristic talking sounds, cyberpunk human-machine hybrid", code: 's("numbers").n(irand(10)).struct("x(5,16)").speed(rand.range(0.5,2)).gain(0.3).room(0.7).delay(0.4)', literal: "random number samples, euclidean 5 of 16, extreme pitch variations, delayed", frequency: "mid", density: "sparse", character: "vocal", placement: "accent" },
                    { desc: "harsh industrial factory sounds, aggressive metallic clangs, gritty mechanical noise, dystopian warehouse atmosphere", code: 's("metal").n(irand(10)).struct("x(3,8)").speed(rand.range(0.8,1.2)).gain(0.4).room(0.5).distort(0.2)', literal: "random metal samples, euclidean 3 of 8, pitch variations, distorted, reverberant", frequency: "mid-high", density: "sparse", character: "metallic", placement: "accent" },
                    { desc: "peaceful outdoor nature sounds, birds chirping ambience, serene natural environment, calming wildlife atmosphere", code: 's("wind").n("<0 1>").slow(8).speed(rand.range(0.7,1.3)).gain(0.25).room(0.9).pan(rand).hpf(2000)', literal: "wind samples, very slow, pitch variations, quiet, huge reverb, random panning, bright filtered", frequency: "high", density: "very sparse", character: "natural", placement: "background" },
                    { desc: "sophisticated jazz club background, classy lounge room tone, elegant atmospheric detail, refined establishment ambience", code: 's("jazz").n(irand(8)).struct("x(7,16)").speed(rand.range(0.9,1.1)).gain(0.3).room(0.4).pan(perlin)', literal: "random jazz samples, euclidean 7 of 16, subtle pitch variation, perlin panning", frequency: "full", density: "medium", character: "atmospheric", placement: "background" },
                    { desc: "quirky playful metallic tinkles, cute small object sounds, whimsical penny drops, childlike innocent details", code: 's("metal").n(irand(4)).struct("~ x ~ x").speed(rand.range(1,2)).gain(0.35).room(0.6).delay(0.2).hpf(2000)', literal: "random metal samples on offbeats, higher pitch, high-passed, delayed", frequency: "high", density: "sparse", character: "metallic", placement: "accent" },
                    { desc: "peaceful countryside field recording, calm open air atmosphere, relaxing natural outdoor space, serene rural environment", code: 's("wind").n("<0 1 2>").slow(16).speed(0.5).gain(0.2).room(1).pan(sine.range(0,1).slow(12))', literal: "wind samples, very slow tempo, low pitch, quiet, full reverb, slow auto-pan", frequency: "low-mid", density: "sustained", character: "natural", placement: "background" },
                    { desc: "rain drops gentle pitter patter, soothing water sounds, peaceful stormy day, cozy indoor window listening", code: 's("perc").n(irand(10)).struct("x(11,16)").gain(rand.range(0.15,0.3)).hpf(4000).room(0.7).pan(rand)', literal: "random percussion, dense euclidean 11 of 16, very high-passed, quiet, random panning", frequency: "very high", density: "high", character: "water-like", placement: "background" },
                    { desc: "tape machine hiss background, vintage analog recording noise, warm nostalgic texture, lo-fi production character", code: 's("noise2").n("<0 1>").slow(8).gain(0.08).hpf(8000).room(0.3)', literal: "noise samples, very slow, extremely quiet, extreme high-pass, subtle presence", frequency: "very high", density: "sustained", character: "noisy", placement: "background" },
                    { desc: "reversed cymbal swells, dramatic build-up effect, cinematic transition riser, epic anticipation moment", code: 's("hh").n(irand(3)).chop(16).rev().gain(sine.range(0.1,0.5).slow(4)).room(0.8).delay(0.25)', literal: "hi-hats chopped into 16 pieces and reversed, building dynamics, reverberant", frequency: "high", density: "crescendo", character: "reversed", placement: "transition" },
                    { desc: "granular particle cloud, microscopic sound grains, experimental texture, contemporary electronic processing", code: 's("arpy").n(irand(16)).chop(32).sometimes(x=>x.speed(rand.range(0.3,3))).gain(0.25).room(0.7).pan(rand)', literal: "random arpeggios chopped into 32 grains, extreme pitch variations, reverbed, random panning", frequency: "variable", density: "cloud", character: "granular", placement: "texture" },
                    { desc: "radio static interference, tuning between stations, nostalgic broadcast texture, found sound collage element", code: 's("noise").n("0").struct("x(3,8)").gain(rand.range(0.05,0.15)).hpf(rand.range(3000,10000))', literal: "noise in euclidean 3 of 8, very quiet, random extreme high-pass filter", frequency: "very high", density: "sparse", character: "static", placement: "accent" },
                    { desc: "water droplets echoing, cave dripping sounds, patient sparse rhythm, meditative natural percussion", code: 's("~ ~ ~ perc").n(irand(5)).struct("x(2,16)").gain(0.3).room(0.95).delay(0.8).hpf(2000)', literal: "percussion on 4th beat, very sparse euclidean 2 of 16, huge reverb, long delay", frequency: "high", density: "very sparse", character: "percussive", placement: "accent" },
                    { desc: "telephone dial tone hum, constant frequency drone, mundane everyday sound, conceptual art piece element", code: 's("simplesine").n("0").slow(16).gain(0.2).lpf(1000).room(0.4)', literal: "sine wave, very slow, quiet, low-pass filtered drone", frequency: "mid", density: "sustained", character: "tonal", placement: "drone" },
                    { desc: "footsteps walking rhythm, human movement sounds, intimate personal acoustic, field recording character", code: 's("perc").n("<0 1 2 3>").struct("x(7,16)").gain(rand.range(0.25,0.4)).lpf(2000).room(0.6).pan(perlin.range(0.2,0.8))', literal: "cycling percussion samples, euclidean 7 of 16, varied gain, filtered, spatial panning", frequency: "mid-low", density: "medium", character: "footstep-like", placement: "rhythmic" },
                    { desc: "submarine sonar ping, underwater exploration vibe, deep ocean atmosphere, mysterious nautical theme", code: 's("simplesine").n("0").struct("~ ~ ~ x").gain(0.3).room(0.9).delay(0.6)', literal: "sine wave on 4th beat only, huge reverb and delay, ping effect", frequency: "mid", density: "very sparse", character: "tonal", placement: "accent" },
                    { desc: "crystal glass resonance, delicate fragile ringing, pure harmonic overtones, ethereal shimmer texture", code: 's("~ perc").n(irand(5)).struct("x(3,16)").speed(rand.range(1.5,2.5)).gain(0.25).room(0.8).hpf(3000).delay(0.4)', literal: "random percussion, sparse euclidean 3 of 16, high pitch, very high-passed, delayed resonance", frequency: "very high", density: "sparse", character: "resonant", placement: "accent" },
                ]
            };

            let hasDirtSamples = false;
            let sampleStatusSuffix = '';
            let ttsAudioBuffers = {};  // Store generated TTS audio buffers by text
            const getSchedulerApi = () => window.strudel ?? null;
            let schedulerApi = null;

            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
            const getNow = () => (typeof performance !== 'undefined' && typeof performance.now === 'function'
                ? performance.now()
                : Date.now());

            // Helper function to compute cosine similarity between two embeddings
            const cosineSimilarity = (a, b) => {
                let dotProduct = 0;
                let normA = 0;
                let normB = 0;
                for (let i = 0; i < a.length; i++) {
                    dotProduct += a[i] * b[i];
                    normA += a[i] * a[i];
                    normB += b[i] * b[i];
                }
                return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
            };

            // Pre-compute embeddings for all patterns (one-time operation)
            // Each comma-separated element in pattern.desc gets its own embedding
            const precomputePatternEmbeddings = async () => {
                if (!extractor) return null;

                // Generate a cache key based on the pattern library structure
                const cacheKey = 'strudel_pattern_embeddings_v1';
                const libraryHashKey = 'strudel_pattern_library_hash_v1';

                // Create a simple hash of the pattern library to detect changes
                const libraryHash = JSON.stringify(Object.keys(patternLibrary).sort() +
                    Object.values(patternLibrary).map(p => p.length).join(','));

                try {
                    // Check if we have cached embeddings
                    const cachedEmbeddings = localStorage.getItem(cacheKey);
                    const cachedHash = localStorage.getItem(libraryHashKey);

                    if (cachedEmbeddings && cachedHash === libraryHash) {
                        console.log('✅ Loading cached pattern embeddings from browser storage');
                        updateLoadingProgress('Loading cached embeddings...');
                        const cache = JSON.parse(cachedEmbeddings);
                        console.log(`Loaded ${cache.length} cached pattern embeddings`);
                        return cache;
                    }
                } catch (e) {
                    console.warn('Could not load cached embeddings:', e);
                }

                updateLoadingProgress('Analyzing pattern library...');
                statusEl.textContent = 'Pre-computing pattern embeddings...';
                const cache = [];

                let processedCount = 0;
                let totalDescriptions = 0;

                // Count total descriptions (each comma-separated element)
                for (const patterns of Object.values(patternLibrary)) {
                    for (const pattern of patterns) {
                        const descriptions = pattern.desc.split(',').map(d => d.trim()).filter(d => d.length > 0);
                        totalDescriptions += descriptions.length;
                    }
                }

                for (const [category, patterns] of Object.entries(patternLibrary)) {
                    for (const pattern of patterns) {
                        // Split description by commas - each becomes a separate embedding
                        const descriptions = pattern.desc.split(',').map(d => d.trim()).filter(d => d.length > 0);

                        // Build literal metadata text based on category
                        let literalText = pattern.literal || '';

                        // Add category-specific metadata to embedding text
                        if (category === 'drums' && pattern.tempo && pattern.density && pattern.energy && pattern.mood) {
                            literalText += ` tempo: ${pattern.tempo}, density: ${pattern.density}, energy: ${pattern.energy}, mood: ${pattern.mood}`;
                        } else if (category === 'bass' && pattern.register && pattern.movement && pattern.timbre && pattern.rhythm) {
                            literalText += ` register: ${pattern.register}, movement: ${pattern.movement}, timbre: ${pattern.timbre}, rhythm: ${pattern.rhythm}`;
                        } else if (category === 'melody' && pattern.range && pattern.contour && pattern.texture && pattern.articulation) {
                            literalText += ` range: ${pattern.range}, contour: ${pattern.contour}, texture: ${pattern.texture}, articulation: ${pattern.articulation}`;
                        } else if (category === 'chords' && pattern.voicing && pattern.quality && pattern.density && pattern.rhythm) {
                            literalText += ` voicing: ${pattern.voicing}, quality: ${pattern.quality}, density: ${pattern.density}, rhythm: ${pattern.rhythm}`;
                        } else if (category === 'texture' && pattern.frequency && pattern.density && pattern.character && pattern.placement) {
                            literalText += ` frequency: ${pattern.frequency}, density: ${pattern.density}, character: ${pattern.character}, placement: ${pattern.placement}`;
                        }

                        for (const desc of descriptions) {
                            // Combine description with literal metadata for embedding
                            const embeddingText = literalText ? `${desc}, ${literalText}` : desc;
                            const embedding = await extractor(embeddingText, { pooling: 'mean', normalize: true });
                            cache.push({
                                code: pattern.code,
                                desc: desc, // Individual description phrase
                                fullDesc: pattern.desc, // Keep full description for reference
                                literal: pattern.literal || '', // Include literal description
                                category,
                                embedding: Array.from(embedding.data)
                            });
                            processedCount++;

                            // Update progress and yield to event loop every 5 embeddings
                            if (processedCount % 5 === 0 || processedCount === totalDescriptions) {
                                updateLoadingProgress(`Analyzing patterns... ${processedCount}/${totalDescriptions}`);
                                await new Promise(resolve => setTimeout(resolve, 0)); // Yield to event loop
                            }
                        }
                    }
                }

                // Cache the embeddings in localStorage
                try {
                    localStorage.setItem(cacheKey, JSON.stringify(cache));
                    localStorage.setItem(libraryHashKey, libraryHash);
                    console.log(`✅ Cached ${cache.length} pattern embeddings to browser storage`);
                } catch (e) {
                    console.warn('Could not cache embeddings to localStorage:', e);
                }

                console.log(`Pre-computed ${cache.length} pattern embeddings from ${totalDescriptions} descriptions`);
                return cache;
            };

            // IndexedDB helper for TTS caching
            const openTTSCache = () => {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open('StrudelTTSCache', 1);

                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('tts')) {
                            db.createObjectStore('tts', { keyPath: 'text' });
                        }
                    };
                });
            };

            const getCachedTTS = async (text) => {
                try {
                    const db = await openTTSCache();
                    return new Promise((resolve, reject) => {
                        const transaction = db.transaction(['tts'], 'readonly');
                        const store = transaction.objectStore('tts');
                        const request = store.get(text);

                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                } catch (e) {
                    console.warn('Could not access TTS cache:', e);
                    return null;
                }
            };

            const saveTTSToCache = async (text, audioData, samplingRate) => {
                try {
                    const db = await openTTSCache();
                    return new Promise((resolve, reject) => {
                        const transaction = db.transaction(['tts'], 'readwrite');
                        const store = transaction.objectStore('tts');
                        const request = store.put({
                            text: text,
                            audio: Array.from(audioData), // Convert Float32Array to regular array for storage
                            sampling_rate: samplingRate,
                            timestamp: Date.now()
                        });

                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                } catch (e) {
                    console.warn('Could not save TTS to cache:', e);
                }
            };

            // Generate TTS audio and register it as a Strudel sample
            const generateTTSSample = async (text, sampleName = 'tts') => {
                // Check if we already generated this text in memory
                if (ttsAudioBuffers[text]) {
                    console.log('✅ Using in-memory cached TTS audio for:', text);
                    return sampleName;
                }

                // Check IndexedDB cache
                const cached = await getCachedTTS(text);
                if (cached) {
                    console.log('✅ Using cached TTS audio from storage for:', text);

                    // Restore to memory cache
                    ttsAudioBuffers[text] = {
                        audio: new Float32Array(cached.audio),
                        sampling_rate: cached.sampling_rate
                    };

                    // Create and register the audio buffer
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const audioBuffer = audioContext.createBuffer(
                        1,
                        cached.audio.length,
                        cached.sampling_rate
                    );

                    const channelData = audioBuffer.getChannelData(0);
                    channelData.set(new Float32Array(cached.audio));
                    // Normalize/amplify TTS audio so it's not too quiet relative to other samples
                    try {
                        let peak = 0;
                        for (let i = 0; i < channelData.length; i++) {
                            const v = Math.abs(channelData[i]);
                            if (v > peak) peak = v;
                        }
                        if (peak > 0 && peak < 0.95) {
                            const scale = Math.min(0.95 / peak, 10);
                            for (let i = 0; i < channelData.length; i++) channelData[i] *= scale;
                        }
                    } catch (e) {
                        console.warn('TTS normalization failed:', e);
                    }

                    // Register with Strudel
                    try {
                        const wavData = audioBufferToWav(audioBuffer);
                        const base64 = btoa(String.fromCharCode.apply(null, new Uint8Array(wavData)));
                        const dataUrl = `data:audio/wav;base64,${base64}`;

                        const sampleLoader = typeof window.samples === 'function'
                            ? window.samples
                            : (typeof samples === 'function' ? samples : null);

                        if (sampleLoader) {
                            await sampleLoader({ [sampleName]: [dataUrl] });
                            console.log('Registered cached TTS sample:', sampleName);
                        }
                    } catch (e) {
                        console.error('Error registering cached sample:', e);
                    }

                    return sampleName;
                }

                try {
                    console.log('🎙️ Generating speech... (audio may briefly pause)');

                    // Generate TTS audio
                    const result = await generateTTSAudio(text);

                    console.log('✅ Speech generated successfully!');

                    // Store in memory
                    ttsAudioBuffers[text] = {
                        audio: result.audio,
                        sampling_rate: result.sampling_rate
                    };

                    // Save to IndexedDB cache
                    await saveTTSToCache(text, result.audio, result.sampling_rate);

                    // Create AudioBuffer for Web Audio API
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const audioBuffer = audioContext.createBuffer(
                        1,  // mono
                        result.audio.length,
                        result.sampling_rate
                    );

                    // Copy audio data
                    const channelData = audioBuffer.getChannelData(0);
                    channelData.set(result.audio);
                    // Normalize/amplify generated TTS audio so it's not too quiet relative to other samples
                    try {
                        let peak = 0;
                        for (let i = 0; i < channelData.length; i++) {
                            const v = Math.abs(channelData[i]);
                            if (v > peak) peak = v;
                        }
                        if (peak > 0 && peak < 0.95) {
                            const scale = Math.min(0.95 / peak, 10);
                            for (let i = 0; i < channelData.length; i++) channelData[i] *= scale;
                        }
                    } catch (e) {
                        console.warn('TTS normalization failed:', e);
                    }

                    // Register with Strudel using the samples() function
                    try {
                        // Convert buffer to base64 data URL to avoid CORS
                        const wavData = audioBufferToWav(audioBuffer);
                        const base64 = btoa(String.fromCharCode.apply(null, new Uint8Array(wavData)));
                        const dataUrl = `data:audio/wav;base64,${base64}`;

                        // Get the samples function from the global scope
                        const sampleLoader = typeof window.samples === 'function'
                            ? window.samples
                            : (typeof samples === 'function' ? samples : null);

                        if (sampleLoader) {
                            // Register the sample with a data URL array (to support s("tts:0"))
                            // The format is: samples({ name: ['url1', 'url2', ...] })
                            await sampleLoader({ [sampleName]: [dataUrl] });
                            console.log('Registered TTS sample via data URL:', sampleName);
                        } else {
                            console.error('Samples loader not available');
                        }
                    } catch (e) {
                        console.error('Error registering sample:', e);
                    }

                    return sampleName;
                } catch (e) {
                    console.error('Error generating TTS sample:', e);
                    throw e;
                }
            };

            // Helper function to convert AudioBuffer to WAV format
            const audioBufferToWav = (buffer) => {
                const length = buffer.length * buffer.numberOfChannels * 2;
                const arrayBuffer = new ArrayBuffer(44 + length);
                const view = new DataView(arrayBuffer);
                const channels = [];
                let offset = 0;
                let pos = 0;

                // Write WAV header
                const setUint16 = (data) => {
                    view.setUint16(pos, data, true);
                    pos += 2;
                };
                const setUint32 = (data) => {
                    view.setUint32(pos, data, true);
                    pos += 4;
                };

                // "RIFF" chunk descriptor
                setUint32(0x46464952); // "RIFF"
                setUint32(36 + length); // file length - 8
                setUint32(0x45564157); // "WAVE"

                // "fmt " sub-chunk
                setUint32(0x20746d66); // "fmt "
                setUint32(16); // subchunk1size
                setUint16(1); // audio format (1 = PCM)
                setUint16(buffer.numberOfChannels);
                setUint32(buffer.sampleRate);
                setUint32(buffer.sampleRate * buffer.numberOfChannels * 2); // byte rate
                setUint16(buffer.numberOfChannels * 2); // block align
                setUint16(16); // bits per sample

                // "data" sub-chunk
                setUint32(0x61746164); // "data"
                setUint32(length);

                // Write interleaved audio data
                for (let i = 0; i < buffer.numberOfChannels; i++) {
                    channels.push(buffer.getChannelData(i));
                }

                while (pos < arrayBuffer.byteLength) {
                    for (let i = 0; i < buffer.numberOfChannels; i++) {
                        let sample = channels[i][offset];
                        sample = Math.max(-1, Math.min(1, sample));
                        view.setInt16(pos, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                        pos += 2;
                    }
                    offset++;
                }

                return arrayBuffer;
            };

            // Generate pattern based on prompt using semantic similarity with STRICT category filtering
            const generatePatternFromPrompt = async (prompt, categoryBias = null) => {
                if (!extractor || !patternEmbeddingsCache || !prompt.trim()) {
                    // Fallback: pick random pattern from the STRICT category only
                    const patterns = categoryBias && patternLibrary[categoryBias]
                        ? patternLibrary[categoryBias]
                        : Object.values(patternLibrary).flat();
                    const selected = patterns[Math.floor(Math.random() * patterns.length)];
                    return { code: selected.code, description: selected.desc };
                }

                try {
                    // Get embedding for the prompt (only one embedding needed now!)
                    const promptEmbedding = await extractor(prompt, { pooling: 'mean', normalize: true });
                    const promptVector = Array.from(promptEmbedding.data);

                    // STRICT filtering: only consider patterns from the slot's category
                    const categoryPatterns = categoryBias
                        ? patternEmbeddingsCache.filter(p => p.category === categoryBias)
                        : patternEmbeddingsCache;

                    // Compute similarities using pre-cached embeddings (only for matching category)
                    const scoredPatterns = categoryPatterns.map(pattern => {
                        const similarity = cosineSimilarity(promptVector, pattern.embedding);
                        return { ...pattern, similarity };
                    });

                    // Sort by similarity
                    scoredPatterns.sort((a, b) => b.similarity - a.similarity);

                    // Use weighted random selection from top matches (add some randomness)
                    const topN = Math.min(3, scoredPatterns.length);
                    const topPatterns = scoredPatterns.slice(0, topN);

                    // Map the UI creativity (0..1) to a temperature value. Lower creativity -> more deterministic.
                    // creativity 0  => temperature ~0.1 (almost deterministic)
                    // creativity 1  => temperature ~1.5 (more exploratory)
                    const temperature = Math.max(0.01, 0.1 + (creativity * 1.4));

                    // If creativity is very low, pick the top match deterministically
                    if (typeof creativity === 'number' && creativity < 0.12) {
                        console.log('Deterministic mode: picking top match');
                        return { code: topPatterns[0].code, description: topPatterns[0].desc };
                    }

                    // Otherwise use a softmax weighted by similarity and temperature
                    const weights = topPatterns.map(p => Math.exp(p.similarity / temperature));
                    const totalWeight = weights.reduce((a, b) => a + b, 0);

                    let random = Math.random() * totalWeight;
                    for (let i = 0; i < topPatterns.length; i++) {
                        random -= weights[i];
                        if (random <= 0) {
                            console.log(`Selected ${topPatterns[i].category}: "${topPatterns[i].desc.substring(0, 40)}..."`);
                            return { code: topPatterns[i].code, description: topPatterns[i].desc };
                        }
                    }

                    // Fallback to top match
                    console.log(`Selected ${topPatterns[0].category}: "${topPatterns[0].desc.substring(0, 40)}..."`);
                    return { code: topPatterns[0].code, description: topPatterns[0].desc };
                } catch (e) {
                    console.error('Error generating pattern:', e);
                    // Fallback to random from the STRICT category
                    const patterns = categoryBias && patternLibrary[categoryBias]
                        ? patternLibrary[categoryBias]
                        : Object.values(patternLibrary).flat();
                    const selected = patterns[Math.floor(Math.random() * patterns.length)];
                    return { code: selected.code, description: selected.desc };
                }
            };

            // Mutate/spice up an existing pattern with random effects
            const spiceUpPattern = (currentCode, categoryName) => {
                if (!currentCode || !currentCode.trim()) {
                    return currentCode;
                }

                // Parse the current code to understand what effects are already present
                const hasEffect = (code, effectName) => {
                    const regex = new RegExp(`\\.${effectName}\\(`);
                    return regex.test(code);
                };

                const removeEffect = (code, effectName) => {
                    // Remove the effect and its parameters (handling nested parens)
                    let result = code;
                    const regex = new RegExp(`\\.${effectName}\\(`, 'g');
                    let match;

                    while ((match = regex.exec(code)) !== null) {
                        const startIdx = match.index;
                        let parenCount = 0;
                        let endIdx = match.index + match[0].length;

                        // Find matching closing paren
                        for (let i = endIdx; i < code.length; i++) {
                            if (code[i] === '(') parenCount++;
                            else if (code[i] === ')') {
                                if (parenCount === 0) {
                                    endIdx = i + 1;
                                    break;
                                }
                                parenCount--;
                            }
                        }

                        result = code.substring(0, startIdx) + code.substring(endIdx);
                        break; // Only remove first occurrence
                    }

                    return result;
                };

                const replaceEffect = (code, effectName, newValue) => {
                    // Find and replace the effect, handling nested parentheses properly
                    const regex = new RegExp(`\\.${effectName}\\(`);
                    const match = regex.exec(code);

                    if (!match) return code;

                    const startIdx = match.index;
                    let parenCount = 0;
                    let endIdx = match.index + match[0].length;

                    // Find matching closing paren
                    for (let i = endIdx; i < code.length; i++) {
                        if (code[i] === '(') parenCount++;
                        else if (code[i] === ')') {
                            if (parenCount === 0) {
                                endIdx = i + 1;
                                break;
                            }
                            parenCount--;
                        }
                    }

                    return code.substring(0, startIdx) + `.${effectName}(${newValue})` + code.substring(endIdx);
                };

                // Analyze what's in the current pattern
                const effects = {
                    temporal: ['fast', 'slow', 'sometimes', 'rarely', 'every', 'chunk'],
                    filters: ['hpf', 'lpf', 'hcutoff', 'lcutoff', 'bandf', 'bandq'],
                    space: ['room', 'size', 'delay', 'delaytime', 'delayfb', 'pan'],
                    distortion: ['crush', 'distort', 'shape'],
                    modulation: ['phaser', 'vowel', 'tremolo'],
                    granular: ['chop', 'striate', 'loopAt'],
                    pitch: ['speed', 'note', 'transpose'],
                    other: ['rev', 'gain', 'degradeBy']
                };

                let spicedCode = currentCode;

                // Decide whether to add, remove, or replace (weighted toward balance)
                const action = Math.random();
                let actionTaken = false;

                if (action < 0.4) {
                    // REMOVE an existing effect (40% chance)
                    const allEffects = Object.values(effects).flat();
                    const presentEffects = allEffects.filter(effect => hasEffect(spicedCode, effect));

                    if (presentEffects.length > 0) {
                        const effectToRemove = presentEffects[Math.floor(Math.random() * presentEffects.length)];
                        spicedCode = removeEffect(spicedCode, effectToRemove);
                        console.log(`🌶️ Removed: ${effectToRemove}`);
                        actionTaken = true;
                    }
                } else if (action < 0.7) {
                    // REPLACE an existing effect (30% chance)
                    const replacements = {
                        'chop': ['4', '8', '16', '"<4 8 16>"'],
                        'striate': ['4', '8', '16'],
                        'crush': ['4', '6', '8'],
                        'gain': ['0.6', '0.8', '1', '<0.8 1 0.6>', 'perlin.range(0.6,1)'],
                        'room': ['0.3', '0.5', '0.7', '0.9', 'perlin.range(0.2,0.8)'],
                        'delay': ['0.125', '0.25', '0.5', '"<0.125 0.25>"'],
                        'hpf': ['500', '1000', '2000', 'perlin.range(200,1000)'],
                        'lpf': ['1000', '2000', '3000', 'perlin.range(500,3000)'],
                        'distort': ['0.2', '0.3', '0.5'],
                        'speed': ['0.5', '1.5', '2', '<1 0.5>', 'perlin.range(0.8,1.2)'],
                        'pan': ['sine.slow(4)', 'perlin.slow(8)', '"<0 0.5 1>"', 'rand'],
                    };

                    const allEffects = Object.keys(replacements);
                    const presentEffects = allEffects.filter(effect => hasEffect(spicedCode, effect));

                    if (presentEffects.length > 0) {
                        const effectToReplace = presentEffects[Math.floor(Math.random() * presentEffects.length)];
                        const newValues = replacements[effectToReplace];
                        const newValue = newValues[Math.floor(Math.random() * newValues.length)];
                        spicedCode = replaceEffect(spicedCode, effectToReplace, newValue);
                        console.log(`🌶️ Modified: ${effectToReplace} → ${newValue}`);
                        actionTaken = true;
                    }
                }

                // If no action was taken yet, try to ADD a new effect
                if (!actionTaken) {
                    const additions = [
                        // Temporal
                        '.fast(2)', '.slow(2)', '.fast("<1 2>")', '.sometimes(x=>x.fast(2))',
                        '.rarely(x=>x.slow(2))', '.every(3, x=>x.fast(1.5))',

                        // Effects (only add if not present)
                        '.room(0.5)', '.delay(0.25)', '.hpf(500)', '.lpf(2000)',
                        '.crush(6)', '.distort(0.3)',

                        // Granular
                        '.chop(8)', '.striate(4)',

                        // Modulation
                        '.pan(sine.slow(4))', '.gain(perlin.range(0.7,1))',

                        // Combinations that work well together
                        '.room(0.5).size(0.7)',
                        '.delay(0.125).delayfb(0.3)',
                        '.hpf(300).lpf(3000)',
                    ];

                    // Filter out effects that are already present to avoid duplicates
                    const availableAdditions = additions.filter(addition => {
                        const effectMatch = addition.match(/\.(\w+)\(/);
                        if (effectMatch) {
                            const effectName = effectMatch[1];
                            return !hasEffect(spicedCode, effectName);
                        }
                        return true;
                    });

                    if (availableAdditions.length > 0) {
                        const addition = availableAdditions[Math.floor(Math.random() * availableAdditions.length)];
                        spicedCode = spicedCode + addition;
                        console.log(`🌶️ Added: ${addition}`);
                        actionTaken = true;
                    }
                }

                return spicedCode;
            };

            const waitForScheduler = async (timeoutMs = 5000) => {
                const start = getNow();
                let api = getSchedulerApi();
                let attempts = 0;

                while (getNow() - start < timeoutMs) {
                    if (api && typeof api.setPattern === 'function' && typeof api.setCps === 'function') {
                        return api;
                    }

                    await sleep(50);
                    api = getSchedulerApi();
                    attempts++;

                    // Update progress every few attempts to show activity
                    if (attempts % 5 === 0) {
                        updateLoadingProgress(`Waiting for audio engine...`);
                    }
                }

                return api;
            };

            updateLoadingProgress('Loading Strudel and samples...');
            statusEl.textContent = 'Loading Strudel and samples…';

            await initStrudel({
                // Load the classic Dirt sample pack so bd/sn/hh/etc. are available.
                prebake: async () => {
                    updateLoadingProgress('Loading sample library...');
                    const sampleLoader = typeof window.samples === 'function'
                        ? window.samples
                        : (typeof samples === 'function' ? samples : null);
                    if (!sampleLoader) {
                        console.warn('Strudel samples loader unavailable. Using synth fallback for drums and percussion.');
                        updateLoadingProgress('Using synth fallback...', false);
                        return;
                    }

                    // Load ALL the sample packs - comprehensive loading
                    const allSamplePacks = [
                        { url: 'github:tidalcycles/Dirt-Samples', name: 'Dirt-Samples (main)' },
                        { url: 'github:yaxu/clean-breaks', name: 'breaks' },
                    ];

                    let loadedCount = 0;
                    for (let i = 0; i < allSamplePacks.length; i++) {
                        const pack = allSamplePacks[i];
                        try {
                            updateLoadingProgress(`Loading ${pack.name}... (${i + 1}/${allSamplePacks.length})`);
                            await sampleLoader(pack.url);
                            console.log(`✓ Loaded: ${pack.url}`);
                            loadedCount++;
                            if (i === 0) hasDirtSamples = true; // First pack is main Dirt samples
                        } catch (e) {
                            console.warn(`✗ Failed to load ${pack.url}:`, e.message || e);
                            // Continue trying other packs even if one fails
                        }
                    }

                    console.log(`Successfully loaded ${loadedCount}/${allSamplePacks.length} sample packs`);
                    updateLoadingProgress(`Loaded ${loadedCount} sample packs ✓`);

                    updateLoadingProgress('Sample libraries loaded ✓');
                }
            });

            // initStrudel has completed, now start the audio engine
            updateLoadingProgress('Starting audio system...');

            schedulerApi = await waitForScheduler();

            if (!schedulerApi) {
                console.warn('Strudel scheduler did not become ready in time.');
            }

            updateLoadingProgress('Configuring audio settings...');

            if (!hasDirtSamples) {
                sampleStatusSuffix = ' (samples not loaded)';
            }

            updateLoadingProgress('Audio engine ready ✓');

            // Pre-compute pattern embeddings if AI model is available
            if (extractor) {
                patternEmbeddingsCache = await precomputePatternEmbeddings();
                updateLoadingProgress('Pattern library ready ✓');
            }

            updateLoadingProgress('Setting up interface...');

            // small helper: convert hex color (#rrggbb or #rgb) to "r,g,b" string
            const hexToRgbString = (hex) => {
                if (!hex) return '0,0,0';
                // remove # if present
                let h = hex.replace('#', '');
                if (h.length === 3) {
                    h = h.split('').map(c => c + c).join('');
                }
                const intVal = parseInt(h, 16);
                const r = (intVal >> 16) & 255;
                const g = (intVal >> 8) & 255;
                const b = intVal & 255;
                return `${r}, ${g}, ${b}`;
            };

            // Function to create a new slot
            const createSlot = (categoryName) => {
                const slotId = slotIdCounter++;
                const category = slotCategories.find(c => c.name === categoryName) || slotCategories[0];

                const slotDiv = document.createElement('div');
                slotDiv.className = 'slot';
                slotDiv.style.setProperty('--slot-color', category.color);
                // also expose an rgb triplet for CSS use (e.g. overlay tint)
                slotDiv.style.setProperty('--slot-color-rgb', hexToRgbString(category.color));
                slotDiv.dataset.slotId = slotId;

                const header = document.createElement('div');
                header.className = 'slot-header';

                const leftGroup = document.createElement('div');
                leftGroup.style.display = 'flex';
                leftGroup.style.alignItems = 'center';
                leftGroup.style.gap = '0.5rem';

                // Drag handle
                const dragHandle = document.createElement('div');
                dragHandle.className = 'slot-drag-handle';
                dragHandle.innerHTML = '⋮⋮';
                dragHandle.title = 'Drag to reorder';
                dragHandle.draggable = true;

                const muteBtn = document.createElement('button');
                muteBtn.className = 'slot-mute-btn';
                muteBtn.innerHTML = '🔊';
                muteBtn.setAttribute('aria-label', 'Mute/unmute layer');
                muteBtn.title = 'Mute/unmute';

                leftGroup.appendChild(dragHandle);
                leftGroup.appendChild(muteBtn);

                const controlsGroup = document.createElement('div');
                controlsGroup.className = 'slot-controls';

                const slotPromptInput = document.createElement('input');
                slotPromptInput.type = 'text';
                slotPromptInput.className = 'slot-prompt';
                slotPromptInput.placeholder = category.name === 'tts' ? 'What would you like to say...' : 'Describe the vibe...';
                slotPromptInput.disabled = !extractor;

                const dice = document.createElement('button');
                dice.className = 'slot-dice';
                dice.innerHTML = '⚅';
                dice.setAttribute('aria-label', `Generate ${category.desc} pattern`);
                dice.title = `Roll for ${category.desc}`;
                dice.disabled = !extractor;

                const spice = document.createElement('button');
                spice.className = 'slot-spice';
                spice.innerHTML = '✦';
                spice.setAttribute('aria-label', `Add spice to ${category.desc} pattern`);
                spice.title = `Add spice - mutate current pattern`;
                spice.disabled = !extractor;

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'slot-delete-btn';
                deleteBtn.innerHTML = '×';
                deleteBtn.setAttribute('aria-label', 'Delete layer');
                deleteBtn.title = 'Delete layer';

                const textarea = document.createElement('textarea');
                textarea.className = 'slot-code';
                textarea.placeholder = category.name === 'tts'
                    ? 'Click ↻ to generate speech, then edit and press Enter to apply...'
                    : 'Click ↻ to generate, or enter Strudel code and press Enter...';

                const codeWrapper = document.createElement('div');
                codeWrapper.className = 'slot-code-wrapper';

                const emojiBackground = document.createElement('div');
                emojiBackground.className = 'slot-code-emoji';
                emojiBackground.textContent = category.icon;

                codeWrapper.appendChild(emojiBackground);
                codeWrapper.appendChild(textarea);

                controlsGroup.appendChild(slotPromptInput);
                controlsGroup.appendChild(dice);
                controlsGroup.appendChild(spice);
                controlsGroup.appendChild(deleteBtn);

                header.appendChild(leftGroup);
                header.appendChild(controlsGroup);
                slotDiv.appendChild(header);
                slotDiv.appendChild(codeWrapper);

                // Create slot object
                const slotObj = {
                    id: slotId,
                    code: '',
                    element: slotDiv,
                    diceButton: dice,
                    spiceButton: spice,
                    textarea: textarea,
                    promptInput: slotPromptInput,
                    muteButton: muteBtn,
                    deleteButton: deleteBtn,
                    isMuted: false,
                    category: category.name,
                    dragHandle: dragHandle
                };

                // Mute button handler
                muteBtn.addEventListener('click', () => {
                    slotObj.isMuted = !slotObj.isMuted;
                    muteBtn.classList.toggle('is-muted', slotObj.isMuted);
                    muteBtn.innerHTML = slotObj.isMuted ? '🔇' : '🔊';
                    slotDiv.classList.toggle('is-muted', slotObj.isMuted);
                    refreshPlayback();
                });

                // Delete button handler
                deleteBtn.addEventListener('click', () => {
                    slotDiv.classList.add('removing');
                    setTimeout(() => {
                        const index = slots.findIndex(s => s.id === slotId);
                        if (index !== -1) {
                            slots.splice(index, 1);
                        }
                        slotDiv.remove();
                        refreshPlayback();
                        updateStatus();
                    }, 300);
                });

                // Code change handler - apply on input
                textarea.addEventListener('input', () => {
                    slotObj.code = textarea.value.trim();
                });

                // Enter key handler - apply changes (Cmd/Ctrl+Enter for new line)
                textarea.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.metaKey) {
                        e.preventDefault();

                        // Add flash animation for visual feedback
                        textarea.classList.add('flash');
                        setTimeout(() => textarea.classList.remove('flash'), 400);

                        if (category.name === 'tts') {
                            // For TTS, regenerate with current text
                            const text = textarea.dataset.ttsText || slotPromptInput.value.trim() || 'Welcome';
                            const previousDiceIcon = dice.innerHTML;
                            dice.disabled = true;
                            dice.innerHTML = '⏳';

                            const ttsSampleName = `tts${slotId}`;
                            generateTTSSample(text, ttsSampleName).then(() => {
                                refreshPlayback();
                            }).catch(e => {
                                console.error('Error generating TTS:', e);
                            }).finally(() => {
                                dice.disabled = false;
                                dice.innerHTML = previousDiceIcon;
                            });
                        } else {
                            // For regular code, just refresh playback
                            if (!slotObj.isMuted && slotObj.code) {
                                refreshPlayback();
                            }
                        }
                    }
                });

                // Dice button handler
                dice.addEventListener('click', () => {
                    // Prevent multiple clicks while processing
                    if (dice.disabled) return;

                    if (category.name === 'tts') {
                        const text = slotPromptInput.value.trim() || 'Welcome to the Strudel Mixer';
                        slotPromptInput.value = text;

                        const originalStatus = statusEl.textContent;
                        statusEl.textContent = 'Generating speech...';

                        animateDiceRoll(dice, async () => {
                            const ttsSampleName = `tts${slotId}`;

                            try {
                                await generateTTSSample(text, ttsSampleName);

                                // Generate TTS with random effects/variations
                                const ttsVariations = [
                                    `s("${ttsSampleName}:0").speed(1)`,
                                    `s("${ttsSampleName}:0").speed(0.9).room(0.5)`,
                                    `s("${ttsSampleName}:0").speed(1.1).delay(0.25)`,
                                    `s("${ttsSampleName}:0").chop(4).speed(0.95)`,
                                    `s("${ttsSampleName}:0").chop(8).room(0.3)`,
                                    `s("${ttsSampleName}:0").speed("<1 0.9>").room(0.4)`,
                                    `s("${ttsSampleName}:0").striate(4).speed(0.95)`,
                                    `s("${ttsSampleName}:0").sometimes(x=>x.speed(0.8)).delay(0.3)`,
                                    `s("${ttsSampleName}:0").chunk(4, x=>x.fast(rand.range(0.8,1.2)))`,
                                    `s("${ttsSampleName}:0").speed(perlin.range(0.9,1.1)).room(0.5)`,
                                    `s("${ttsSampleName}:0").chop(16).speed(1.05)`,
                                    `s("${ttsSampleName}:0").fast(2).chop(2)`,
                                    `s("${ttsSampleName}:0").slow(2).room(0.7)`,
                                    `s("${ttsSampleName}:0").speed(1).hpf(200).lpf(3000)`,
                                    `s("${ttsSampleName}:0").speed(rand.range(0.85,1.15)).delay(0.4)`,
                                ];

                                // Avoid generating the same variation if there's already code
                                let ttsCode;
                                const currentCode = slotObj.code || '';
                                const availableVariations = ttsVariations.filter(v => v !== currentCode);

                                if (availableVariations.length > 0) {
                                    ttsCode = availableVariations[Math.floor(Math.random() * availableVariations.length)];
                                } else {
                                    ttsCode = ttsVariations[Math.floor(Math.random() * ttsVariations.length)];
                                }

                                slotObj.code = ttsCode;
                                textarea.value = ttsCode;
                                textarea.dataset.ttsText = text;

                                statusEl.textContent = 'Speech generated!';
                                setTimeout(() => {
                                    statusEl.textContent = originalStatus;
                                }, 2000);

                                if (!slotObj.isMuted) {
                                    refreshPlayback();
                                }
                            } catch (e) {
                                console.error('Error generating TTS:', e);
                                statusEl.textContent = 'TTS generation failed';
                                setTimeout(() => {
                                    statusEl.textContent = originalStatus;
                                }, 3000);
                            }
                        });
                    } else {
                        // Category-specific default prompts for cohesive minimal techno
                        const defaultPrompts = {
                            drums: 'minimal techno kick, sparse crisp hi-hats, deep bass drum, hypnotic groove',
                            bass: 'minimal techno pulse, hypnotic repetitive throb, stripped-down club tool',
                            melody: 'minimal sparse synth line, subtle melodic movement, understated techno',
                            chords: 'minimal dark pad, subtle harmonic movement, moody techno atmosphere',
                            texture: 'minimal atmospheric detail, subtle background texture, sparse hi-hats'
                        };

                        const prompt = slotPromptInput.value.trim() || defaultPrompts[slotObj.category] || 'minimal techno';

                        animateDiceRoll(dice, async () => {
                            try {
                                let result = await generatePatternFromPrompt(prompt, slotObj.category);

                                // If we got the exact same code, try one more time
                                if (result.code === slotObj.code) {
                                    result = await generatePatternFromPrompt(prompt, slotObj.category);
                                }

                                slotObj.code = result.code;
                                textarea.value = result.code;

                                // Update the prompt input with the pattern's description
                                slotPromptInput.value = result.description;

                                if (!slotObj.isMuted) {
                                    refreshPlayback();
                                }
                            } catch (e) {
                                console.error('Error generating pattern:', e);
                            }
                        });
                    }
                });

                // Spice button handler - mutate existing pattern
                spice.addEventListener('click', () => {
                    // Prevent multiple clicks while processing
                    if (spice.disabled) return;

                    // Need existing code to mutate
                    if (!slotObj.code || !slotObj.code.trim()) {
                        console.log('No pattern to spice up - roll the dice first!');
                        return;
                    }

                    if (category.name === 'tts') {
                        // For TTS, apply spice to the existing TTS code
                        animateDiceRoll(spice, async () => {
                            const currentCode = slotObj.code;
                            const spicedCode = spiceUpPattern(currentCode, category.name);

                            if (spicedCode !== currentCode) {
                                slotObj.code = spicedCode;
                                textarea.value = spicedCode;

                                if (!slotObj.isMuted) {
                                    refreshPlayback();
                                }
                            }
                        }, 'spicing');
                    } else {
                        // For regular patterns, apply mutations
                        animateDiceRoll(spice, async () => {
                            const currentCode = slotObj.code;
                            const spicedCode = spiceUpPattern(currentCode, category.name);

                            if (spicedCode !== currentCode) {
                                slotObj.code = spicedCode;
                                textarea.value = spicedCode;

                                if (!slotObj.isMuted) {
                                    refreshPlayback();
                                }
                            }
                        }, 'spicing');
                    }
                });

                // Prompt input Enter key handler - trigger dice roll
                slotPromptInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !dice.disabled) {
                        e.preventDefault();
                        dice.click();
                    }
                });

                // Drag and drop handlers
                dragHandle.addEventListener('dragstart', (e) => {
                    slotDiv.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', slotId);
                });

                dragHandle.addEventListener('dragend', () => {
                    slotDiv.classList.remove('dragging');
                    document.querySelectorAll('.slot').forEach(el => el.classList.remove('drag-over'));
                });

                slotDiv.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    const dragging = document.querySelector('.dragging');
                    if (dragging && dragging !== slotDiv) {
                        slotDiv.classList.add('drag-over');
                    }
                });

                slotDiv.addEventListener('dragleave', () => {
                    slotDiv.classList.remove('drag-over');
                });

                slotDiv.addEventListener('drop', (e) => {
                    e.preventDefault();
                    slotDiv.classList.remove('drag-over');

                    const draggedId = parseInt(e.dataTransfer.getData('text/plain'));
                    const draggedSlot = slots.find(s => s.id === draggedId);
                    const targetSlot = slots.find(s => s.id === slotId);

                    if (draggedSlot && targetSlot && draggedSlot !== targetSlot) {
                        // Reorder in array
                        const draggedIndex = slots.indexOf(draggedSlot);
                        const targetIndex = slots.indexOf(targetSlot);

                        slots.splice(draggedIndex, 1);
                        slots.splice(targetIndex, 0, draggedSlot);

                        // Reorder in DOM
                        slotsGrid.innerHTML = '';
                        slots.forEach(slot => slotsGrid.appendChild(slot.element));

                        refreshPlayback();
                    }
                });

                return slotObj;
            };

            // Create add layer buttons for each category
            slotCategories.forEach(category => {
                const addBtn = document.createElement('button');
                addBtn.className = 'add-slot-btn';
                addBtn.style.setProperty('--category-color', category.color);

                const emoji = document.createElement('div');
                emoji.className = 'add-slot-btn-emoji';
                emoji.textContent = category.icon;

                const label = document.createElement('div');
                label.className = 'add-slot-btn-label';
                label.textContent = category.desc;

                addBtn.appendChild(emoji);
                addBtn.appendChild(label);
                addBtn.title = `Add ${category.desc} layer`;

                addBtn.addEventListener('click', () => {
                    const slot = createSlot(category.name);
                    slots.push(slot);
                    slotsGrid.appendChild(slot.element);
                    updateStatus();
                });

                addSlotContainer.appendChild(addBtn);
            });

            // Update status message
            const updateStatus = () => {
                const activeCount = slots.filter(s => !s.isMuted && s.code).length;
                statusEl.textContent = `${slots.length} layers (${activeCount} active)${sampleStatusSuffix}`;
            };

            masterVolumeSlider.addEventListener('input', () => {
                masterVolume = parseFloat(masterVolumeSlider.value);
                refreshPlayback();
            });

            masterReverbSlider.addEventListener('input', () => {
                masterReverb = parseFloat(masterReverbSlider.value);
                refreshPlayback();
            });

            if (creativitySlider) {
                creativitySlider.addEventListener('input', () => {
                    creativity = parseFloat(creativitySlider.value);
                    // Update status briefly to reflect change
                    statusEl.textContent = `Creativity: ${Math.round(creativity * 100)}%`;
                    setTimeout(() => updateStatus(), 900);
                });
            }

            const refreshPlayback = () => {
                if (!schedulerApi) {
                    console.warn('Scheduler is not ready yet.');
                    return;
                }

                // Collect all unmuted slots with code
                const activePatterns = [];
                slots.forEach((slot, index) => {
                    if (!slot.isMuted && slot.code) {
                        try {
                            console.log(`Evaluating slot ${slot.id} (${slot.category}):`, slot.code);
                            const pattern = eval(slot.code);
                            console.log(`Slot ${slot.id} pattern:`, pattern);
                            activePatterns.push(pattern);
                        } catch (e) {
                            console.error(`Error evaluating slot ${slot.id}:`, e);
                            console.error('Code was:', slot.code);
                        }
                    }
                });

                if (activePatterns.length === 0) {
                    if (schedulerApi?.hush) {
                        schedulerApi.hush();
                    } else if (typeof window.hush === 'function') {
                        window.hush();
                    }
                    updateStatus();
                    return;
                }

                // Stack all active patterns together
                let mixedPattern = stack(...activePatterns);

                // Apply master controls
                if (masterVolume !== 1) {
                    mixedPattern = mixedPattern.gain(masterVolume);
                }

                if (masterReverb > 0) {
                    mixedPattern = mixedPattern.room(masterReverb);
                }

                try {
                    if (schedulerApi?.setPattern) {
                        schedulerApi.setPattern(mixedPattern, false);
                    } else {
                        mixedPattern.play();
                    }
                } catch (e) {
                    console.error('Error setting pattern:', e);
                }

                updateStatus();
            };

            // Enable prompt inputs when AI model is ready
            if (extractor) {
                // AI is ready, users can add slots
            }

            stopDiceAnimation();
            updateLoadingProgress('All systems ready!');
            statusEl.textContent = `Ready! ${sampleStatusSuffix}`;

            // Hide loading screen with a slight delay
            setTimeout(() => {
                loadingScreen.classList.add('hidden');
            }, 500);

            // Pre-warm TTS samples in the background (optional)
            // This helps avoid audio freezing during playback
            // Uncomment the next line to enable:
            // preWarmTTS();

        })().catch((error) => {
            console.error('Strudel init failed', error);
            const statusEl = document.getElementById('status');
            const loadingProgress = document.getElementById('loading-progress');
            const loadingScreen = document.getElementById('loading-screen');

            loadingProgress.textContent = '❌ Failed to load. Check console for details.';
            statusEl.textContent = 'Could not load Strudel. Please check the console for details.';

            // Still hide loading screen after error
            setTimeout(() => {
                loadingScreen.classList.add('hidden');
            }, 3000);
        });
    </script>
</body>

</html>